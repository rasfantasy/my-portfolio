[{"header":"QA Теория: базовая теория","links":[{"title":"Что такое тестирование?","data":{"code":"-","description":"<b>Тестирование</b> - это процесс проверки продукта (например программы) на соответствие требованиям, выявлении ошибок и его работы в разных условиях. Проще говоря это сверка ожидаемого результата с фактическим результатом.\n\nСуть тестирования в трёх тезисах\n1. Проверяем соответствие ожиданиям.\nЕсть требования &gt; формируем ожидания &gt; проверяем реальное поведение.\n2. Ищем расхождения.\nЛюбое отличие - потенциальный дефект, риск или недочёт.\n2. Повышаем качество продукта, но не гарантируем его.\nТестирование снижает риск, но не делает продукт безошибочным.\n\nЧто включает тестирование:\n- анализ требований - проверяем логику;\n- дизайн тестов - выбираем техники;\n- подготовка данных и окружения;\n- выполнение тестов;\n- фиксация результатов;\n- оформление багов;\n- проверка исправлений.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-55.vkuserphoto.ru/s/v1/ig2/4hkKpfsLQPruHpWg0srJ6rjJ7ZdkG47-7lA_rOZ_LDpRd8htow63ubQCREY_7qfy_pzY9JTFpeDezS6VC5MyK1h-.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x59,240x89,360x133,480x178,540x200,640x237,720x267,1080x400,1280x475,1300x482&amp;from=bu&amp;cs=1300x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Что такое качество?","data":{"code":"-","description":"<b>Что такое качество</b> - это совокупность характеристик ПО и его функционала. Которая удовлетворяет поставленные и предполагаемые потребности. Так же это степень требуемых свойств ПО. Есть определённые стандарты ISO качества международные, так же есть субъективные ощущения качества. \n\nТри ключевых точки качества:\n<b>1. Требования</b> - формальные ожидания: функционал, UX, безопасность, производительность.\n<b>2. Пользователи</b> - реальная применимость, удобство.\n<b>3. Бизнес </b>- продукт должен решать задачу, а не просто существовать.\n\n<b>Пример:</b> Создана идеальная кнопка \"Купить\", без багов.\nНо:\n- процесс покупки неудобный &gt; качество UX низкое\n- оплату не принимает половина банков &gt; качество функционала низкое\n- работает только с VPN &gt; качество доступности низкое\n- отвратительный дизайн &gt; качество восприятия низкое\nТо, что \"багов нет\" - не означает, что \"качество есть\".\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/pW5_92_0sXHT8T34OXLR4p-DLbcdAu6rXGC58WdJ76673pA0NErBdam3E1BDr77ylQ43_Za3uQNaDNPLcOSKm7b_.jpg?quality=95&amp;as=32x19,48x28,72x42,108x64,160x94,240x142,360x213,480x283,540x319,640x378,720x425,1080x638,1280x756,1377x813&amp;from=bu&amp;cs=1377x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Отличие QA/QC и тестировщика","data":{"code":"-","description":"<b>QA (Quality Assurance) </b>- (человек про процессы) следит за качеством продукта в целом, документацию и следит за тем чтоб минимизировать ошибки изначально (допустим ревью тест кейсов), организует тестирование, улучшает процессы.\n<b>QC (Quality Control)</b> - Проверяет продукт на наличие ошибок, соответствие требованиям и стандартам. Это больше про проверку качества после разработки. А так же проверка релиза в общем.\n<b>Тестировщик (часть QC)</b> - проходит тест кейсы, выявляет баги ошибки и недоработки, и сообщает о них. Пишет тест кейсы, проверяет функциональность. \n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-32.vkuserphoto.ru/s/v1/ig2/o0hdNfBoY7817LhtkU2TYRC4_FZfclPjQa_awP4QdM9XrWhLrZ6KV8ab7g8R5H1pQLAiOekNZ73DA7Qz3_cQntu0.jpg?quality=95&amp;as=32x17,48x25,72x38,108x57,160x84,240x126,360x189,480x252,540x283,640x336,720x378,1080x567,1200x630&amp;from=bu&amp;cs=1200x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Принципы тестирования","data":{"code":"-","description":"Принципы тестирования помогают делать работу тестировщика эффективной и понятной\n\n<b>1) Тестирование показывает наличие ошибок, но не их отсутствие:</b> Тесты помогают найти баги, но они не гарантируют что их больше нет.\nНапример: Вы протестировали форму логина и нашли несколько багов (например неправильная проверка пароля). После исправленая багов вы повторно тестируете и не находите новых. Но это не значит, что в системе нет других скрытых ошибок. \n<b>2) Исчерпывающее тестирование невозможно:</b> проверить абсолютно всё в системе нельзя, поэтому тестировщик выбирает самые важные сценарии. \nНапример: вы тестируете интернет-магазин. Проверить как работает кнопка \"Купить\" с каждым товаром, на всех браузерах, на всех языках и устройствах, физически нереально. Поэтому вы выбираете самые важные варианты (например, популярные браузеры или устройства)\n<b>3) Раннее тестирование.</b> Тестирование стоит начинать как можно раньше, что бы найти ошибки еще на этапе проектирования или разработки. (Это экономит время и деньги)\nНапример: Если в начале проектирования выяснится, что требования к функционалу противоречат друг другу или есть какие то неточности, это можно сразу исправить. Если же вы обнаружите это в готовой системе, придётся переделывать код, что дороже и дольше.\n<b>4) Скопление дефектов: </b>большинство багов сосредоточено в небольшом количестве функций или модулей. \nНапример: Вы замечаете, что баги чаще всего воздникают в модуле \"Оплата\", а другие части работают стабильно. Это значит что модуль \"Оплата\" требует более пристального внимания, возможно, из-за сложной логики.\n<b>5) Парадокс пестицида:</b> Если повторять одни и те же тесты, они перестают находить новые баги. Тесты нужно регулярно обновлять.\nНапример: вы проверяете форму регистрации одним и тем же набором данных (ПРАВИЛЬНЫЕ И НЕПРАВИЛЬНЫЕ ЛОГИНЫ/ПАРОЛИ). Со временем разработчики исправляют эти баги, но остаются другие проблемы (например, с обработкой специальных символов), которые ваши тесты не покрывают. \n<b>6) Тестирование зависит от контекста</b> - подход к тестированию зависит от особенностей проекта.\nНапример: Вы тестируете мобильное приложение, важно проверить работу на разных устройствах и версиях ОС. Если это банковская система, ключевое внимание будет на безопасности и точности расчётов. \n<b>7) Отсутствие ошибок не показатель качества:</b> даже если багов нет, продукт может не удовлетворять потребности пользователя или бизнеса. \nНапример: Вы протестировали систему бронирования и не нашли ошибок. Но пользователи жалуются, что интерфейс неудобный, бронирование занимает слишком много времени, и важные функции сложно найти. Это значит, что продукт не удовлетворяет их потребности.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-4.vkuserphoto.ru/s/v1/ig2/0vf4CTPOxcEP4zqtq1ZTEf44uvhRJOc_5J9p-MMZzqargeB2qaZqAohi0NDmi7ZQIsnOtB-xYrk0gf78b9r0Hdx_.jpg?quality=95&amp;as=32x17,48x25,72x38,108x56,160x84,240x125,360x188,480x251,540x282,640x334,720x376,1080x564,1280x668,1440x752&amp;from=bu&amp;cs=1440x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Ошибка (Error)/Дефект (Defect)/Баг (Bug) отличие","data":{"code":"-","description":"Во время разработки всегда присуще ошибаться. И очень важно отличать то или иное на этих этапах.\n<b>Ошибка (Error)</b> - это когда разработчик совершил ошибку в своей локальной среде в коде.\n<i>Например:</i> пропустил запятую, или неправильно написал регулярное выражение для расчетов.\n<b>Дефект (Defect)</b> - это когда после ошибки (error) разработчик отправил свой код в общий проект. На этом этапе все еще не определено наличие дефекта.\n<b>Баг (Bug)</b> - вот тут как раз при тестировании если находится дефект (defect), тестировщик заводит баг (bug) и отправляет в баг трекер.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-62.vkuserphoto.ru/s/v1/ig2/Pt6_T5AoPaieiTtJQIuCowTK9Xo7qAuopsGJxJfpriFLvtIMzKjV86n4Ryeyl2iy7nnq-l7U8-aDV-r-kDe9eD8B.jpg?quality=95&amp;as=32x28,48x42,72x63,108x94,160x140,240x210,327x286&amp;from=bu&amp;cs=327x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Верификация и валидация","data":{"code":"-","description":"<b>Верификация</b> - соответствие продукта требованиям (спецификациям).\n<i>Например:</i> велосипед - у него присутствуют 2 колеса, 2 педали, сиденье и руль. По спецификациям он полностью является велосипедом.\n<b>Валидация</b> - соответствие продукта потребностям пользователей.\n<i>Например:</i> велосипед - при нажатии на педали велосипед должен ехать, при повороте руля велосипед меняет направление, сиденье удобное и мягкое. \n\n<b>Пример из разработки:</b>\nСтраница корзины \nВерификация - присутствует список товаров в корзине, присутствует кнопка оплаты, есть кнопка очистки корзины\nВалидация - при клике на очистку корзины она должна очищаться, при клике на товар открывается детальная информация о товаре, при клике на кнопку \"Оплата\" происходит переход на страницу оплаты\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/wKHOabh6YGgQMIeepHQj2C8jawh4Vr4wLaXKFxM3nl8MC2pnSu6OwXM_DWedhrFdziccARkwcFBm1xXhA63aATW_.jpg?quality=95&amp;as=32x21,48x32,72x48,108x72,160x107,240x160,360x240,480x320,540x360,640x427,720x480,1024x683&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Идентификация/Аутентификация/Авторизация разница","data":{"code":"-","description":"<b>Идентификация </b>- понять кто стучится в систему. Используются логины/email/номер телефона. Позволяет идентифицировать пользователя.\n<b>Аутентификация</b> - проверка пользователя на то что он действительно является тем кем он представился. Существует однофакторная аутентификация (логин/пароль) и двухфакторная (логин/пароль) + смс на номер телефона/totp.\n<b>Авторизация</b> - наделение пользователя определёнными правами (ролями) после того как система проверила идентификатор и успешно пройдена аутентификация. \n\n<b>Например:</b>\nпользователь зашёл на сайт, в нём необходимо авторизоваться.\nПользователь вводит идентификатор - email\nСистема определила что данный идентификатор существует в базе\nДалее пользователь производит аутентификацию - вводит пароль\nСистема определила что идентификатор и аутентификация подходят\nДалее система выдаёт права/роли в зависимости от идентификатора\nВ нашем случае это может быть обычный пользователь сайта\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-85.vkuserphoto.ru/s/v1/ig2/36wGvDxyC7zR8b6p7nYrALEEmNbXrCpkmKDeftdj5fj992FbjlwVmlLrzDQU6fGfsB2syq4d1ogbVn8YCQNpVD8B.jpg?quality=95&amp;as=32x18,48x28,72x41,108x62,160x92,240x138,360x207,480x275,540x310,640x367,720x413,934x536&amp;from=bu&amp;cs=934x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Виды тестирования","data":{"code":"-","description":"<h4>По цели тестирования:</h4>\n\t<b>1) Функциональные:</b>\n\t- проверка функциональности согласно требованиям\n\t<b>2) Нефункциональные:</b>\n\t- UI (пользовательский интерфейс)\n\t- UX (опыт пользователя/удобство пользования)\n\t- Тестирование безопасности (Security Testing)\n\t- Тестирование локализации (Localization Testing)\n\t- Тестирование установки (Installability Testing)\n\t- Тестирование производительности (Perfomance Testing) (Стабильность/Стрессовое/Нагрузочное)\n\n<h4>По знанию системы:</h4>\n1) Черный ящик\n2) Серый ящик\n3) Белый ящик \n\n<h4>Связанные с изменениями:</h4>\n1) Smoke\n2) Sanity\n3) Regression\n4) Re-test\n\n<h4>По сценариям:</h4>\n1) Позитивное\n2) Негативное\n\n<h4>По степени автоматизации:</h4>\n1) Ручное\n2) Автоматизированное\n\n<h4>По исполнению кода:</h4>\n1) Статическое\n2) Динамическое\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-35.vkuserphoto.ru/s/v1/ig2/3XW4Wmcsf8PsDLqOkEAPE_TztjVKOPLhbQ5oD-3wO27lNNwdKFhEzO0XFkBuOQWkDxwDTvXYtjbU-nGu0JqSOU34.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x75,240x113,360x170,480x226,540x255,640x302,720x340,1080x510,1280x604,1440x679,1793x846&amp;from=bu&amp;cs=1793x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Smoke/Sainty/Regress/Retest тестирование","data":{"code":"-","description":"<b>Smoke (дымовое) тестирование </b>- быстрое тестирование базового функционала ПО (критически важного) после серьёзных изменений. Цель данного тестирование это ПО стартует и выполняет основные бля бизнеса функции.\n<b>Например:</b> После изменения/внедрения системы авторизации необходимо проверить корректность перехода на страницу авторизации и возможность авторизоваться. Если страница не загружается или не работают кнопки то дальнейшие проверки прекращаются.\n<hr>\n<b>Sanity (санитарное)</b> - углубленная проверка какой то функциональности. Локальное тестирование 1 фичи которую разработали. \n<b>Например: </b>на главной странице добавлен виджет погоды. Вот его и проверяют полностью, а не всю главную страницу.\n<hr>\n<b>Regression (регресс) тестирование</b> - после неких изменений в функционале ПО необходимо проверить что весь предыдущий функционал работает.\n<b>Например:</b> На главную страницу добавили виджет погоды, необходимо проверить что главная страница отображается корректно и весь старый функционал работает.\n<hr>\n<b>Re-test (Повторное) тестирование</b> - проверка исправления бага (тестирование во время которого исполняются те же сценарии приводившие к багу, дабы удостовериться успешности исправления этих ошибок) \n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-59.vkuserphoto.ru/s/v1/ig2/Dh01oD2TLEreKr9RIUIVlM2yp53eMCcq_mGO1sXwJXMG72AoHVgldnMEJoiGEUyqn_LjGPGaPHbi6pUqgKLFEF1o.jpg?quality=95&amp;as=32x20,48x31,72x46,108x69,160x102,240x154,360x230,480x307,540x346,640x410,720x461,800x512&amp;from=bu&amp;cs=800x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Черный белый и серый ящики","data":{"code":"-","description":"<b>Черный ящик</b> - у тестировщика отсутствует доступ к коду, к базам данных. Тестирование проводится на уровне пользователя со входящими и исходящими данными. Тут тестируется функциональность.\n<b>Например:</b> тестировщик проверяет функциональность нажатия на кнопку \"Купить\", то что она действительно выполняет нужное действие, не зная как именно она реализована в коде.\n<hr>\n<b>Белый ящик</b> - у тестировщика присутствует доступ к коду, базам данных, знает архитектуру разрабатываемого ПО изнутри. Используется для unit-тестов как разработчиками так и тестировщиками. \n<b>Например:</b> тестировщик видит код функции и все её входящие параметры и проверяет всевозможные пути выполнения этого кода. \n<hr>\n<b>Серый ящик</b> - у тестировщика неполный доступ ко всему проекту. У него есть документация по API, доступ к БД но нет полного представления архитектуры разрабатываемого приложения только частичное. \n<b>Например:</b> Тестировщик проверяет кнопку \"Оплатить\", знает её API запрос но не видит весь код обработки на сервере.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-17.vkuserphoto.ru/s/v1/ig2/-qS5peNLTa-1rGzFoJzF2HbHRl855V6x0Zs4dSVm8OsOhBKPgLfVUpK4ME6vGjj4ku3ZdYC1aNPheeCSTvsNwKvF.jpg?quality=95&amp;as=32x15,48x22,72x33,108x50,160x74,240x110,360x166,480x221,540x248,640x294,720x331,1024x471&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Пирамида тестирования","data":{"code":"-","description":"<b>Пирамида тестирования</b> - это модель распределения тестирования, которая показывает, какие типы тестов и в каком количестве должны быть в проекте. Чтобы система была качественной, а разработка - быстрой и дешёвой.\n<b>Цели: </b>\n- максимизировать скорость обратной связи\n- минимизировать стоимость поддержки тестов\n- ловить дефекты как можно раньше\n\n\n<h4>Структура пирамиды (снизу вверх)</h4>\n<h5>1. Unit tests  (Юнит тесты) - основание </h5>\n<b>Что это:</b> тесты отдельных модулей / функций / классов в изоляции. В большинстве случаев данный вид тестирования выполняется самими разработчиками. Он самый большой и самый важный. Если изначально что то будет не работать на этом этапе то на следующих этапах будут большие проблемы. (Если следующих этапах тестирования выявится дефект, то исправления будут стоить намного дороже)\n<b>Что проверяют:</b>\n- находить ошибки на фундаментальных уровнях\n- граничные условия\n- ошибки алгоритмов\n<b>Характеристики:</b>\n- очень быстрые\n- очень дешёвые\n- тестирование на уровне белого ящика\n<b>Зачем:</b>\n- Ловят большинство логических багов на самом раннем этапе. На этом этапе нахождение багов быстро правятся т.к. даже не создаются баг репорты. Разработчик - видит баг и тут же его исправляет. \n\n<h5>2. Integration tests - середина</h5>\n<b>Что это: </b> идёт после юнита, тут главное чем быстрее и качественней тем лучше. Тут берутся отдельные модули и производятся попытки их скрестить, посмотреть поведение и выявить дефекты. Проверка взаимодействия между модулями.\n- Проверка взаимодействия компонентов:\nсервис &lt; &gt; БД\nсервис &lt; &gt; сервис\nAPI &lt; &gt; бизнес-логика\n<b>Что проверяют:</b>\n- контракты\n- конфигурации\n- схемы данных\n- сериализацию\n<b>Чего НЕ проверяют:</b>\n- полноценный пользовательский сценарий\n<b>Характеристики:</b>\n- быстрые\n- дешевые\n- на этом уровне используется либо серый, либо черный ящик\n\n<h5>3. System Testing - верхушка</h5>\n<b>Что это:</b> это тестирование полностью собранной системы как единого целого, проверка функциональных и нефункциональных требований. Проверяется система целиком, все её требования от важных до неважных.\n<b>Что проверяют system tests</b>\n- бизнес-сценарии на уровне системы\n- функциональные и нефункциональные  требования\n- верифицировать требования\n<b>Характеристики</b>\n- средняя скорость\n- средняя стоимость\n- тестирование на уровне черного ящика\n<b>Инструменты:</b>\n- REST clients\n- API автотесты\n- тесты по спецификациям и т.д.\n\n<h5>4. End-to-End (E2E) / (Приемочное тестирование) - вершина</h5>\n<b>Что это:</b> тестирование от пользователя, как он будет пользоваться продуктом, соответствует ли потребностям. Пользовательские сценарии в общем. \n<b>Что проверяют: </b>\n- интеграцию всего стека по сценариям пользователя\n- валидацию требований\n<b>Характеристики:</b>\n- медленные\n- дорогие\n- тестирование на уровне черного ящика\n<b>Зачем:</b>\n- Проверяют ценность для пользователя, а не код.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-70.vkuserphoto.ru/s/v1/ig2/JDrYA7hIu8mZagHiEwxqCWsJYXGucmhdlVGOuXgGfur6RYJr771IXl0YbSqS9T6zF3KllyuSJ-FAU3oN_gYkxQre.jpg?quality=95&amp;as=32x21,48x32,72x48,108x72,160x106,240x159,360x239,480x319,540x359,640x425,720x478,1080x717,1197x795&amp;from=bu&amp;cs=1197x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n\nЧем выше тесты уровнем, тем они:\n- сложней в реализации, и соответственно, дороже в реализации;\n- важнее для бизнеса и критичней для пользователей;\n- замедляют скорость прохождения тестовых наборов, например, регресса\n","path":"-"}},{"title":"Модели разработки ПО","data":{"code":"-","description":"<hr>\n<b>Водопадная модель</b> - состоит из 4х этапов: проектирование &gt; кодирование &gt; тестирование &gt; эксплуатация.\nСамая простая модель, одна из очень дорогих т.к. при выявлении проблем на каком то из стадий нужно полностью начинать сначала все этапы разработки. Чем глубже проблема, тем дороже разработка. Например если во время тестирования выявлен какой то критический баг, то цепочка будет начинаться с проектирования. И каждый раз это платно для компании (хорошо для разрабов и тестировщика)\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-65.vkuserphoto.ru/s/v1/ig2/8J5Kzv-fGNaKtTPdSX8M5fv_VHxyXz_5LnZ4QGB3NaS5XHb4lba73sFvYSUKWdQolA2kgS4L-8yvI4G3jcMaD3Jz.jpg?quality=95&amp;as=32x21,48x31,72x47,108x71,160x105,240x157,360x235,476x311&amp;from=bu&amp;cs=476x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n<hr>\n<b>V образрая модель</b> - состоит из 9 этапов: Бизнес-требования &gt; Функциональные требования &gt; Архитектура системы &gt; Архитектура компонентов &gt; Разработка &lt; Модульное тестирование &lt; Интеграционное тестирование &lt; Функциональное тестирование &lt; Приемочное тестирование.\nНа каждый этап разработки присутствует своё тестирование: \n1) Архитектура компонентов = Модульное тестирование. На этом этапе тестируют сами разработчики. \n2) Архитектура системы = интеграционное тестирование\n3) Функциональные требования = функциональное тестирование \n4) Бизнес-требования = приёмочное тестирование \nЭто подобие треугольника разработки, чем ниже проблема, тем быстрее и дешевле её исправить. Например если проблема произошла на этапе модульного тестирования, то этап начинается на стадии архитектуры компонентов. И дальше опять разработка. Если же проблема произошла на стадии \"приёмочное тестирование\" то (например заказчик сказал что весь интернет магази фигня и нужно переделать), то начинается самый первый этап \"Бизнес-требования\", и это очень дорого для компании(клиента) и хорошо для разрабов/тестировщиков т.к. цикл увеличивается и больше денег заносится за работу.\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-22.vkuserphoto.ru/s/v1/ig2/WY2ZTZ406giFzvU1JryPhKIwZCfaONwYpxaKV53dZsIOZLt6fF3RPaSw9SIaricMd0mbcrT3tUa73vZP5UAaEijb.jpg?quality=95&amp;as=32x20,48x30,72x44,108x67,160x99,240x148,360x222,480x296,540x333,640x395,720x444,1024x632&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n<hr>\n<b>Инкрементальная модель (Иттеративная модель подраздел)</b> - состоит из \"Идея\" от неё стартует цикл из: Планирование &gt; Требования &gt; Проектирование &gt; Разработка &gt; Тестирование &gt; Оценка (и так по кругу). После цикла &gt; Развертывание (Релиз). Получается тут по кусочкам какой то функционал реализуется и развертывается (релизится). И этот цикл пока полностью всё проектирование не закончится по результатам оценки и т.п. Отличие Иттеративной модели в том что этот цикл маленький, небольшая разработка/дополнение к действующей системе). У этой модели более удобная разрабокта по быстроте разработки т.к. каждый цикл проверяется и в случае чего возвращается обратно. Тестировщик тут в основном только на 1 этапе работает, но иногда может быть привлечён на каком то этапе. \n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-70.vkuserphoto.ru/s/v1/ig2/O2I_quO4SWyeqW9G3JoNBa04yf-B_XNzLSQCbW1IB-iwLmRBI7sbvAA11ep4-mBLGpRbBYA4N9eYSI_r-Cx8DomV.jpg?quality=95&amp;as=32x11,48x17,72x25,108x38,160x57,240x85,360x127,480x170,540x191,620x219&amp;from=bu&amp;cs=620x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n<hr>\n<b>Спиральная модель</b> - Есть некая модель из оси X и Y. Допустим есть идея (Планирование) &gt; Далее Этап Анализа Рисков &gt; Разработка (Планы, усилия, сама идея) &gt; Оценка (Если план нормальный то следующий этап). И это начинается от идеи до реальной разработки и тестирования. Спираль разворачивается постоянно. Тестировщик работает на этапе разработки (допустим разрабатывать тестплан/тесткейс и тестирование функциональности ОР от ФР). (По ней никто не работает в компаниях). \n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-82.vkuserphoto.ru/s/v1/ig2/BeLETGMDk6nzCh5w1en4duS1i-lCJrmN-fabPOPTj1xsTgh-87w6rfv7_S3egFWlwhVyqMHQXnZ42ctfAKkClGlj.jpg?quality=95&amp;as=32x27,48x40,72x60,108x90,160x133,240x200,360x300,480x400,540x450,640x533,720x600,1080x900,1200x1000&amp;from=bu&amp;cs=1200x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n<hr>\n<b>Гибкая модель (agile / scrum) (Самый популярный)</b> - по ней работают многие команды (или пытаются по ней). Шаги, изначально \"Старт\", далее от него цикл Планирование &gt; Разработка &gt; тестирование &gt; Демонстрация. После чего происходит отдельный шаг от этого цикла \"Внедрение\" - оно опциональное, по мере разработки. \nТак же в нём есть \"Спринт\" - это отрезок времени на разработку продукта (участка продукта, модуля, функицональности). Допустим команде дали 2 недели, и за эти 2 недели должен быть результат (Спринт) по шагам сверху \"Старт...Внедрение\". \nВ скраме есть \"Бэклог\" - некий артефакт, это подобие списка требований и функциональности продукта. Есть бэклог всего проекта и определённого спринта. \n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/kukvU1HpXPLjbxE-dkUC2A7YMgdIoScPJjhHpOHOb4qT5DsM8ABSpA7Qfkep7iljd2-wDWYEKDZS5Mu8SGtJYN2T.jpg?quality=95&amp;as=32x18,48x28,72x41,108x62,160x92,240x138,360x206,480x275,540x310,640x367,720x413,1080x620,1280x734,1426x818&amp;from=bu&amp;cs=1426x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n<hr>\n<b>Модель хаоса (самая любимая в компаниях)</b> - существует, по ней работают и вполне на стартапе живут. Отсутствие каких либо правил разработки. Кто где и как в разный момент разработки вклинивается тестировщик и т.п.","path":"-"}},{"title":"SCRUM/Agile","data":{"code":"-","description":"<b>Гибкая модель (agile / scrum) (Самый популярный)</b> - по ней работают многие команды (или пытаются по ней). Шаги, изначально \"Старт\", далее от него цикл Планирование &gt; Разработка &gt; тестирование &gt; Демонстрация. После чего происходит отдельный шаг от этого цикла \"Внедрение\" - оно опциональное, по мере разработки. \n<b>Так же в нём есть \"Спринт\"</b> - это отрезок времени на разработку продукта (участка продукта, модуля, функицональности). Допустим команде дали 2 недели, и за эти 2 недели должен быть результат (Спринт) по шагам сверху \"Старт...Внедрение\". \n<b>В скраме есть \"Бэклог\"</b> - некий артефакт, это подобие списка требований и функциональности продукта. Есть бэклог всего проекта и определённого спринта. \n\n<b>Пример беклога:</b> в задачах проекта около 250 задач. И в спринте команда (разраб, скраммастер, тестировщик и т.п.) не может сразу взять все 250 задач на себя. Они берут допустип 5 задач из общего беклога и выставляю временные метки выполнения (Спринта). И эти 5 задач уходят в бэклог спринта. Тестировщик в скраме может во время спринта не работать именно над этим спринтом (Завимсит от ситуаций). Допустим: первый спринт прошёл у разрабов на 1ю неделю, то на 2ю неделю тестировщик тестирует предыдущий спринт, а на этой неделе на 2й разрабы уже делают новый спринт. \n\nТак же в скраме перед спринтом происходит \"митинг\" (планёрка), тут обсуждаются роли, кто что и когда делает. Так же обсуждается предыдущий спринт. \n\n<b>ЦЕЛЬ СПРИНТА</b> - ПО ИТОГУ временного отрезка, показать видимый результат. Чтоб было что показать. \nТак же есть Дейли митинг - ежедневная планёрка. На которой каждый участник команды должен ответить на 3 вопроса: что я сделал вчера, что я буду делать сегодня, и какие у меня были проблемы. \n\n<b>Роли в команде:</b>\n2 типа существует. Свиньи и Куры. \nСвиньи это те кто полностью вовлечены в этот проект.\nКурицы это те кто вовлечён в проект лишь частично.\n(Это из анекдота. Как то Свинья и Курица решили создать кафе. И Свинья говорит курице, как назовём заведение? Курица отвечает: Бекон и яишница. Свинья говорит: нет так не пойдёт. Курица отвечает: почему? Свинья ей в ответ: потому что я учавствую там полностью, а ты лишь частично)\nСвиньи: скраммастер (менеджер проекта), продуктовнер (заказчик владелец продукта или выделенный человек отвечающий за продукт), участники команды разработки (разрабы, тестировщики, дизайнеры и т.д.)\nКак правило команда свиней состоит из 5-9 человек (очень редко больше, меньше тоже редко).\nКуры: пользователи, не учавствующие в разработке но учавствуют в пользовании продукта. Так же есть стэкхолдеры - инициаторы проекта, те кто принимают итоговый результат. \n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/kukvU1HpXPLjbxE-dkUC2A7YMgdIoScPJjhHpOHOb4qT5DsM8ABSpA7Qfkep7iljd2-wDWYEKDZS5Mu8SGtJYN2T.jpg?quality=95&amp;as=32x18,48x28,72x41,108x62,160x92,240x138,360x206,480x275,540x310,640x367,720x413,1080x620,1280x734,1426x818&amp;from=bu&amp;cs=1426x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"SDLC","data":{"code":"-","description":"<b>SDLC (Software Development Life Cycle) \"Жизненный цикл разработки ПО\"</b> - это процесс по этапам разработки ПО. Позволяет правильно скомпоновать и реализовать проект в сроки и адекватно оценить. \nСостоит из 7 пунктов:\n<b>0) Идея.</b> На этом этапе заказчик (клиент) придумал идею о каком то сервисе. \nНапример: производитель мебели увидел у конкурентов интернет магазин, и он тоже захотел себе такую площадку. \n<b>1) Анализ.</b> Этап когда продукт овнеры уточняют детали о функционале и бизнес виденье. Определяет что команда будет разрабатывать. Переводит бизнес-требования в конкретные задачи для разработчиков. Управляет бэклогом и списком требований. \nНапример: а тут примера и не надо.\n<b>2) Планирование.</b> Этот этап подразумевает разработку дизайн макетов и общего виденья продукта. \nНапример: дизайнеры нарисовали макет страниц, UI/UX интерфейс. Обсуждается удобство и в общем актуальность дизайна в современных реалиях.\n<b>3) Разработка. </b>Тут уже подключается команда разработки. Они реализуют функционал интерфейса, базы данных, бэкэнд. \nНапример: фронт-эндеры переводят дизайн макет интернет магазина в код, разметку html, css верстку, javascript интерактивность. Бэк-эндеры в свою очередь реализуют логику работы и расчетов, хранение информации в базах данных, API запросы.\n<b>4) Тестирование.</b> Подразумевается проверка функционала с ожидаемым результатом и фактическим. Как проверка качества самого продукта и реализация в целом.\nНапример: в спринте по разработке интернет магазина была реализована корзина с оплатой. Тестировщик проверяет его функционал согласно требованиям и в случае дефектов заводит баг репорт.\n<b>5) Развертывание.</b> Считай финал, завершение разработки и выкладка в релиз. \nНапример: сайт готов, выгрузка на сервера хостинги, развертывание баз данных.\n<b>6) Эксплуатация и поддержка.</b> Пользователи уже начинают использовать данное ПО. А команда разработки в случае проблем или улучшений продолжает поддерживать проект. \n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/3633DkuClGs6xDimEO9AXlyB6m3mAiCNSCfC2WdzaLwE3H6L-d75a-QIPrKJgd5Z_B6TXWl-FxmA9HeieVKX6d0-.jpg?quality=95&amp;as=32x19,48x28,72x42,108x63,160x94,240x141,360x211,480x281,540x316,640x375,720x422,1080x633,1280x750,1306x765&amp;from=bu&amp;cs=1306x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Тестирование требований","data":{"code":"-","description":"По SDLC после анализа происходит планирование, в котором начинают разрабатывать дизайн макеты и прорабатывать требования к продукту.\nОтсюда вытекает такой термин как \"требование\". \n<b>Требование</b> - это когда в продукте должно быть реализовано то или иное. Тут описывается поведение продукта. Цель состоит в том, чтобы создать документ c требованиями или спецификацию с соответствующей детализацией. Этот документ будет содержать все требования к дизайну, проверке и техническому обслуживанию продукта.\n\nПоэтому обычно перед тем как происходит этап разработки, необходимо протестировать требования. \n\n<b>Тестирование требований</b> - это проверка задокументированных требований на соответствие с ключевыми свойствами хороших требований (см ниже) и оптимизации работы команды. Так же помогает избежать недопонимания и позволяет понять, могут ли эти требования быть выполнены с точки зрения времени, ресурсов и бюджета.\n\n<h4>Ключевыми характеристиками хороших требований являются:</h4>\n<b>- Завершённость</b>\nТребования должны быть логически завершены и иметь всю необходимую информацию\n<i>Например:</i> \"Экспорт осуществляется в PDF, PNG и т.д.\" - в этом случае не понятно что есть \"и т.д.\", в хорошем варианте это будет \"Экспорт осуществляется в PDF, PNG, Word\". Тем самым требование полностью логически завершено. \n\n<b>- Непротиворечивность</b>\nТребования не должны противоречить друг к другу.\n<i>Например:</i> кнопка \"Закрыть\" всегда синяя в одном документе требований, а в другом кнопка \"Закрыть\" всегда красная. Эти требования противоречат друг другу. \n\n<b>- Недвусмысленность</b>\nТребования должны быть написаны без двусмысленного понимания. \n<i>Например:</i> \"по нажатию на кнопку \"Перейти\" происходит переход на страницу товара или корзины. \" - в данном случае двусмысленный ожидаемый результат, правильнее было написать несколько иначе.\n\n<b>- Атомарность</b>\nТребование должно описывать только одну вещь.\n<i>Например:</i> \"Кнопка \"ОК\" находится слева, а кнопка \"Закрыть справа\"\" - неправильно составлено требование. Нужно написать отдельно требование на каждую кнопку т.е. ДВА отдельных требования.\n\n<b>- Выполнимость</b>\nТребование должно быть реализуемо в рамках проекта.\n<i>Например:</i> \"Мобильное приложение должно запускаться на всех версиях Android, начиная с 2.0\" - невозможно выполнить требование т.к. система Android 2.0 слишком стара, и технически реализовать современный UI и API на старых ОС невозможно.\n\n<b>- Обязательность</b>\nТребование должно быть обосновано, т.е. оно реально требуется, а те \"на всякий случай\"\n<i>Например:</i> \"Добавим поддержку Internet Explorer 6, вдруг кому-то понадобится\" - слишком устаревший браузер без поддержки современных JS/CSS и общей вёрстки. Затраты на адаптацию продукта под него нецелесообразно.\n\n<b>- Прослеживаемость</b>\nКаждое требование должно быть отслеживаемо на всех этапах - от бизнес-идеи до тестов и результатов. Что бы в случае проблем при тестировании можно было найти откуда вообще взялось такое требование по обратной цепочке взаимосвязи. \n<i>Например:</i> \"При нажатии на кнопку \"Отправить\" происходит отправка формы.\"\nТут не понятно к какому требованию это относится, по какому URL отправляется форма, какие параметры передаются по это форме.\n\n<b>- Модифицируемость</b>\nТребование должно быть написано таким образом, чтоб его можно было изменить.\n<i>Например:</i> \"Огромный абзац текста, где смешано 5-6 требований.\" - Это во первых противоречит требованию атомарности, во вторых изменение одного требования неизбежно затронет все остальные внутри общего требования.\n\n<b>- Проранжированность </b>\nУ требований должны быть приоритеты. К каждому требованию присвоен свой приоритет.\n<i>Например:</i> \"Список из 100 требований без указания, что делать в первую очередь.\" - необходимо выставить приоритеты по требованиям. В первую очередь необходимо выставить высокий приоритет самым необходимым и базовым требованиям.\n\n<b>- Проверяемость</b>\nПо требованию можно составить тест кейс.\n<i>Например:</i> \"страница выглядит ровно без поехавших блоков\" - как это проверить объективно? Необходимо составить требования на каждый блок на странице.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-23.vkuserphoto.ru/s/v1/ig2/TdBFUa2aHLP_77mzJhdespk702LNJVHi-mCw2RElWf8cL5MJCDKcNEkH8SgNzoTN1uSYlIVCPfp3o5wEeZdKhEQP.jpg?quality=95&amp;as=32x18,48x28,72x42,108x62,160x92,240x139,360x208,480x277,540x312,640x370,720x416,978x565&amp;from=bu&amp;cs=978x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}}]},{"header":"QA Теория: тест-дизайн, тест-анализ, документация","links":[{"title":"Техника тест-дизайна (что это ?)","data":{"code":"-","description":"При создании тестов часто требуется проверить ту или иную функциональность. В условной одной функциональности можно написать очень много разных тестов, которые по итогу выдают один и тот же требуемый результат, т.е. они повторяются и по логике не приносят обширного требуемого результата. Из-за чего время проверок и разработка затягиваются на очень долго. Поэтому существует техника тест-дизайна.\n\n<b>Тест-дизайн</b> - это ускорение и оптимизация тестирования. Он помогает ускорять процессы тестирования, сокращать количество проверок и не терять в их качестве. Так же помогает писать документацию по тестированию. Не нужно писать сотню тест кейсов с проверками если использовать техники тест дизайна. \n\nСуществует несколько основных техник тест-дизайна:\n- Эквивалентное разделение\n- Анализ граничных значений\n- Диаграмма состояний и переходов\n- Попарное тестирование\n- Таблица принятия решений\n- причина/следствие\n- предугадывание ошибок\n- Use&nbsp;Case (пользовательский сценарий)\n\n","path":"-"}},{"title":"Техника тест-дизайна: Эквивалентное разделение","data":{"code":"-","description":"<b>Для дальнейших примеров применения техник составим пример: </b>\nсуществует поле ввода, куда необходимо ввести свой возраст. И по условиям этого поля будет скидка для пользователей в зависимости от возраста.\nВходные данные: \n0-17 лет скидка 50%\n18-54 года скидка 25%\n55+ скидка 75%\n\n<b>Эквивалентное разделение</b> - тестируем несколько значений из каждого интервала. Все данные можно разбить на группы (классы), внутри которых программа себя ведет одинаково. Если проверка прошла для одного значения из класса, то скорее всего проверка пройдет и для всех остальных. \n<i>Например: </i>\nПри тестировании необходимо разделить на группы (классы):\n- позитивные классы - набор допустимых данных (0-17 лет, 18-54 года, 55+ лет)\n- негативные классы - вместо цифр буквы, спецсимволы, отрицательные значения \nДля проверки берётся по одному значению из каждой группы (класса)\n<b>1 тест:</b> вводится 16 лет\nожидаемый результат: скидка 50%\n<b>2 тест:</b> вводится @\nожидаемый результат: ответ пользователю \"Необходимо ввести свой возраст\"\nТем самым мы взяли по одному значению из классов и всего 2 кейсами проверили большую часть функционала. \n\n<b>Так же техники применимы и десятичным дробям.</b> Где границы зависят не только от целой, но и от дробной части:\nТребование: поле принимает от 0.01 до 10.00 включительно\nпо эквивалентному: \n- позитивные классы - набор допустимых данных (0.01-10.00)\n- негативные классы - вместо цифр буквы, спецсимволы, отрицательные значения \n<b>1 тест:</b> вводится 0.02\nОжидаемый результат: поле приняло данные\n<b>2 тест:</b> вводится -1\nожидаемый результат: пришло сообщение о допустимых диапазонах ввода (0.01-10.0)\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/AaG0otG-xVOK-9ZAWIvrWj4PsGKqRpayvReMs8-9i0nHgr2a0rMDfP5M_5VevYeJjw5wQwmet5xSq8cq0q6K0SQo.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x202,540x227,640x269,720x303,1080x454,1265x532&amp;from=bu&amp;cs=1265x0\" <=\"\" img=\"\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Техника тест-дизайна: Анализ граничных значений","data":{"code":"-","description":"<b>Для дальнейших примеров применения техник составим пример: </b>\nсуществует поле ввода, куда необходимо ввести свой возраст. И по условиям этого поля будет скидка для пользователей в зависимости от возраста.\nВходные данные: \n0-17 лет скидка 50%\n18-54 года скидка 25%\n55+ скидка 75%\n\n<b>Анализ граничных значений</b> - большинство ошибок происходит не в середине класса, а на его краях. Эта техника по сути своей дополнение к эквивалентному разделению но с фокусировкой на этих \"опасных\" точках.\n<i>Например:</i>\nиз класса допустимых данных берём значение 0-17 лет, границы класса это 0 и 17\n- Метод 2-х значений: \n<b>1 тест:</b> вводится граница и следующее значение за ней, в поле проверяется 17 и 18\nОжидаемый результат: при вводе границы 17 скидка 50%, при вводе после границы 18 скидка 25%\n- Метод 3-х значений:\n<b>2 тест:</b> вводится значение перед границей, граница и после границы, это будет 16, 17, 18\nОжидаемый результат: при вводе до границы 16 скидка 50%, при вводе границы 17 скидка 50%, при вводе после границы 18 скидка 25%\n\nТем самым мы покрыли границу из класса где обуславливается скидка 50%\nТак же не стоит забывать проверять границы из середины диапазона. Так как бывают случаи когда в середине диапазона происходит ошибка.\n\n\n<b>Так же техники применимы и десятичным дробям.</b> Где границы зависят не только от целой, но и от дробной части:\nпо граничным значениям:\nметод 2-х значений: \n<b>1 тест: </b>вводится граница и следующее значение за ней, например 10.0 и 10.01\nОжидаемый результат: при 10.0 поле приняло значение, при 10.01 поле сообщило о допустимых диапазонах \n<b>2 тест: </b>вводится значение перед границей, граница и после границы. 0.0, 0.01, 0.02\nОжидаемый результат: значение перед границей не принято, значение на границе принято, значение после границы принято.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/AaG0otG-xVOK-9ZAWIvrWj4PsGKqRpayvReMs8-9i0nHgr2a0rMDfP5M_5VevYeJjw5wQwmet5xSq8cq0q6K0SQo.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x202,540x227,640x269,720x303,1080x454,1265x532&amp;from=bu&amp;cs=1265x0\" <=\"\" img=\"\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n","path":"-"}},{"title":"Техника тест-дизайна: Диаграмма состояний и переходов","data":{"code":"-","description":"<b>Диаграмма состояний и переходов</b> - это модель поведения системы, которая показывает какие состояния может принимать объект, какие события вызывают переход между состояниями, какие правила/ограничения существуют между ними. Данная техника используется когда поведение зависит от предыдущих действий. \n<b>Например: </b>\n<i>входной объект: </i>учетная запись пользователя\n<i>возможные состояния: </i>\n - неавторизован\n - авторизован\n - заблокирован\n<i>события (триггеры): </i>\n - ввод корректных данных\n - ошибка пароля\n - превышение количества попыток\n - выход из аккаунта\n<i>переходы: </i>\n - неавторизован &gt; правильный пароль &gt; авторизован \n - неавторизован &gt; 3 неудачные попытки ввода &gt; заблокирован\n - авторизован &gt; нажал \"выйти\" &gt; неавторизован \n \n<b>После чего строится диаграмма:</b>\n- выделяются состояния системы \n- определяются события которые меняют состояния \n- рисуются стрелки от состояния А &gt; к состоянию Б\n- на стрелках пишется условие/действие/ограничения(если есть)\n\n<i>мини диаграмма: </i>\n  [Неавторизован] \n        |  (правильный пароль)\n        v\n  [Авторизован]\n        |\n        | (Выход)\n        v\n  [Неавторизован]\n\n  [Неавторизован]\n        |\n        | (3 ошибки подряд)\n        v\n  [Блокировка]\n \n<b>Что тестируется по этой диаграмме:</b>\n1. Правильные переходы - из неавторизован &gt; авторизован (пароль правильный)\n2. Неправильные переходы - из авторизован &gt; заблокирован (такого быть не должно)\n3. Пограничные события - 2 ошибки &gt; ещё не заблокирован, 3 ошибки &gt; блок\n4. Недопустимые переходы - из заблокирован &gt; авторизован (без разблокировки)\n\nЗачем это нужно? Чтоб найти баги в логике переходов, построить тесты основанные на поведении системы, протестировать комбинаторику сценариев которую обычные тест кейсы пропускают.\n\n<img style=\"width: 98%; cursor: pointer; max-width: 500px; max-height: 400px;\" src=\"https://sun9-35.vkuserphoto.ru/s/v1/ig2/BhSxjswF_LJO2NyM6p2in5MXuwmoAGn7-iXz-mXP3K1A-s5Ccc2cmtQLK_4DbXvn9v64EzXNJST7MO6LJuNOgJnd.jpg?quality=95&amp;as=32x32,48x48,72x72,108x108,160x160,240x240,360x360,480x480,540x540,640x640,720x720,1080x1080&amp;from=bu&amp;cs=1080x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Техника тест-дизайна: попарное тестирование","data":{"code":"-","description":"<b>Попарное тестирование</b> - это когда присутствует много данных для проверок. Необходима комбинаторная техника, которая позволяет протестировать все возможные комбинации параметров по парам а не полностью. Большинство дефектов возникает из-за взаимодействия двух параметров, а не всех сразу. \nЕсли в продукте много параметров (цвет, размер, тип аккаунта, устройство, браузер и т.д.) то полная проверка всех комбинаций можеть быть огромной. Попарное тестирование выбирает набор тестов так, что бы каждая пара значений встречалась минимум один раз, при этом число тестов снижается в десятки раз. \n<b>Например:</b> есть форма регистрации\n<i>параметры: </i>\n- тип устройства Desktop/Mobile\n- браузер Chrome/Firefox/Safari\n- тип аккаунта VipUser/User\n\n<i>полное количество комбинаций</i>\n2 устройства * 3 браузера * 2 типа аккаунтов = 12 тестов \n\n<i>попарное тестирование должно покрыть все пары значений между параметрами:</i>\n- устройство + браузер \n- устройство + тип аккаунта \n- браузер + тип аккаунта \n\n<i>В результате получаем минимальный набор тестов</i>, который покрывает все пары хотя бы один раз, и обычно получается 4-6 тестов вместо 12:\n1 Desktop + Chrome + User\n2 Desktop + Firefox + VipUser \n3 Desktop + Safari + VipUser \n4 Mobile + Chrome + VipUser \n5 Mobile + Firefox + User\n6 Mobile + Safari + User \n\n<b>Итого: </b>\nDesktop + Chrome &gt; есть\nMobile + Firefox &gt; есть\nChrome + User &gt; есть\nSafari + VipUser &gt; есть\nMobile + VipUser &gt; есть\nDesktop + User &gt; есть\n\n<b>Инструменты для облегчения попарного тестирования:</b>\nPICT (Microsoft)\nAllPairs\nPairwiser\nTestCase Studio + Pairwise plugin\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/oTiGfqvptSOQ2tvOGIggAXD-h1zA1J_MdXcio0_A8VqEkgTTzPtq9yFH4DF439oWr3K3NqlC7ch6qhQRDMaJXM2b.jpg?quality=95&amp;as=32x7,48x11,72x17,108x25,160x37,240x56,360x84,480x112,540x126,640x150,720x168,761x178&amp;from=bu&amp;cs=761x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Техника тест-дизайна: Таблица принятия решений","data":{"code":"-","description":"<b>Таблица принятия решений</b> - это такая техника тест-дизайна которая помогает описать сложную бизнес-логику, разбить эту логику на условия и действия. Для этого создаётся таблица где каждая строка - уникальное сочетание условий и ожидаемого поведения системы.\nОбычно данная техника используется когда в продукте много правил, есть комбинации условий, логика ветвится и чтоб важно было понять поведение системы при определённой комбинации входных данных. Она покрывает полные комбинации условий, но оптимизированно.\n\n<h4>Структура таблицы принятия решений состоит из двух больших блоков:</h4>\n<b>1. Условия (Conditions)</b> - все что влияет на решения, могут быть бинарными (Y/N, False/True, +/-) или многозначными\n<b>2. Действие/Результат (Actions)</b> - что система должна сделать если условия совпадают. (Можно/Нельзя/Показать сообщение/Выдать ошибку/Открыть доступ и т.д.)\n\nКаждая колонка это один полный сценарий/правило (Rule).\n\n<b>Например:</b>\nСуществует логика скидок в интернет магазине\n<i>Входящие данные:</i>\nЕсли пользователь постоянный и у него есть промокод &gt; скидка 20%.\nЕсли пользователь постоянный и промокода нет &gt; скидка 10%.\nЕсли не постоянный, но есть промокод &gt; скидка 5%.\nЕсли не постоянный и нет промокода &gt; скидка 0%.\n\n<i>Условия:</i>\n1. Постоянный ? (Yes/No)\n2. Промокод ? (Yes/No)\n\n<i>Действие:</i>\nРазмер скидки от 0% до 20%\n\n<b>Таблица принятия решений:</b>\n<table><thead><tr><th>Условие (Conditions)</th><th>Rule 1</th><th>Rule 2</th><th>Rule 3</th><th>Rule 4</th></tr></thead><thead><tr><td>Постоянный клиент</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>Есть промокод</td><td>Y</td><td>N</td><td>Y</td><td>N</td></tr><tr><td><b>Действие (Actions)</b></td><td></td><td></td><td></td><td></td></tr><tr><td>скидка</td><td>20</td><td>10</td><td>5</td><td>0</td></tr></thead></table>\n\nПо этой таблице можно создать 4 тест кейса где в каждом проверяется одна комбинация условий.\n\n<b>Тест-кейсы:</b>\nПостоянный + Промокод &gt; 20%\nПостоянный + Без промокода &gt; 10%\nНе постоянный + Промокод &gt; 5%\nНе постоянный + Без промокода &gt; 0%\n\n<b>P.S:</b> опишу более понятным языком на пальцах\nВ первой колонке документа описываются условия, после чего в первой же колонке описываются действия. И последующие колонки R1/R2/R3 это сценарии, если какое то условие выполняется ставится Y/N и в действии выставляется результат например галочка ✔️  или 20% (скидка)\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-32.vkuserphoto.ru/s/v1/ig2/354sr_67gBnqUs6cQpQZCUyQ9y0MAcvntLZevqP3Dhr28YR7IP4j8XZFKCJIZCbioCaIULC-VKnKaa-knN3wceNP.jpg?quality=95&amp;as=32x11,48x16,72x24,108x36,160x54,240x81,360x121,480x161,540x181,640x215,720x242,1080x362,1280x429,1440x483,2465x827&amp;from=bu&amp;cs=2465x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\"><br>\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-82.vkuserphoto.ru/s/v1/ig2/QJR9oFV76MSzP5wF7eKBXsIsWAhBTQEXZe07rO74gFBRYGxL03qjfx3Ng_joSojz94IZLmsL8llmlUeon3v09MGN.jpg?quality=95&amp;as=32x26,48x39,72x59,108x88,160x131,240x196,360x294,480x392,540x441,640x522,720x588,761x621&amp;from=bu&amp;cs=761x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Техника тест-дизайна: причина/следствие","data":{"code":"-","description":"<b>Причина/следствие </b>- это техника где ввод комбинаций условий (причина) позволяет получить ответ от системы (следствие). Это позволяет ничего не пропустить в своих проверках. Т.е. допустим есть какое то первое действие из него выходит второе действие после второго третье и т.д. исходя из этих действий мы получаем причину и следствие.\n\n<b>Например:</b>\n<i>Условие:</i> проверить возможность добавлять пользователей\nПричина: необходимо заполнить поля \"Имя\", \"Адрес\", \"Номер телефона\" и нажать кнопку \"Добавить\"\n<i>Следствие:</i> После нажатия на кнопку \"Добавить\" система добавляет клиента в базу данных и показывает его номер на экране. \n\nТут у нас причина \"Добавить\" следствие \"Добавлено в базу данных\"\n","path":"-"}},{"title":"Техника тест-дизайна: предугадывание ошибок","data":{"code":"-","description":"<b>Предугадывание ошибок</b> - такая техника в которой тестировщик исходя из своего опыта может предугадать ту или иную ошибку/дефект в продукте. Использование знаний системы и интерпретации спецификаций (требований) на предмет того, что бы \"предугадать\" при каких входных данных и условиях система выдаст ошибку. \n\n<b>Например: </b>\n<i>Условие:</i> пользователь должен ввести код\n<i>Тестировщик:</i> \"Что если я введу не код?\", \"Что если я введу некорректный код?\"\n<i>Итого: </i>попытка предугадать поведение работы поля ввода кода\n\n<i>Условие: </i> присутствует поле ввода для возраста \n<i>Тестировщик:</i> очевидно при вводе возраста 0 система должна мне выдать ошибку на подобии \"Возраст введён некорректно\"\n<i>Итого:</i> тут попытка предугадать что система должна выдать какую то ошибку, если этого не произошло то это неправильное поведение системы. Как пользователю может быть 0 лет? Это неуместно.","path":"-"}},{"title":"Техника тест-дизайна: Use Case","data":{"code":"-","description":"<b>Use case </b>- это по сути своей пользовательский сценарий. Как пользователь предположительно будет пользоваться продуктом, куда будет заходить и что нажимать для достижения определённой цели. \n<b>Use case содержит:</b>\n- кто использует систему (обычный пользователь, администратор, продавец)\n- что пользователь хочет сделать\n- цели пользователя\n- шаги которые выполняет пользователь\n- описание того как система реагирует на действие пользователя\n\n<b>Например:</b>\n<i>Условие:</i> обычный пользователь в интернет магазине\n<i>Цель:</i> добавить товар в избранное\n<i>Шаги:</i>\n1. зайти на страницу товара\n2. навести курсор на звездочку\n3. нажать лкм\n4. появился попап об успешном добавлении товара в избранное\n\n<i>Итог: </i>основываясь на пользовательском сценарии мы проверили поведение системы\n","path":"-"}},{"title":"Тест-анализ: что это?","data":{"code":"-","description":"В индустрии разработки ПО до сих пор частенько встречается опасное заблуждение: если баг обнаруживается на проде или на поздних стадиях разработки, это автоматически считается провалом тестировщика. \"Пропустил баг!\" звучит как приговор. Но это не особо верный подход, т.к. он искажает суть процесса контроля качества. Тестировщик не создает баги и не гарантирует их 100% обнаружение. Его задача – обеспечить адекватное тестирование на основе качественного тест-анализа. \n<i>Именно тест-анализ является тем фундаментом, который определяет, насколько обоснованно и эффективно будет проведено тестирование, и почему найденный баг – это не ошибка тестировщика, а следствие системных факторов.</i>\n\n<img src=\"https://sun9-47.userapi.com/s/v1/ig2/4otFUnzSmrL-ReTxrZaHUg2yKykI-PK-Fa2TwTxyvPNulDu3NzuqCwIoMsbbwI3K1VLAbgSj7j5s0K2k80T2ca_t.jpg?quality=95&amp;as=32x19,48x29,72x43,108x65,160x96,240x144,360x216,480x288,540x324,640x384,720x432,1080x648,1280x768,1440x864,2000x1200&amp;from=bu&amp;cs=2000x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Тест-анализ</b> – это процесс изучения тестируемого объекта (требований, дизайна, кода, рисков) с целью определения \"ЧТО тестировать?\". Это интеллектуальная деятельность, предшествующая созданию тест-кейсов, использования тест-дизайна и т.д. \n\n<b>Главные аспекты хорошего тест-анализа:</b>\n<b>1. Тестовые условия (Test Conditions): </b>\nЧто именно мы будем проверять (функции, атрибуты качества, риски).\n\n<b>2. Приоритеты тестирования: </b>\nЧто критично, а что можно проверить позже или менее глубоко.\n\n<b>3. Подходы и методы тестирования: </b>\nКакие техники тест-дизайна (эквивалентные классы, граничные значения, сценарии использования, исследовательское тестирование и т.д.) наиболее подходят.\n\n<b>4. Оценка покрытия: </b>\nКакие аспекты системы должны быть покрыты тестами (требованиями, рисками, бизнес-процессами, кодом).\n\n<b>5. Выявление неясностей и рисков: </b>\nОбнаружение противоречий, пробелов, двусмысленностей в требованиях и дизайне ДО начала кодирования или на ранних стадиях.\n\n<b>Тест-анализ – основа адекватного тестирования:</b>\nАдекватное тестирование – это не \"всеобъемлющее\" тестирование (что невозможно, кстати), а достаточное и обоснованное, по-умному говоря, тестирование для достижения целей проекта с учетом контекста (сроки, бюджет, критичность системы). Тест-анализ обеспечивает эту адекватность, тк в нем есть:\n<b>1. Фокусировка на рисках:</b>\n Анализ помогает выявить наиболее уязвимые и критичные части системы. Тестирование концентрируется там, где сбой будет наиболее болезненным.\n\n<b>2. Обоснованность тестов:</b>\nКаждый тест-кейс имеет причину для существования, вытекающую из требований, дизайна, рисков или прошлого опыта.\n\n<b>3. Эффективность ресурсов:</b>\nПозволяет избежать тестирования \"всего подряд\", направляя усилия на наиболее важные области.\n\n<b>4. Раннее выявление дефектов:</b>\n Анализ требований и дизайна позволяет находить дефекты до их воплощения в коде (дешевле и быстрее исправлять).\n\n<b>5. Измеримость покрытия: </b>\nПозволяет определить, что именно должно быть покрыто тестами, и оценить степень этого покрытия.\n\n<img src=\"https://sun9-65.userapi.com/s/v1/ig2/ABuFLRv-yXO-whwlFGItRQZSgFPCrUFtySsbhGK7FQ_TcgJJzcEdofC3fUKV3YduzX-G7OWwLTW-3Ins99BMo8X2.jpg?quality=95&amp;as=32x25,48x37,72x56,108x84,160x124,240x186,360x279,480x372,540x419,640x496,720x558,1024x794&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">","path":"-"}},{"title":"Тест-анализ: декомпозиция","data":{"code":"-","description":"<img src=\"https://sun9-80.userapi.com/s/v1/ig2/43VqLhTXD1PMmJV5p1UXtPuHIaGMUiiZc7OJRa21A2FwMU5_e2GMOPjjTrOBxlhPozd_x9M6_Vz8qNCUFk3aWrHO.jpg?quality=95&amp;as=32x32,48x48,72x72,108x108,160x160,240x240,360x360,480x480,540x540,640x640,720x720,1024x1024&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Декомпозиция</b> - научный метод, использующий структуру задачи и позволяющий заменить решение одной большой задачи решением серии меньших задач, пусть и взаимосвязанных, но более простых.\n\nДекомпозиция, как процесс расчленения, позволяет рассматривать любую исследуемую систему как сложную, состоящую из отдельных взаимосвязанных подсистем, которые, в свою очередь, также могут быть расчленены на части.\n\nНапример, стандартный персональный компьютер начала 21в. состоит из системного блока, монитора, клавиатуры, мышки и проводов, которые соединяют эту систему. Системный блок – это материнская плата, процессор, кулер, винчестер и т.д. Мышка – это датчик перемещения, управляющие элементы, интерфейс подключения к компьютеру. Управляющие элементы мышки – это правая и левая кнопки, колёсико, дополнительные кнопки.\n\nДекомпозиция системы чаще всего представляется в виде иерархического дерева, вершина которого – сама система, а уровни – выделенные подсистемы.\n\n<hr>\n<h5>Декомпозиция в тестировании</h5>\n Подобные иерархические деревья для приложений можно строить с целью:\n- сбора и сохранения информации о структуре приложения. Глубина расчленения (количество уровней) будет варьироваться в зависимости от того, кто будет пользоваться этой структурой и как.\n- создания чеклиста, который можно будет использовать в процессе тестирования. Для этого необходимо достичь очень глубокого расчленения.\n\nОднако, даже если декомпозиция приложения не представляется в виде иерархического дерева, для тестировщика принцип декомпозиции обозначает то, что тестируемое приложение (отдельный его модуль или функционал) можно рассматривать как состоящий из относительно независимых друг от друга подсистем, каждую из которых тестировать гораздо проще и понятнее, чем всю систему сразу. Принцип декомпозиции необходимо и полезно использовать повсюду:\n- при создании чеклистов или тест-кейсов\n- при выполнении тестирования исследовательским способом\n- при проведении тестирования требований\n- при планировании и оценке задач по тестированию\n\n<b>Осмысленное применение декомпозиции в процессе тестирования помогает достигнуть как лучшего качества, так и большей уверенности в этом качестве.</b>\n\n<hr>\n<h5>Пример декомпозиции</h5>\n<img src=\"https://sun9-77.userapi.com/s/v1/ig2/GgC1L9793H8-XMiGZPXvsRlr-W1pnr42REr8A4_yxvBWcWuPPEYEP60XPr5fyzzQ4DgGl333-iKL0HKMk3NAc6sY.jpg?quality=95&amp;as=32x19,48x28,72x42,108x63,160x93,240x140,360x210,480x280,540x315,640x373,720x420,774x451&amp;from=bu&amp;cs=774x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<span style=\"text-align: center; display: block;\">Рис.1. Браузер</span>\n\nДля разделения одного и того же приложения на подсистемы могут использоваться разные признаки декомпозиции. В качестве задачи на декомпозицию мы будем рассматривать приложение \"Браузер\". Следует учесть, что во всех примерах, которые будут приведены ниже, декомпозиция не полная. Показаны лишь некоторые из подсистем первого и второго уровней.\n\nВ качестве признака разделения приложения могут использоваться:\n- внешний интерфейс (экран, окно, закладка и т.п. со всеми элементами интерфейса). На рис. 2 показан пример декомпозиции по этому признаку.\n- компонентная структура (функциональные модули приложения и их интеграция в более сложные модули). См. пример на рис. 3.\n- функции приложения и их варианты использования (см. пример на рис. 4),\n- обрабатываемые приложением объекты и данные (и часто нужно анализировать не то, что видно, а то что скрыто внутри – что передается на вход, что на выходе, что храниться внутри системы),\n- характеристики (параметры) объектов и данных или в целом всей системы (например, если объект – это файл, то параметры это – формат, размер, создатель, дата создания и т.д.),\n- действия над объектами (если объект “файл”, то действия – удалить, переименовать, переместить, а если объект “список файлов”, то действия – сортировать, фильтровать, выделить несколько файлов)\nсостояния, в которые переходит приложение или его модули,\n- этапы взаимодействия пользователя с приложением (см. пример на рис. 5),\n виды пользователей,\n- характеристики качества (функциональность, удобство использования, производительность и т.д.),\n- и другие.\n\n<img src=\"https://sun9-70.userapi.com/s/v1/ig2/75QqIpF95cxjqmPJAqqa7MiyYqkeZvFuoMw5D48ps3L1MagThl-44ZQeoc-DvuegU6_qWbpGr91tGlm9Gwka8E2W.jpg?quality=95&amp;as=32x12,48x19,72x28,108x42,160x63,240x94,360x141,480x188,540x211,640x250,720x281,944x369&amp;from=bu&amp;cs=944x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<span style=\"text-align: center; display: block;\">Рис. 2. Пример декомпозиции по элементам интерфейса приложения \"Браузер\"</span>\n\n<img src=\"https://sun9-26.userapi.com/s/v1/ig2/Wn73-uvxdGISv0QCOb3kRMvwSO-ovGLt86dKqLKLrGNeV5XU5VLA-_U1yPMxLsbSD2ySLHHJpNVbny9HfpBI3DmL.jpg?quality=95&amp;as=32x20,48x29,72x44,108x66,160x98,240x147,360x221,441x271&amp;from=bu&amp;cs=441x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<span style=\"text-align: center; display: block;\">Рис. 3. Пример компонентной декомпозиции приложения \"Браузер\"</span>\n\n<img src=\"https://sun9-69.userapi.com/s/v1/ig2/1HJePbTDIR2BM0V-d4xOtGwSzkT7PWutsuicbKvv0qmnnUCF6UV-Oq3jyN8cu6wVkwa2gPX3Yx7HbhE7k-VXrs9K.jpg?quality=95&amp;as=32x14,48x21,72x32,108x48,160x71,240x106,360x159,480x212,540x239,640x283,720x318,803x355&amp;from=bu&amp;cs=803x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<span style=\"text-align: center; display: block;\">Рис. 4. Пример функциональной декомпозиции приложения \"Браузер\"</span>\n\n<img src=\"https://sun9-77.userapi.com/s/v1/ig2/CSouU4YqX_TKhZ1ZoQAcb7r5BqGQtVqL0AldAPMKdD0Hj6_pcz_bdzU83__I9aQiNWu6Mah_rRTvYRdYFTr3ZtbA.jpg?quality=95&amp;as=32x14,48x20,72x30,108x46,160x68,240x102,360x152,480x203,540x229,640x271,720x305,815x345&amp;from=bu&amp;cs=815x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<span style=\"text-align: center; display: block;\">Рис. 5. Пример декомпозиции по этапам взаимодействия пользователя с приложением \"Браузер\"</span>\n\nЧасто декомпозиция одной и той же системы может осуществляться по нескольким признакам, порядок их выбора зависит от квалификации и предпочтений тестировщика. Декомпозиция – задача очень субъективная. И самое главное, чтобы тестировщик осознавал свой выбор принципа декомпозиции в каждый момент времени.\n","path":"-"}},{"title":"Тест-анализ: принципы декомпозиции","data":{"code":"-","description":"У декомпозиции так же существуют свои принципы в тестировании. Используя их можно проводить качественное тестирование. Существует несколько принципов:\n\n<b>1. Каждое разделение образует свой уровень.</b>\nИсходная система располагается на нулевом уровне. После её разделения получаются подсистемы первого уровня. Разделение этих подсистем или некоторых из них приводит к появлению подсистем второго уровня и т.д.\nТестирование системы или подсистемы обозначает тестирование всех уровней всех подсистем, на которые она разбивается.\n\n<b>2. Все подсистемы одного уровня, являющиеся подсистемами одной и той же системы, должны разделяться по одному признаку.</b>\nДругими словами, должны отвечать на один и тот же вопрос относительно своего родителя.\nПо правилам декомпозиции все подсистемы одного уровня должны обладать одним признаком и разделяться по нему но часто при тестировании ПО подобного разделения достичь очень тяжело либо требует слишком много времени, поэтому я руководствуюсь упомянутым упрощенным правилом – в рамках одного узла деление должно быть выполнено по одному признаку.\n\n<b>3. Вычленяемые подсистемы в сумме должны составлять всю систему (как пазл соединяться в одну картинку). При этом они должны взаимно исключать друг друга.</b>\nЕсли сложить все выделенные подсистемы вместе, то мы должны получить всю систему. Однако целостность и качество этой системы можно гарантировать только с учётом взаимодействия подсистем. Например, нет гарантии, что системный блок компьютера будет работать, если работают по отдельности материнская плата, процессор, компьютер и др. компоненты. Их нужно собрать вместе и проверить взаимодействие.\nВ процессе декомпозиции допускается выделять группу (подсистему) \"Другие\", в которую включаются те подсистемы, для которых невозможно выделить один общий признак или подсистем получается слишком много, чтобы выделять их на верхний уровень.  Но в \"Других\", должен всё равно применяться некий свой внутренний признак расчленения.\nК неоднозначности может привести использование на одном уровне взаимно пересекающихся подсистем. Например, в сводке расходов за месяц, в большинстве случаев немного странно будут выглядеть пункты: еда, аренда помещения, канцелярия, коммунальные услуги, подогрев воды. Обычно подогрев воды относится к коммунальным услугам. Соответственно, при выделении этих пунктов на один уровень могут возникнуть вопросы формата: расходы на подогрев воды – это дополнительные расходы сверх нормы? Или это постоянные ежемесячные расходы? А не платим ли мы дважды за подогрев воды?\n\n<b>4.  Выбирайте глубину декомпозиции в зависимости от задач.</b>\nИщите компромисс между полнотой и простотой.\nГлубина декомпозиции (количество уровней) и степень подробности описания определяются требованиями обозримости и удобства восприятия получаемой иерархической структуры, её соответствия уровням знания работающему с ней специалисту.\nДля специалиста, знающего систему хорошо, декомпозиция может быть неглубокой, менее детализированной. Если же предполагается, что результат декомпозиции будет использоваться не работавшим ранее с системой специалистом, то декомпозировать следует более детально и глубоко.\nРаньше рекомендовалось выделять 3-6 уровней. В настоящее время существует специальное ПО для создания интеллектуальных карт и управлять декомпозицией стало проще. Однако всё равно следует искать золотую середину, подходящую под ваши условия работы, и учитывать, что когда в структуре получается много уровней, то система становится труднообозримой, в ней сложно ориентироваться. Если же глубину делать небольшую, то вероятнее всего возрастет число находящихся на одном уровне подсистем и становится сложно связать их в единую полную систему, сложно искать взаимосвязи.\nСистемы нижнего уровня называются элементарными.\nЕсли иерархическая схема используется как чеклист, то элементарные системы – это и есть идеи тестов.\nЕсли же схема используется как структура приложения, то элементарные системы – это системы с такой степенью детализации, которую будет очевидно, как тестировать человеку, использующему эту схему в процессе тестирования.\n\n<b>5. Проводите критическую оценку декомпозиции каждого из построенных уровней и системы в целом.</b>\nВсё ли охвачено? Не пропущено ли? Может быть есть избыточные ветви или пересекающиеся?\nПонятно ли как тестировать системы нижнего уровня? Можно ли расчленить эти системы еще больше? Если ваших знаний недостаточно для дальнейшей декомпозиции, то привлекайте других участников проекта (проектных менеджеров, программистов и т.д.)\n\n<img src=\"https://sun16-1.userapi.com/s/v1/ig2/YWo1F5rBPFxD9lbGjBLd4WjUIfnjhq5hvFZzd8wYYmzIBOeNzXwVfjf9PTEfKrHZorFq4XOuhlGr_xWJ4gtVr7te.jpg?quality=95&amp;as=32x15,48x23,72x34,108x52,160x76,240x115,360x172,480x229,540x258,640x306,720x344,844x403&amp;from=bu&amp;cs=844x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-76.userapi.com/s/v1/ig2/ojNye5ZXrFUm0hqK4UjJVGJaUMhzoWF6uhvOFucA8ZO1gTr9ytFhPiSyN1lTwDiHm0czJabkk_Qg6ZXvJfcCyleR.jpg?quality=95&amp;as=32x18,48x28,72x42,108x62,160x92,240x139,360x208,480x277,540x312,640x369,720x416,998x576&amp;from=bu&amp;cs=998x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">","path":"-"}},{"title":"Тест-анализ: оценка рисков и приоритезация","data":{"code":"-","description":"<img src=\"https://sun9-32.userapi.com/s/v1/ig2/qa8z0iRycT6b39b0FpnxGaXiOBJ5T5N7Bn9RIeq06ju3K1_Gmib0DToq8M2ldENhds2tzvEdRayiz1oPTZjQrHee.jpg?quality=95&amp;as=32x21,48x32,72x48,108x72,160x107,240x160,360x240,480x320,540x360,640x427&amp;from=bu&amp;cs=640x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nДля обеспечения качества информационного продукта в медицине, страховании, банкинге и других отраслях, наряду с другими методами тестирования, важно использовать тестирование, основанное на рисках. Для проверки выбирают самые рискованные области создаваемого программного обеспечения. Это позволяет предусмотреть негативные сценарии и успешно реализовать бизнес-цели заказчика.\n\n<b>Риск</b> - это сочетание вероятности возникновения дефекта и тяжести последствий его проявления.\n\n<hr>\n<h5>Риски связанные с ПО</h5>\n<b>- Риск проекта:</b> Эти риски относятся к проекту в его собственном контексте. Проектные риски связаны с организацией и управлением проектом: сроки, ресурсы, компетенции, зависимости от внешних поставщиков и контрактные ограничения.\n\n<b>- Риск продукта:</b> Риск для продукта является основной областью риска, вызывающей озабоченность у тестировщиков. Эти риски связаны с определением продукта, стабильностью (или отсутствием) требований, сложностью продукта и уязвимостью технологии. \n<b>Риск продукта</b> - это возможность возникновения дефекта или отказа системы, последствия которого неприемлемы в эксплуатации.\n\n<hr>\n<h5>Что такое тестирование на основе рисков?</h5>\n<b>Тестирование, основанное на рисках</b> - это метод, при котором усилия по тестированию приоритизируются на основе степени потенциального влияния и вероятности дефекта.\nВместо применения единого подхода к тестированию всех функциональных возможностей приложения, эта стратегия предполагает выявление и оценку потенциальных рисков, связанных с различными функциями и частями.\nСосредоточившись на областях с повышенным риском, тестировщики могут максимизировать шансы на обнаружение критических проблем и обеспечить более надёжный и качественный продукт.\n\n<b>Простыми словами:</b> тестировщик совместно с командой (PO, Dev, Stakeholders) оценивает риски разрабатываемого продукта (Проектные/Продуктовые). Далее определяется объём, глубина и приоритет тестирования для минимизации этих рисков.\n\n<hr>\n<h5>Формула риска</h5>\nВ контексте тестирования программного обеспечения риск определяется как сочетание двух факторов:\n<b>Риск = Вероятность возникновения дефекта × Влияние (ущерб) от дефекта</b>\n<b>Вероятность</b>- насколько высока вероятность появления дефекта в данной области:\n- сложность логики\n- частота изменений\n- новизна функциональности\n- история дефектов\n- качество требований\n\n<b>Влияние</b> -  степень негативных последствий при проявлении дефекта:\n- финансовые потери\n- нарушение бизнес-процессов\n- риски безопасности\n- репутационный ущерб\n- юридические и регуляторные последствия\n\n<b>Риск</b> считается высоким, если хотя бы один из факторов имеет высокое значение, но наибольшую опасность представляют области с одновременно высокой вероятностью и высоким влиянием.\n<hr>\n<h5>Оценка рисков</h5>\nОценка рисков при тестировании ПО включает выявление потенциальных проблем, оценку степени их влияния и вероятности возникновения.  Что позволяет расставить приоритеты тестирования и эффективно распределить ресурсы.\nДля оценки рисков используется качественная или полуколичественная шкала.\n<b>Вероятность:</b>\n- Низкая\n- Средняя\n- Высокая\n<b>Влияние:</b>\n- Низкое\n- Среднее\n- Высокое\nКаждому риску присваивается уровень на основе экспертной оценки команды (QA, Dev, PO).\n\n\n<hr>\n<h5>Матрица рисков</h5>\nМатрица рисков позволяет визуализировать приоритеты тестирования.\n<img src=\"https://sun9-49.userapi.com/s/v1/ig2/MoQtw_ObJyMxbj73F54Tlr5nTVThIjn-rXSeY5oVCxuthxwK0tMi-6f5hvhcf-UHWrcTeEXqsDYa227BioyI2_4Q.jpg?quality=95&amp;as=32x7,48x11,72x16,108x24,160x36,240x54,360x82,480x109,540x122,640x145,720x163,790x179&amp;from=bu&amp;cs=790x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nМатрица не предназначена для точных расчётов, а служит инструментом принятия решений при планировании тестирования.\n\n<hr>\n<h5>Использование результатов оценки рисков</h5>\nРезультаты оценки рисков применяются для:\n- определения приоритетов тестирования\n- выбора глубины тестирования\n- планирования порядка выполнения тестов\n- распределения ограниченных ресурсов\n- принятия решений о сокращении или исключении тестирования низкорисковых областей\n\nЧем выше риск, тем:\n- раньше выполняется тестирование\n- больше тестовых сценариев\n- глубже негативные и граничные проверки\n- выше требования к регрессии\n\n<hr>\n<h5>Приоритезация тестирования на основе рисков</h5>\n<b>Приоритезация тестирования</b> - это процесс определения порядка, глубины и объёма тестирования функциональных областей на основе их уровня риска.\nВ тестировании на основе рисков приоритет тестирования напрямую зависит от уровня продуктового риска, определённого на этапе оценки рисков.\n<b>Цель приоритезации</b> - обнаружить дефекты с наибольшими последствиями как можно раньше при ограниченных ресурсах.\n\n<hr>\n<h5>Связь риска и приоритета тестирования</h5>\nПриоритет тестирования формируется не интуитивно, а как следствие оценки риска:\n<table><thead><tr><th>Уровень риска</th><th>Приоритет тестирования</th><th>Подход</th></tr></thead><tbody><tr><td>Критический</td><td>P1</td><td>Максимальное покрытие, тестируется первым</td></tr><tr><td>Высокий</td><td>P2</td><td>Глубокое функциональное и негативное тестирование</td></tr><tr><td>Средний</td><td>P3</td><td>Основные сценарии и выборочная регрессия</td></tr><tr><td>Низкий</td><td>P4</td><td>Smoke / поверхностная проверка</td></tr><tr><td>Минимальный</td><td>P5</td><td>Может не тестироваться</td></tr></tbody></table>\n\n<hr>\n<h5>Как именно приоритезируется тестирование</h5>\nПриоритезация влияет на три параметра:\n<b>1. Порядок выполнения тестов</b>\n- сначала - области с критическим и высоким риском\n- низкорисковые области тестируются позже или при наличии времени\n<b>2. Глубина тестирования</b>\n- Чем выше риск, тем глубже тестирование:\n- позитивные сценарии\n- негативные сценарии\n- граничные значения\n- нестандартные пользовательские действия\n- проверки отказоустойчивости\n<b>3. Объём тестирования</b>\n- высокий риск &gt; больше тест-кейсов\n- низкий риск &gt; минимум сценариев\n\nПосле оценки рисков тест-кейсы также получают приоритет.\nПример:\n<table><thead><tr><th>Тест-кейс</th><th>Связанный риск</th><th>Приоритет</th></tr></thead><tbody><tr><td>Оплата картой</td><td>Потеря денег</td><td>P1</td></tr><tr><td>Восстановление пароля</td><td>Безопасность</td><td>P1</td></tr><tr><td>Фильтрация товаров</td><td>Удобство</td><td>P3</td></tr><tr><td>Страница «О нас»</td><td>Нет влияния</td><td>P5</td></tr></tbody></table>\nПриоритет тест-кейса определяется по самому высокому риску, который он покрывает.\n\n<hr>\n<h4>Пример RBT на небольшом веб-сайте</h4>\n<h5>Контекст проекта</h5>\n<b>Небольшой сайт интернет-магазина:</b>\n<b>1. Функциональность:</b>\n- регистрация и логин\n- каталог товаров\n- корзина\n- оформление заказа\n- онлайн-оплата картой\n- страница «О нас»\n<b>2. Ограничения:</b>\n- ограниченное время на тестирование\n- один тестировщик\n- релиз через 3 дня\n\n<b>Шаг 1. Выявление рисков</b>\nНа этом этапе мы не считаем и не ранжируем, а просто ищем, где может быть больно.\n<table><thead><tr><th>Область</th><th>Потенциальный риск</th></tr></thead><tbody><tr><td>Авторизация</td><td>Пользователь не может войти</td></tr><tr><td>Авторизация</td><td>Возможность входа под чужим аккаунтом</td></tr><tr><td>Каталог</td><td>Неверное отображение цен</td></tr><tr><td>Корзина</td><td>Потеря товаров при обновлении страницы</td></tr><tr><td>Оформление заказа</td><td>Заказ не создаётся</td></tr><tr><td>Оплата</td><td>Списание денег без создания заказа</td></tr><tr><td>Оплата</td><td>Дублирование платежа</td></tr><tr><td>Страница «О нас»</td><td>Ошибка верстки</td></tr></tbody></table>\nВажно:\nна этом этапе это ещё не приоритеты, а гипотезы риска.\n\n<b>Шаг 2. Оценка рисков</b>\nИспользуем простую шкалу:\n- Вероятность: Низкая / Средняя / Высокая\n- Влияние: Низкое / Среднее / Высокое\n<table><thead><tr><th>Риск</th><th>Вероятность</th><th>Влияние</th><th>Уровень риска</th></tr></thead><tbody><tr><td>Неудачный логин</td><td>Средняя</td><td>Среднее</td><td>Средний</td></tr><tr><td>Вход под чужим аккаунтом</td><td>Низкая</td><td>Высокое</td><td>Высокий</td></tr><tr><td>Неверные цены</td><td>Средняя</td><td>Высокое</td><td>Высокий</td></tr><tr><td>Потеря товаров в корзине</td><td>Средняя</td><td>Среднее</td><td>Средний</td></tr><tr><td>Заказ не создаётся</td><td>Средняя</td><td>Высокое</td><td>Высокий</td></tr><tr><td>Деньги списались, заказ не создан</td><td>Низкая</td><td>Критическое</td><td>Критический</td></tr><tr><td>Дублирование платежа</td><td>Низкая</td><td>Высокое</td><td>Высокий</td></tr><tr><td>Ошибка на «О нас»</td><td>Средняя</td><td>Низкое</td><td>Низкий</td></tr></tbody></table>\nОбрати внимание:\n- низкая вероятность != низкий риск\n- влияние может \"перетянуть\" риск вверх\n\n<b>Шаг 3. Приоритезация тестирования</b>\nТеперь риски превращаются в действия.\n<table><thead><tr><th>Уровень риска</th><th>Приоритет тестирования</th><th>Что делаем</th></tr></thead><tbody><tr><td>Критический</td><td>P1</td><td>Тестируем первым, максимально глубоко</td></tr><tr><td>Высокий</td><td>P2</td><td>Глубокие позитивные и негативные сценарии</td></tr><tr><td>Средний</td><td>P3</td><td>Основные сценарии</td></tr><tr><td>Низкий</td><td>P4</td><td>Smoke или визуальная проверка</td></tr></tbody></table>\n\n<b>Шаг 4. Связь рисков с тестами</b>\n<table><thead><tr><th>Область</th><th>Риск</th><th>Приоритет</th><th>Подход</th></tr></thead><tbody><tr><td>Оплата</td><td>Деньги списались без заказа</td><td>P1</td><td>Негативные сценарии, сбои, повторы</td></tr><tr><td>Оформление заказа</td><td>Заказ не создаётся</td><td>P2</td><td>Основные и граничные сценарии</td></tr><tr><td>Авторизация</td><td>Вход под чужим аккаунтом</td><td>P2</td><td>Безопасность, сессии</td></tr><tr><td>Каталог</td><td>Неверные цены</td><td>P2</td><td>Проверка расчётов</td></tr><tr><td>Корзина</td><td>Потеря товаров</td><td>P3</td><td>Базовые сценарии</td></tr><tr><td>«О нас»</td><td>Ошибка верстки</td><td>P4</td><td>Визуальная проверка</td></tr></tbody></table>\nЕсли тестирование будет прервано в любой момент,\nнаиболее рискованные области уже должны быть проверены.\n\n<b>Примеры из интернета:</b>\nВыделим следующие требования:\nD1.Обеспечение 1000 одновременных подключений к системе в секунду.\nD2. Безопасность совершения транзакций.\nD3. Доступ к транзакции должен быть только у лица, совершающего транзакции.\nD4. Обеспечение и поддержка стандарта SET (Secure Electronic Transaction).\n\nВ качестве риска продукта мы можем выделить:\nRP1. Падение системы при одновременных подключениях.\nRP2. Использование SQL инъекций в процессе совершения транзакции.\nRP3. Доступ к чужой транзакции при смене параметров в URL.\nRP4. Потеря данных при обрыве связи с банком в момент совершения транзакции.\nRP5. Использование недействующих сертификатов при обеспечении системы SET (Secure Electronic Transaction).\n\nВ качестве организационных рисков:\nRO1. Падение разрабатываемой системы из-за недоступности внешних систем.\nRO2. Наличие трудно воспроизводимых кейсов, которые не могут быть обнаружены в тестовой среде.\n\nНапример, на одном из проектов мы определяем проектные и продуктовые риски, которые могут сработать. Для этого в анализе участвуют аналитики, разработчики и QA - по одному представителю от команды.\nФормируется таблица рисков с продуктами. По ним определяется оценка вероятности срабатывания риска и его возможного влияния на систему по пятибалльной шкале. В таблице 1 — самое сильное влияние, 5 — самое слабое. Также и для вероятности 1 — большая вероятность, 5 — небольшая вероятность.\n<img src=\"https://sun9-77.userapi.com/s/v1/ig2/pX7jvxU5yy5-yjs570pMct0suXGBXntGgvZmANuGB4ODIXeSCqwiour4Ye4f3EzM8ZTVueX8PoXPjGP4pXbsqyNv.jpg?quality=95&amp;as=32x30,48x46,72x69,108x103,160x152,240x229,360x343,480x457,540x515,597x569&amp;from=bu&amp;cs=597x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nДалее по каждому из них происходит трассировка покрытия риска продукта тест-кейсами.\nВыбираем следующие проверки:\nTC1. Проверка нагрузки при наличии более 1000 подключений к системе\nТС2. Проверка нагрузки при 1000 подключений к системе\nТС3. Ввод SQL-инъекции во время совершения транзакции\nТС4. Ввод SQL-инъекции на странице успешной транзакции, путем подстановки других данных\nТС5. Ввод XSS (Cross-Site Scripting) скриптов в доступные поля для ввода при совершении транзакции\nТС6. Имитация разрыва связи с интернетом в процессе транзакции\nТС7. Выход из сеанса транзакции на этапе подтверждения\nТС8. Проверка просроченных сертификатов при совершении транзакции\n\n<img src=\"https://sun9-12.userapi.com/s/v1/ig2/o-d7dhfr6Jlm0XgTWlZgxGj4RiMjLKzJTBKr2bQfcl27q8lot2AKlRK05X21s4Qg6d27vmprD5Tono4MCvpKl6PW.jpg?quality=95&amp;as=32x30,48x45,72x68,108x102,160x151,240x227,360x341,480x454,540x511,599x567&amp;from=bu&amp;cs=599x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nТаким образом, приоритетные проверки - это TC2, ТС4, ТС5.\nТС6 и ТС8 имеют высокое влияние, но меньшую вероятность, поэтому приоритет проверки по ним ниже, но проверки тоже обязательны.\nТС7 не относится ни к одному из требований, но расширяет проверку на негативный сценарий, который возможен при стабильной работе системы.\n\n","path":"-"}},{"title":"Тестовая документация: что это?","data":{"code":"-","description":"<b>Тестовая документация</b> - это набор документов, которые описывают, как будет проводиться тестирование и какие результаты ожидаются. Она нужна для планирования, контроля и повторяемости тестирования.\nВ каждой компании ведение тестовой документации разница, всё зависит от того как команда привыкла разрабатывать продукты. В некоторых компаниях те или иные требования ведения тестовой документации упраздняются. Но существуют общие цели:\n- обеспечить четкое понимание, что и как тестировать\n- зафиксировать требования, сценарии, данные и результаты\n- позволить другим тестировщикам повторять тесты и проверять качество продукта\n\n<h4>Главные виды тестовой документации:</h4>\n<b>- тест-план </b>- цели тестирования, объём, ресурсы, сроки, риски.\n<b>- тест-кейсы</b> - конкретные шаги для проверки функции, сверка ожидаемого результата с фактическим а так же предусловиями\n<b>- тестовые сценарии</b> - более общие последовательности действий чем обычные тест-кейсы, часто для комплексного тестирования\n<b>- матрица трассируемости</b> - показывает что все требования покрыты тестами\n<b>- отчеты о тестировании</b> - результаты проведенных тестов, найденные баги, процент покрытия\n<b>- чек-листы</b> - это упрощённая форма тестовой документации\n<b>- баг-репорты</b> - документ описывающий шаги приводящие к дефекту.","path":"-"}},{"title":"Тестовая документация: чек-лист","data":{"code":"-","description":"<b>Чек-лист</b> - список проверок которые необходимо сделать/покрыть. Суть в том чтоб составить документ с набором пунктов проверок без детальных шагов, ожидаемых результатов как в тест-кейсах. Обычно используется для быстрых проверок, когда не надо описывать каждое действие подробно или тестирование производит поверхностный или регрессионный характер.\n\n<b>Например:</b>\nкнопка \"Сохранить\" в форме:\n- кнопка кликабельна\n- при нажатии данные сохраняются\n- появляется сообщение \"успешно\"\n\nкнопка \"Купить\":\n- кнопка видна\n- кнопка нажимается\n- открывается страница оплаты\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-69.vkuserphoto.ru/s/v1/ig2/ecIA022dMVTVf5rsj5Wb78OBIjngBScA5vJGQi5RZVJX3D4hq_Z3Az0bydB_V5Ns3ykFpViKNievBUb6c-7IvzU3.jpg?quality=95&amp;as=32x33,48x49,72x74,108x110,160x164,240x245,360x368,480x491,526x538&amp;from=bu&amp;cs=526x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Тестовая документация: тест-кейс","data":{"code":"-","description":"<b>Тест-кейс</b> - это документ который содержит подробный набор предусловий, шагов и ожидаемых результатов. В тест-кейсах более подробно описываются действия (шаги) приводящие к ожидаемым результатам. Чаще каждый шаг имеет ожидаемый результат. \n\n<b>Например:</b> (ОР) - ожидаемый результат\n<i>Тест-кейс №1</i> проверка кнопки \"Купить\" у товара\nШаг 1. Открыть страницу товара\nОР: страница товара открыта, присутствует кнопка \"Купить\"\nШаг 2. Нажать на кнопку \"Купить\"\nОР: происходит переход на страницу оплаты\n\nЕсли на каком то из шагов ОР не сходится с ФР (фактическим результатом) это и есть баг.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-88.vkuserphoto.ru/s/v1/ig2/hIGb2YaKhv3SdzxHjWMV_1D2vruwwOU4wj8t0OqWh7dO2ro1FuL5oihUOPxKzA0M3bQ8OA4lXhQcLVIAiDBsJRBQ.jpg?quality=95&amp;as=32x32,48x48,72x72,108x108,160x161,240x241,360x361,480x482,540x542,625x627&amp;from=bu&amp;cs=625x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n","path":"-"}},{"title":"Тестовая документация: тест-план","data":{"code":"-","description":"<b>Тест-план</b> - это документ который описывает стратегию и организацию тестирования всего проекта. В нём описывается что тестировать, как тестировать, кто будет тестировать и за какое время. \r\nОбычно этот документ пишет QA Leed или какой-нибудь старший тестировщик. Очень нужно чтоб в команде тестирования все понимали что будем тестировать. \r\n\r\n<h4>Основные разделы тест-плана: </h4>\r\n<b>1) Цель тестирования</b> - почему проводим тесты.\r\n<i>Например: </i>проверить соответствие функционала с требованиями и найти критические ошибки при их наличии\r\n<b>2) Объём тестирования</b> - что будет тестироваться и что не будет.\r\nНапример: Тестируем web-приложение, мобильное пока не будем\r\n<b>3) Типы тестирования</b> - функциональное, нагрузочное, регрессионное и т.д.\r\n<b>4) Критерии начала и завершения тестирования</b> - когда тестирование готово к запуску и когда его нужно закрывать.\r\n<i>Например:</i> начало после готовности сборки, конец - когда все критические баги исправлены\r\n<b>5) Ресурсы и роли </b>- кто будет тестировать, какие инструменты нужны, окружение, данные.\r\n<b>6) Подход к тестированию</b> - как тесты будут организованы: автоматические, ручные, чек-листы, тест-кейсы\r\n<b>7) Риски и допущения</b> - возможные проблемы: нехватка времени, зависимость от других команд, баги на продакшне.\r\n<b>8) Матрица ответственности и расписание</b> - кто за что отвечает, сроки выполнения\r\n<b>9) Критерии оценки результатов</b> - что считается успешным результатом, как фиксируются баги, уровень покрытия тестами \r\n\r\n\r\n<b>Упрощенный пример тест-плана:</b>\r\n<i>Тест-план:</i> Веб-приложение \"Online Shop\"\r\n<i>1. Цели тестирования:</i>\r\nПроверка соответствия функционала требованиям.\r\nОбеспечение корректной работы основных функций (регистрация, поиск, оформление заказа).\r\n<i>2. Объём тестирования:</i>\r\nВключено: регистрация, авторизация, каталог товаров, корзина, оформление заказа, оплата.\r\nИсключено: мобильное приложение, админ-панель, интеграция с внешними сервисами.\r\n<i>3. Типы тестирования:</i>\r\nФункциональное\r\nРегрессионное\r\nUI/UX проверка\r\nТестирование производительности (для корзины и поиска)\r\n<i>4. Критерии начала и завершения:</i>\r\nНачало: сборка тестового стенда готова, тестовые данные загружены.\r\nЗавершение: все критические баги исправлены, 95% тест-кейсов выполнены.\r\n<i>5. Ресурсы и роли:</i>\r\nТестировщики: 2 человека\r\nQA-инструменты: Jira, TestRail\r\nОкружение: тестовый сервер, база данных с демо-данными\r\n<i>6. Подход к тестированию:</i>\r\nРучное тестирование для функционала\r\nАвтоматизация регрессионных тестов (Selenium)\r\nИспользование чек-листов для UI\r\n<i>7. Риски и допущения:</i>\r\nВозможны задержки от команды разработки\r\nТестовые данные могут отличаться от продакшн\r\nНагрузка на тестовый сервер ограничена\r\n<i>8. Расписание:</i>\r\n<table><thead><tr><th>Этап</th><th>Дата начала</th><th>Дата окончания</th><th>Ответственный</th></tr></thead><tbody><tr><td>Подготовка тестового окружения</td><td>20.11.25</td><td>21.11.25</td><td>QA-1</td></tr><tr><td>Создание тест-кейсов</td><td>22.11.25</td><td>24.11.25</td><td>QA-2</td></tr><tr><td>Функциональное тестирование</td><td>25.11.25</td><td>30.11.25</td><td>QA-1, QA-2</td></tr><tr><td>Регрессионное тестирование</td><td>01.12.25</td><td>03.12.25</td><td>QA-1</td></tr><tr><td>Отчёт о тестировании</td><td>04.12.25</td><td>04.12.25</td><td>QA-2</td></tr></tbody></table>\r\n\r\n\r\n<i>9. Критерии оценки результатов:</i>\r\nОшибки классифицируются по степени критичности (критические, высокие, средние, низкие)\r\nУспешное выполнение тест-кейса = фактический результат соответствует ожидаемому\r\n\r\n<i>Дашборд:</i>\r\n<img src=\"https://sun9-28.vkuserphoto.ru/s/v1/ig2/FtSgKcKIeC2YzcRyMBA_yORLikI-VJvPocZXvii1sb4WqH6mnJdVj-w2VWsZ-hxqJj1op5B1yyyuAXn3dW5OrrQT.jpg?quality=95&amp;as=32x14,48x21,72x31,108x47,160x69,240x104,360x156,480x208,540x234,640x277,720x312,1080x468,1280x555,1440x624,1636x709&amp;from=bu&amp;cs=1636x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n<hr>\r\nДругие примеры:\r\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-45.vkuserphoto.ru/s/v1/ig2/PQVY41zyJQ9lnadg7r9o0wOgnrzZQvkFnjOl5spXKR7TfeobKVR30dOBgS5YLfmBaqALZIHQMRFQ1kRIqmok6MB9.jpg?quality=95&amp;as=32x23,48x35,72x52,108x79,160x116,240x175,360x262,480x349,540x393,640x466,673x490&amp;from=bu&amp;cs=673x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\r\n\r\n<i>Excel или другая таблица:</i>\r\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-88.vkuserphoto.ru/s/v1/ig2/KoH9FpUz2TaGlYZ_BAtltYVKePwNh60Q1vYC_XLJkIlG-dn-CIuh0qEgJrCZSt0luhWGDZECEG697DJtQ8jkeQRi.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x79,240x119,360x179,480x238,540x268,640x317,720x357,899x446&amp;from=bu&amp;cs=899x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\r\n\r\n<i>Доска для записей – Trello:</i>\r\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-45.vkuserphoto.ru/s/v1/ig2/hNNAByN8z72vIZszgJwyI3r0_w1Zbf8ScXeG3JBV5RuYpA_W9-0NzIKjTrUCs1Vbr1K8xcEzPhIMi-XwzsiMKOyC.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x133,360x199,480x266,540x299,640x354,720x398,806x446&amp;from=bu&amp;cs=806x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\r\n","path":"-"}},{"title":"Тестовая документация: тестовые сценарии","data":{"code":"-","description":"<b>Тестовый сценарий</b> - это высокоуровневое описание того, <b>ЧТО </b>нужно проверить, без деталей <b>КАК </b>именно.\n\n<h3>Зачем вообще нужны тестовые сценарии</h3>\n1) Зафиксировать объём тестирования\n2) Понять, ничего ли не забыли\n3) Быстро договориться с командой на уровне смысла, а не кнопок\n4) Используются:\n- в тест-плане\n- при оценке объёма работ\n- как основа для тест-кейсов\n\n<hr>\nПримеры:\nПример №1 - Авторизация\n<span style=\"color:red\">Неправильно (это не сценарий):</span>\nВвести логин, ввести пароль, нажать кнопку\n<span style=\"color:green\">Правильно (тестовый сценарий):</span>\nПроверка авторизации пользователя с валидными и невалидными данными\nЭто один сценарий, а тест-кейсов внутри - десятки.\n\nПример №2 - Интернет-магазин\nТестовые сценарии:\n1) Проверка добавления товара в корзину\n2) Проверка изменения количества товара в корзине\n3) Проверка оформления заказа\n4) Проверка оплаты заказа\n5) Проверка отмены заказа\n\nТут:\n- Нет шагов\n- Нет конкретных данных\n- Нет UI-деталей\n- Только смысл проверки.\n<hr>\n<h3>Так же альтернативное трактование по тестовым сценариям:</h3>\n<b>Тестовый сценарий</b> - логический блок тестирования функциональности, объединяющий несколько тест-кейсов. Это группа тест-кейсов, покрывающая одну функциональность / фичу / пользовательский поток.\nПример:\nТестовый сценарий: \"Авторизация пользователя\"\nВнутри:\n- Успешная авторизация\n- Неверный пароль\n- Пустой логин\n- SQL-инъекция\n- Блокировка после N попыток\n\nЭта трактовка:\n- используется в Jira / TestRail / TestLink\n- удобна для покрытия\n- масштабируется\n- нормально ложится на спринты\n<hr>\nИтого: В практике QA тестовый сценарий - это логическая группа тест-кейсов, покрывающая определённую функциональность или пользовательский поток.\nИногда под тестовым сценарием понимают high-level user flow, но в рабочих инструментах сценарий обычно используется как контейнер для тест-кейсов.\n","path":"-"}},{"title":"Тестовая документация: матрица трассируемости","data":{"code":"-","description":"<b>Матрица трассируемости (Traceability Matrix) </b>- это таблица, которая связывает требования (технические, бизнес или пользовательские) с тестами, которые эти требования проверяют.\nЦель - убедиться, что каждое требование покрыто хотя бы одним тестом, и что нет лишних тестов, не связанных с требованиями.\n\nПочему это важно:\n- Проверка полноты тестирования\n- Легче отслеживать изменения требований и понимать, какие тесты надо обновить\n- Упрощает аудит и отчётность перед заказчиком\n\nЧто бы узнать насколько процентов покрыта матрица, есть специальная формула:\nПроцент покрытия = (Количество проверенных требований / Общее количество требований) × 100%<br>\n\nПример простейшей матрицы трассируемости:\n<table><caption>Матрица трассируемости требований</caption><thead><tr><th>ID требования</th><th>Описание требования</th><th>ID теста</th><th>Статус теста</th></tr></thead><tbody><tr><td>REQ-001</td><td>Пользователь может зарегистрироваться</td><td>TC-001, TC-002</td><td>Пройдено</td></tr><tr><td>REQ-002</td><td>Пользователь может авторизоваться</td><td>TC-003</td><td>Не пройдено</td></tr><tr><td>REQ-003</td><td>Возможность восстановления пароля</td><td>TC-004</td><td>Пройдено</td></tr></tbody></table>\nREQ-001 &gt; TC-001, TC-002\nВсе тесты проверяют конкретное требование.\nСтатус теста показывает текущее состояние покрытия.\n\nВажные моменты\n1) Требования &gt; Тесты\n- Каждое требование должно иметь хотя бы один тест.\n2) Тесты &gt; Требования\n- Каждый тест проверяет хотя бы одно требование.\n3) Можно расширять: добавить поля \"Приоритет», \"Серьёзность\", \"Исполнитель\", \"Дата запуска\" и т.д.\n\n<hr>\n<h3>Мини-пример для сайта интернет-магазина</h3>\nПредставим, что у нас есть блоки функциональности: Регистрация, Авторизация, Корзина, Оформление заказа.\nТаблица трассируемости:\n<table border=\"1\"><caption>Матрица трассируемости интернет-магазина</caption><thead><tr><th>ID требования</th><th>Функциональный блок</th><th>Описание требования</th><th>ID теста</th><th>Статус теста</th></tr></thead><tbody><tr><td>REQ-001</td><td>Регистрация</td><td>Пользователь может зарегистрироваться</td><td>TS-REG-001, TS-REG-002</td><td>Пройдено</td></tr><tr><td>REQ-002</td><td>Авторизация</td><td>Пользователь может авторизоваться</td><td>TS-AUTH-001</td><td>Не пройдено</td></tr><tr><td>REQ-003</td><td>Корзина</td><td>Можно добавить товар в корзину</td><td>TS-CART-001, TS-CART-002</td><td>Пройдено</td></tr><tr><td>REQ-004</td><td>Корзина</td><td>Можно удалить товар из корзины</td><td>TS-CART-003</td><td>Пройдено</td></tr><tr><td>REQ-005</td><td>Оформление заказа</td><td>Пользователь может оформить заказ</td><td>TS-CHECKOUT-001</td><td>Не пройдено</td></tr><tr><td>REQ-006</td><td>Оформление заказа</td><td>Счёт и итоговая сумма отображаются корректно</td><td>TS-CHECKOUT-002</td><td>Пройдено</td></tr></tbody></table>\nПроцент покрытия:  (4 / 6) × 100% = 66.7%\n\nЕщё один вариант:\nФТ - функциональные требования\nТК - тест кейс\nМатрица показывает, какие тесты обеспечивают проверку каждого функционального требования. Важно, что одно требование может тестироваться сразу несколькими сценариями.\n<img src=\"https://sun9-15.vkuserphoto.ru/s/v1/ig2/5wgLr28W-8TQrvLpnhyA3pS2rJ8f29G3-zmTjjCCtStIACJsff_Jizox55u_I9StgcKpyYIlWb9aWHVswm2FbBv4.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x88,240x133,360x199,480x265,540x299,640x354,720x398,908x502&amp;from=bu&amp;cs=908x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n","path":"-"}},{"title":"Тестовая документация: отчет о тестировании","data":{"code":"*","description":"<b>Отчёт о тестировании </b>- это документ, в котором фиксируются результаты проведённых тестов, фактическое состояние тестируемой системы и оценка качества продукта.\nЦель - показать заинтересованным сторонам (PO, менеджерам, команде разработки), насколько продукт готов к выпуску, какие дефекты найдены и насколько они критичны.\n\nЗачем нужен отчёт о тестировании:\n- Контроль качества: показывает, какие функции работают, а какие нет.\n- Прозрачность: менеджеры и заказчики видят фактическое состояние продукта.\n- Принятие решений: помогает решать, выпускать продукт в релиз или откладывать исправления.\n- Аудит и документация: фиксирует проведённую работу для внутреннего контроля или внешних проверок.\n- Анализ рисков: выявляет критичные дефекты и оценивает их влияние на бизнес.\n\nТипичная структура отчёта о тестировании:\n1) Общие сведения\n- Название проекта\n- Версия продукта\n- Даты проведения тестирования\n- Команда тестировщиков\n2) Объект тестирования\n- Модули/функции, которые проверялись\n3) Типы и объём тестирования\n- Функциональное, регрессионное, нагрузочное и т.д.\n- Количество проведённых тест-кейсов и тест-сценариев\n4) Результаты тестирования\n- Пройдено / Не пройдено / Заблокировано\n- Список найденных дефектов с Severity и Priority\n- Статистика покрытия тестами\n5) Анализ и выводы\n- Общая оценка качества продукта\n- Рекомендации: готово к релизу, нуждается в исправлениях, требует дополнительного тестирования\n\nФормула расчёта процента покрытия:\nПроцент покрытия = (Количество пройденных тест-кейсов / Общее количество тест-кейсов) × 100%;\n\nПример простого отчёта о тестировании:\n<table border=\"1\"><caption>Результаты тестирования функциональных блоков</caption><thead><tr><th>Функциональный блок</th><th>Тест-кейсы</th><th>Пройдено</th><th>Не пройдено</th><th>Заблокировано</th><th>Найденные дефекты</th></tr></thead><tbody><tr><td>Регистрация</td><td>5</td><td>5</td><td>0</td><td>0</td><td>-</td></tr><tr><td>Авторизация</td><td>3</td><td>2</td><td>1</td><td>0</td><td>TC-AUTH-003 (medium)</td></tr><tr><td>Корзина</td><td>4</td><td>4</td><td>0</td><td>0</td><td>-</td></tr><tr><td>Оформление заказа</td><td>3</td><td>2</td><td>1</td><td>0</td><td>TC-CHECKOUT-001 (high)</td></tr><tr><td colspan=\"5\"><strong>Процент покрытия тестами</strong></td><td><strong>73.3%</strong></td></tr></tbody></table>\nПроцент покрытия: (11 / 15) × 100% = 73.3%\nВывод:\nОсновные функции работают, но критичный баг в оформлении заказа требует исправления перед релизом.\nРекомендация: исправить TC-CHECKOUT-001 и провести регрессию.","path":"*"}},{"title":"Тестовая документация: баг-репорт","data":{"code":"-","description":"<b>Баг-репорт</b> - документ описывающий ошибку в системе. Он нужен чтоб показать разработчику где находится ошибка и он мог её исправить. \n\n<b>В тестировании баг репорт обычно содержит следующие параметры:</b>\n- id (номер) репорта (для идентификации бага в баг трекере)\n- Заголовок (краткая суть ошибки)\n- Предусловия (если есть такие для проверки)\n- Шаги воспроизведения (как повторить баг)\n- Ожидаемый результат (как должно работать)\n- Фактический результат (что сломалось)\n- Вложения (скриншоты, логи, видео)\n- Окружение (на чем баг воспроизводился)\nЧем точнее составлен баг, тем быстрее его исправят.\n\n<b>Так же у баг-репортов есть другие параметры. </b>Например серьёзность и приоритет. Серьёзность (Severity) - это настолько серьёзно этот баг влияет на работу системы.\nПриоритет (Priority) - насколько быстро его должны исправить. \nSeverity = насколько баг ломает систему\nPriority = насколько срочно его надо чинить\n\n<b>Список серьёзностей:</b>\n- Trivial (Low) - мелкая косметика, опечатки, пиксель-хантинг\n- Minor - небольшая ошибка, не мешает работать, есть обходной путь\n- Major - значительное нарушение работы функции, но без полного отказа\n- Critical - ключевая функция работает неправильно или не работает, но продукт не полностью лежит\n- Blocker - тестирование дальше невозможно, продукт или функция полностью недоступны. Иногда Blocker не включают в Severity, а относят к Priority.\n\n<b>Список приоритета:</b>\n1. High (высокий) P1 - нужно исправлять немедленно. Блокирует критический функционал, релиз без фикса невозможен\n2. Medium (средний) P2 - желательно исправить в ближайших циклах разработки. Ошибка есть, но есть обходной путь или влияние умеренное.\n3. Low (легкий) P3 - Можно отложить, не влияет на ключевой функционал, не мешает релизу.\n4. Так же иногда есть P4 — исправим когда-нибудь / в бэклог.\n\n<img src=\"https://sun9-16.vkuserphoto.ru/s/v1/ig2/D5jOVU3tzCh61w70F5dtxUY8qhsAg4EHXf3xHhUjkrh5va49dJ4cMjWkcvTYpPrv9IdOaqQ5ernyTszGa18XGKaU.jpg?quality=95&amp;as=32x17,48x26,72x39,108x59,160x87,240x131,360x196,480x262,540x295,640x349,720x393,1080x589,1280x699,1440x786,1781x972&amp;from=bu&amp;cs=1781x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Например:</b> в кейсе проверяется кнопка \"Купить\" на странице товара.\nТест кейс:\nШаг 1: Открыть страницу товара \nОР: страница товара открыта, присутствует кнопка \"Купить\"\nШаг 2: Нажать на кнопку \"Купить\" \nОР: происходит переход на страницу оплаты /checkout\n\n<i>Баг:</i>\nЗаголовок: id-1 Не открывается страница оплаты\nШаги: \n1. Открыть страницу товара\n2. Нажать на кнопку \"Купить\"\nОжидаемый результат: открылась страница оплаты\nФактический результат: по нажатию на кнопку появляется поап \"Внутренняя ошибка сервера\" (500) и ничего не происходит\nВложения: Видео.mp4, log.txt (из консоли DevTools), XAR файл из раздела Network в DevTools\nОкружение: Windows 11 25H2 &amp;&amp; Chrome Версия: 142.0.7444.175\nСерьезность: Критическая (Critical)\nПриоритет: High (Высокий)\n\n<hr>\n<h3>Высокий  приоритет, низкая серьёзность</h3>\nТак же существуют такие ситуации когда серьезность низкая но приоритет высокий:\nУсловие:\nЛоготип искажён / старый / неправильного цвета\nСайт полностью работает\nЭто прод, публичная главная страница, идёт рекламная кампания\nПочему так:\nНичего не сломано функционально &gt; не критично\nРепутационный и маркетинговый ущерб &gt; срочно\n\"Бизнесу больно, системе - нет\"\nВердикт:\nПриоритет: высокий\nСерьезность: низкая\n<hr>\n<h3>Низкий приоритет, высокая серьёзность</h3>\nИ наоборот: \nНа проде:\nЕсть модуль экспорта данных в XML для регулятора\nПри запуске экспорт всегда падает с 500\nМодуль используется только раз в квартал\nСледующая обязательная выгрузка - через 2 месяца\nСейчас данные никуда не отправляются, но и отправлять пока не надо\nКлассификация:\nСерьёзность: высокая (Critical)\nФункция полностью неработоспособна. Если понадобится - задача невыполнима.\nПриоритет: низкий (Low)\nНет текущего бизнес-сценария. Нет дедлайна. Нет немедленного ущерба.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-50.vkuserphoto.ru/s/v1/ig2/JKPz8zdJBj0xdB-UTtJgem3PS7mBJZmQJCRGj5henVScoVs7y7hPDUq00-5NA783uzLUCvPb-Om7lmbYqNsoPrm5.jpg?quality=95&amp;as=32x25,48x37,72x55,108x83,160x123,240x185,360x277,388x299&amp;from=bu&amp;cs=388x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n\nПример в Jira:\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-62.vkuserphoto.ru/s/v1/ig2/SdMTTk3DSgdCG41qaFty7zkXJNJ04uPM9CHhB6zGLze3bcgYYedYdEXM3DkXYOZBVR391io_culNtThuwQht1lpJ.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720,1440x810,1919x1079&amp;from=bu&amp;cs=1919x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Тестовая документация: Жизненный цикл бага/дефекта","data":{"code":"-","description":"<b>Жизненный цикл дефекта</b> - это последовательность статусов, через которые проходит баг от момента создания до закрытия.  Он начинается с регистрации бага (новый), затем проходит через стадии \"в работе\" и \"исправлен\", после чего тестировщик проверяет исправление. Если баг исправлен, он закрывается; если нет, его переоткрывают для дальнейшей работы. \n\n<h4>Типовой набор:</h4>\n<b>New / Open (Новый/Открыт)</b> - дефект создан тестировщиком, ожидает анализа.\n<b>In Progress (В процессе/В работе)</b> - разработчик взял задачу в работу.\n<b>Fixed / Resolved (Пофикшен/Решено)</b> - разработчик внёс правки и передал дефект на проверку.\n<b>Ready for QA / In QA (Готов для QA/у QA)</b> - тестировщик начал проверку.\n<b>Verified (Проверен/Исправлен)</b> - дефект подтверждён как исправленный.\n<b>Closed (Закрыт)</b> - баг закрыт полностью.\n\n<h4>Промежуточные статусы:</h4>\n<b>Reopened (Переоткрыт)</b> - дефект повторяется или исправлен частично.\n<b>Rejected / Not a Bug (Отклонён / Не баг)</b> - разработчик не признаёт дефектом (по ТЗ так и задумано).\n<b>Duplicate (Дубликат)</b> - такой баг уже существует.\n<b>Won’t Fix (Не будет исправлено)</b> - исправлять не будут.\n<b>Deferred / Postponed (Отложен/Перенесён)</b> - перенесён на следующий релиз.\n<b>Cannot Reproduce (Не воспроизводится)</b> - не удаётся воспроизвести.\n\n<img src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/F79ul4y6DVKEC_ELMuWU6Qqw59IHb7r4jPP9dp20qO3qYtzA3QINoQXEcXnTFaPHMoGFwAqNgzH5GTs1s8VXDR51.jpg?quality=95&amp;as=32x21,48x31,72x46,108x69,160x103,240x154,360x232,480x309,540x347,544x350&amp;from=bu&amp;cs=544x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-65.vkuserphoto.ru/s/v1/ig2/U2CQFhwsXujht6u6CzITVXhMGs1YRsCOQlj1RKi1XCLJ-BVXsDFq16YhRAwbwV_2ghfzQa3cv1WNgdeWIvakoYFL.jpg?quality=95&amp;as=32x36,48x55,72x82,108x123,160x182,240x273,360x410,480x547,540x615,638x727&amp;from=bu&amp;cs=638x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">","path":"-"}}]},{"header":"QA Теория: системы и технологии","links":[{"title":"HTTP: Клиент-серверная архитектура","data":{"code":"-","description":"<b>Клиент-серверная архитектура</b> - это взаимодействие между клиентом и сервером а так же базой данных. \r\n<b>Например:</b> клиент отправляет HTTP Request (запрос) на сервер &gt; он определяет это в БД &gt; БД отправляет серверу данные &gt; сервер отправляет клиенту (нам) HTTP Response (ответ).\r\n\r\n<b>Клиент </b>- фронтэнд (интефрейс пользователя, визуализация)\r\n<b>Сервер </b>- бэкэнд (логика работы продукта, вычисления)\r\n<b>БД</b> - база данных (хранение записей и информации)\r\n\r\nЧаще всего фронтэнд и бэкэнд работают через API.\r\n\r\n<b>Ещё более подробный пример из продукта:</b> пользователь вводит логин и пароль для авторизации в интерфейсе, этот запрос отправляется в бэкэнд через API, бэкэнд отправляет запрос в БД дабы удостовериться что пользователь существует и пароль подходит. Далее производит БД отправляет ответ бэкэнду, бэкенд выполняет действия согласно требованию и возвращает ответ пользователю (авторизован/не авторизован и т.д.)\r\n\r\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-49.vkuserphoto.ru/s/v1/ig2/Jfu5GCx8nzIYrsrGk8BCJlGROj4HPKiMcEUROSvTxraLJk9uYE-EfZ8V-4USCV0DtAOz7SMpAZ_E06dihCYzG6ux.jpg?quality=95&amp;as=32x18,48x28,72x41,108x62,160x92,240x138,360x206,480x275,540x310,640x367&amp;from=bu&amp;cs=640x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"HTTP: HTTP/HTTPS/Коды ответа","data":{"code":"-","description":"<b>HTTP (HyperText Transfer Protocol) </b>- это протокол передачи данных от сервера к пользователю (клиенту). Через HTTP передаются данные двусторонние (Запрос/Ответ). \n\n<b>HTTPS </b>- это протокол защищённого типа, выполняет те же функции что и HTTP только в защищённом виде (зашифрованы).\n\n<h4>Так же при запросах/ответах к серверу существуют статус коды (коды ответа).</h4>\n<b>1хх-е коды</b> - информационные коды, означают что сервер готов получить запрос\nНапример: 100 Continue (продолжайте)\n\n<b>2хх-е коды</b> - означают что сервер успешно обработал запрос\nНапример: 200 OK (хорошо)\n\n<b>3хх-е коды</b> - происходит редирект (переход/перенаправление) на другую страницу\nНапример: 301 Moved Permanently - страница переехала навсегда\n\n<b>4хх-е коды</b> - ошибка клиента, сервер не смог обработать запрос что то не так с запросом.\nНапример: 401 - отсутствие авторизации, 403 - отсутствие доступа, 404 - отсутствие ресурса на сервере и т.д.\n\n<b>500е коды</b> - ошибка на бэкэнде (сервере). Чаще всего встречается когда бэкэнд падает. \nНапример: 500 Internal Server Error (внутренняя ошибка сервера)\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-21.vkuserphoto.ru/s/v1/ig2/4y8LyhCiUKsu3IYYk5FTVkvMiqD5u31xyxvGgNTWwwbnND8tFsQmDRH0erPSn1JDcZzlphrXmuLRMPaPxLQShUOC.jpg?quality=95&amp;as=32x22,48x33,72x50,108x75,160x111,240x167,360x250,480x334,540x376,640x445,720x501,920x640&amp;from=bu&amp;cs=920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"HTTP: Основные HTTP запросы","data":{"code":"-","description":"У HTTP запросов присутствует такой параметр как метод. Метод позволяет определить какой запрос отправляется на сервер. Основные: GET, POST, PUT, DELETE, PATCH. Так же внутри запроса присутствуют несколько дополнительных параметров например Body (тело запроса), Headers (заголовок запроса), ещё некоторые свойства запросов как безопасность, кешируемость и идемпотентность. \n\nТак же все эти методы по сути своей рекомендации по работе с запросами REST. Тем самым если не придерживаться рекомендаций то даже через POST можно получить данные (если разработчики реализуют функционал обработки). \n\n<b>Body </b>- тело запроса в котором находится передаваемая информация на сервер. Например в JSON варианте. \n \n<b>Headers</b> - это служебные поля в HTTP-сообщении, передающие метаданные о запросе, клиенте и ожидаемой обработке запроса сервером.\n\n<b>Безопасность</b> - обуславливается изменением состояния ресурсов на сервере. Если запрос не меняет состояние (такие как GET) то он безопасен. В остальных случаях безопасности нет т.к. можно добавлять, изменять, удалять ресурсы и данные на сервере.\n\n<b>Кешируемость</b> - сохраняет на клиенте основные необходимые файлы. Для того чтоб не грузить с сервера их каждый раз.\n\n<b>Идемпотентность</b> - это свойство запроса давать одинаковый результат при многократном выполнении.\n\n<h4>Основные:</h4>\n<b>GET </b>- запрос отвечает за получение данных с сервера. У данного метода отсутствует параметр Body. Все запросы выполняются по URL (прямой путь) к ресурсу для получения данных. Так же он безопасен, может кешироваться и он идемпотентен.\n<b>POST </b>- запрос отвечает за отправку данных на сервер. У данного метода присутствует параметр Body. Он НЕ безопасен, НЕ идемпотентен и НЕ кешируем. \n<b>PUT </b>- запрос отвечает за полное изменение данных, на сервер отправляется новая запись замещающая старую. Данный метод использует Body, он НЕ безопасный, НЕ кешируемый, идемпотентный. \n<b>DELETE </b>- запрос отвечает за удаление данных на сервере. Данный метод использует Body, он НЕ безопасный, НЕ кешируемый, идемпотентный. \n<b>PATCH </b>- запрос отвечает за частичное изменение данных на сервере. Данный метод использует Body, он НЕ безопасный, НЕ кешируемый, НЕ идемпотентный. \n\n<h5>Более редкие методы запросов: </h5>\n<b>OPTIONS </b>- используется для получения списка методов которые предоставляет данная URL\n<b>HEAD </b>- аналог GET но в ответ от сервера будет без Body. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.\n<b>TRACE </b>- для диагностики, чтоб проследить все цепочки задействованных звеньев, какие изменения произошли в теле запроса и т.п.\n<b>CONNECT</b> - установка TCP \"туннеля\" от клиента к серверу. \n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-27.vkuserphoto.ru/s/v1/ig2/za4jZ7xMh3JTTx4XQqtPnW5VE6Rlth3jrxh4A1IxKtoOYYYU4j5q2yh-Xt6CV6JIN5yuslRE0ormhN_aIkm0E3Jt.jpg?quality=95&amp;as=32x12,48x18,72x27,108x41,160x61,240x91,360x137,480x183,540x205,640x243,720x274,1080x411,1280x487,1440x548,1572x598&amp;from=bu&amp;cs=1572x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\"><br>\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-30.vkuserphoto.ru/s/v1/ig2/Cu0fZi0s7BHMhhMWbnnyJWUtPVSNNsWpHu9Q9mBc6M1YTOS81elNFhVW8mRRiwrr6ojQEuFCjL3Xo91gIKaOXP3B.jpg?quality=95&amp;as=32x22,48x33,72x50,108x75,160x111,240x166,360x250,480x333,540x375,640x444,720x499,960x666&amp;from=bu&amp;cs=960x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">\n\n","path":"-"}},{"title":"HTTP: Headers - заголовки","data":{"code":"-","description":"<b>HTTP-заголовки</b> - это пары <i>имя: значение</i>, которые передаются в начале HTTP-запроса и описывают:\n- кто делает запрос\n- что именно он отправляет\n- что ожидает получить\n- при каких условиях.\nОни не являются телом запроса и не влияют напрямую на URL, но <b>кардинально влияют на поведение сервера.</b>\n\n<b>Что делают headers на практике:</b>\n- Управляют аутентификацией\n- Определяют формат данных\n- Влияют на кеширование\n- Управляют CORS\n- Определяют локаль, кодировку, сжатие\n\n<h3>Список headers</h3>\n<h4>1) Request Headers (что клиент сообщает серверу)</h4>\n<h5>1.1 Идентификация клиента</h5>\n- <b>Host </b>- к какому домену обращается запрос (обязателен в HTTP/1.1)\n- <b>User-Agent</b> - кто ты: браузер, версия, ОС\n- <b>Referer </b>- с какой страницы пришёл запрос\n<br>\n<hr>\n<h5>1.2 Формат и контент</h5>\n<b>Accept </b>- какие типы ответа клиент принимает (application/json)\n<b>Accept-Language</b> - предпочтительный язык ответа\n<b>Accept-Encoding</b> - допустимое сжатие (gzip, br)\n<b>Content-Type</b> - формат тела запроса (если есть тело)\n<b>Content-Length</b> - размер тела в байтах\n<br>\n<hr>\n<h5>1.3 Аутентификация и безопасность</h5>\n<b>Authorization</b> - данные авторизации (Bearer, Basic, etc.)\n<b>Cookie </b>- куки, сохранённые браузером\n<b>Origin </b>- источник запроса (важен для CORS)\n<br>\n<hr>\n<h5>1.4 Управление кешем</h5>\n<b>Cache-Control </b>- правила кеширования\n<b>If-None-Match</b> - ETag для условного запроса\n<b>If-Modified-Since </b>- проверка изменений ресурса\n<br>\n<hr>\n<h5>1.5 Управление соединением</h5>\n<b>Connection </b>- держать ли соединение (keep-alive)\n<b>Upgrade </b>- переход протокола (например, WebSocket)\n<br>\n<hr>\n<h4>2) Response Headers (что сервер сообщает клиенту)</h4>\n<h5>2.1 Описание ответа</h5>\n<b>Content-Type</b> - формат тела ответа\n<b>Content-Length</b> - размер ответа\n<b>Content-Encoding </b>- сжатие\n<br>\n<hr>\n<h5>2.2 Кеш</h5>\n<b>Cache-Control</b> - можно ли кешировать\n<b>ETag </b>- идентификатор версии ресурса\n<b>Expires </b>- срок жизни кеша\n<br>\n<hr>\n<h5>2.3 Cookies</h5>\n<b>Set-Cookie</b> - установка cookie\n(HttpOnly, Secure, SameSite - критично!)\n<br>\n<hr>\n<h5>2.4 CORS  (механизм безопасности браузера)</h5>\n<b>Access-Control-Allow-Origin</b> - указывает, каким origin разрешено получать ответ.\n<b>Access-Control-Allow-Methods</b> - перечисляет HTTP-методы, разрешённые для кросс-доменных запросов.\n<b>Access-Control-Allow-Headers</b> - определяет, какие request headers разрешено отправлять в CORS-запросе\n<br>\n<hr>\n<h5>2.5 Безопасность</h5>\n<b>Strict-Transport-Security </b>- только HTTPS\n<b>X-Content-Type-Options</b> - запрет MIME sniffing\n<b>Content-Security-Policy</b> - защита от XSS\n<b>X-Frame-Options</b> - защита от clickjacking\n<br>\n<hr>\n<h4>3 Общие (туда-сюда)</h4>\n<b>Date </b>- время отправки сообщения\n<b>Transfer-Encoding</b> - HTTP-заголовок, который определяет КАК передаётся тело сообщения, а не ЧТО в нём и не в каком формате chunked и т.п.\n<b>Via</b> -  прокси / балансировщики\n\n<h4>Кастомные headers</h4>\n<b>X-Request-ID</b> - трейсинг запросов\n<b>X-Forwarded-For</b> - реальный IP клиента\n<b>X-*</b> - любые внутренние договорённости\n<hr>\n<b>Пример:</b>\nGET /api/users HTTP/1.1\nHost: example.com\nUser-Agent: Mozilla/5.0\nAccept: application/json\nAuthorization: Bearer eyJhbGciOiJIUzI1...\n<b>Здесь:</b>\nHost - к какому хосту обращаемся\nUser-Agent - кто ты вообще такой\nAccept - в каком формате хочешь ответ\nAuthorization -  докажи, что тебе можно\n\n<img src=\"https://sun9-74.userapi.com/s/v1/ig2/a2k7wqR3W8S4GXGEq3VaqTdAi24VsZrBy4-IQW-82f_LLxGBCO_lKmtsb7c1-QCFBKsXK6mxATZVZEG4M0LR1dv8.jpg?quality=95&amp;as=32x26,48x38,72x58,108x86,160x128,240x192,360x288,480x383,537x429&amp;from=bu&amp;cs=537x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n","path":"-"}},{"title":"HTTP: Идемпотентность","data":{"code":"-","description":"<b>Идемпотентность </b>- это свойство операции, при котором повторное выполнение не изменяет итоговое состояние системы. То есть результат многократного вызова идентичен первому.\n\n<h4>Например:</h4>\n<b>Get запрос /users/1</b> - сколько раз его не вызывай, он каждый раз будет возвращать пользователя под номером 1. Результат от сервера - получи информацию.\n\n<b>Put запрос /users/1 </b>- сколько не заменяй данные у пользователя, он каждый раз будет выполнять замену данных этого пользователя.  Результат от сервера - данные пользователя изменены\n\n<b>Delete запрос /users/1 </b>- каждый раз будет удалять пользователя под номером 1, даже если его нет. Результат от сервера - удален пользователь.\n\n<h5>Не идемпотентные:</h5>\n<b>Post запрос /users/ (в body данные о пользователе)</b> - при многократной отправке данных на сервер, будет каждый раз создаваться новый пользователь. 10 раз отправил - 10 пользователей получил. Каждый вызов не идентичен первому. \n\n<b>Patch запрос /users/1 (в body некоторые другие данные о пользователе)</b> - вносит частичные изменения, результат зависит от предыдущего состояния ресурса. Допустим +100$ на баланс пользователя. Если отправить так 10 раз то итого будет +1000$. В отличии от PUT который заменяет каждый раз данные. \n\n<img src=\"https://sun9-20.userapi.com/s/v1/ig2/WbHqES5pOeZ_Qx3Q0jJI7Jnre_WOo5NkKep09ordliFUYsGtPEXf2GJ7i7fnmAFqDHbPFGPo-mt2t6kVDhPzXj2-.jpg?quality=95&amp;as=32x24,48x36,72x54,108x81,160x120,240x180,360x270,480x360,540x405,640x480,720x540,740x555&amp;from=bu&amp;cs=740x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">","path":"-"}},{"title":"HTTP: Кеш/Куки","data":{"code":"-","description":"<b>Кеш</b> - это временное хранилище данных в браузере, чтобы сайты загружались быстрее и уменьшить нагрузку на сервер. В кешах обычно хранятся скрипты JS, изображения, html страниц, стили. При первой загрузке сайта возможно что сайт будет загружаться чуть дольше, но зато в последующих загрузках сайт будет загружаться практически моментально. \n\n<b>HTTP cache</b> - это механизм временного хранения ответа, чтобы:\n- не ходить к серверу повторно\n- снизить задержку\n- уменьшить нагрузку\nCache оптимизирует производительность, не состояние.\n\n<h4>Основные cache-заголовки</h4>\n<h5>1. Cache-Control (главный)</h5>\n<b>Примеры:</b>\nCache-Control: max-age=3600\nCache-Control: no-cache\nCache-Control: no-store\nCache-Control: private\n<b>Смысл:</b>\n<b>max-age</b> - сколько секунд можно использовать кеш\n<b>no-cache</b> - можно хранить, но надо перепроверить\n<b>no-store</b> - не хранить вообще\n<b>private</b> - только для браузера, не для proxy\n\n<h5>2. ETag</h5>\n<b>Пример:</b>\nETag: \"v123\"\n- идентификатор версии ресурса\n- используется для условных запросов\n<b>Клиент:</b>\n- If-None-Match: \"v123\"\n<b>Сервер:</b>\n- 304 Not Modified - бери из кеша\n- 200 OK - новая версия\n\n<h5>3. Last-Modified</h5>\n- более грубый аналог ETag\n- по времени изменения\n\n <h5>4. Expires</h5>\n- устаревший механизм\n- абсолютная дата\n<hr>\n<b>Куки</b> - это тоже хранилище, но информации и сессий. Туда записываются данные о пользователе, или той же корзине товаров. Если пользователь авторизовался на сайте, то сохранить его авторизацию чтоб он зайдя на сайт в следующий раз уже был авторизован. В общем записываются все пользовательские данные. Так же на сайтах бывает окно с подтверждением использование куков, обычно чтоб собрать данные о пользователе и отдать их рекламным агенствам. Это позволяет нацелено рекомендовать пользователю то чем он интересуется в виде рекламы. \n\n<b>HTTP cookies</b> - это небольшие пары ключ=значение, которые:\n- сервер устанавливает клиенту,\n- клиент автоматически отправляет обратно серверу\n- при каждом запросе, если совпадают условия (домен, путь, флаги).\n\n<b>Где они живут</b>\n- Хранятся у клиента (браузер)\n- Передаются в headers, не в body:\nсервер &gt; Set-Cookie\nклиент &gt; Cookie\n\n<b>Жизненный цикл cookie</b>\n<b>Сервер:</b>\n- Set-Cookie: sessionId=abc123; HttpOnly; Secure\n- Браузер сохраняет\n<b>При следующих запросах:</b>\n- Cookie: sessionId=abc123\nСервер не просит cookie каждый раз - браузер шлёт их сам.\n\n<h4>Ключевые атрибуты cookie (и зачем они)</h4>\n<b> Expires / Max-Age</b>\n- срок жизни cookie\n- без них &gt; session cookie\n<b>Domain</b>\n- для какого домена доступна cookie\n- .example.com → доступна поддоменам\n<b>Path</b>\n- ограничивает URL /api ≠ /\n<b>Secure</b>\ncookie передаётся только по HTTPS\n<b>HttpOnly</b>\n- недоступна из JS\n- защита от XSS\n<b>SameSite</b>\n- защита от CSRF\n- Strict | Lax | None\n\n<b>Для чего cookies реально используют</b>\n- сессии (sessionId)\n- аутентификация\n- пользовательские настройки\n- трекинг\n\n<b>Критичное ограничение</b>\n- cookies автоматически отправляются\n- они увеличивают каждый запрос\n- плохи для хранения больших данных\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-21.vkuserphoto.ru/s/v1/ig2/8SAJ-RuLDTBvrvxfmwB-7ehrPcGJbrwWl4XvmhcqtrbuHPq09JkC9vmqBxO5Fbau7PKYlg-NnozZVlfd0G0DRovy.jpg?quality=95&amp;as=32x21,48x32,72x47,108x71,160x105,240x158,360x237,480x316,540x355,640x421,698x459&amp;from=bu&amp;cs=698x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"API: что это?","data":{"code":"-","description":"<b>API (Application Programming Interface)</b> - это интерфейс взаимодействия между программами. Включает в себя набор правил, протоколов которые позволяют программам обмениваться данными и взаимодействовать друг с другом. \n\n<b>Например:</b>\nПример из жизни. Приходит клиент в кафе, и официанту говорит \"принесите мне раф\". Официант принимает запрос и отдаёт его на кухню где готовят кофе. А потом приносит тебе его. \nОфициант в нашем случае - API\n\nКак это работает (простыми словами)\n- У клиента (например, фронтенд-приложения, мобильного приложения или теста) есть запрос: “дай мне данные” или “создай ресурс”.\n- Клиент формирует API-запрос (HTTP, если это веб-API), отправляет его на “эндпоинт” (URL).\n- Сервер, который “владеет” API, принимает запрос, обрабатывает его, может обратиться к базе данных или другой логике.\n- Сервер отправляет ответ клиенту (обычно в формате JSON или XML). \n- Клиент получает эти данные и делает что-то с ними - отображает, анализирует, сохраняет и т.д.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/WE2ZBYjNnEACxbD5Atu1S93n6ZoLE3KAP2ngcAhrDqNTmt26SK2IivwkV91DOrVFswEEuBe__FuZ_K49T_1l2trt.jpg?quality=95&amp;as=32x12,48x19,72x28,108x42,160x62,240x93,360x139,480x185,540x209,640x247,720x278,800x309&amp;from=bu&amp;cs=800x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"API: авторизация OAuth2, Bearer Tokens, JWT","data":{"code":"-","description":"В современной разработке при взаимодействии клиента (браузера/мобильного приложения) с API и другими микросервисами используется многоуровневая система защиты и идентификации. Она необходима для того, чтобы:\n- Защитить данные пользователя: не передавать логин и пароль при каждом запросе.\n- Разграничить доступ: четко понимать, к каким именно ресурсам разрешен доступ (например, только чтение профиля).\n- Масштабировать систему: позволять разным сервисам доверять друг другу без постоянных запросов к центральной базе данных.\n\nДля реализации этой системы используются три компонента:\n\n<hr>\n<h5>1. OAuth 2.0</h5>\nOAuth 2.0 - это \"Сценарий доверия\" (Протокол). Это набор правил и шагов, по которым одно приложение получает разрешение действовать от имени пользователя. Так же это протокол авторизации, а не аутентификации.\nОн отвечает на вопрос: \"Можно ли этому клиенту делать это действие?\" (Не путать с логином)\n\n<b>Для чего именно:</b> Он определяет, как пользователь подтверждает свою личность и как выдается разрешение (тот самый \"процесс получения ключа\"). Вместо того чтобы отдавать приложению свой пароль, пользователь проходит через OAuth-сценарий и дает приложению временный доступ.\n\n<b>Роли в OAuth 2.0:</b> В протоколе всегда участвуют четыре стороны:\n - Resource Owner (Пользователь) - тот, кто дает разрешение.\n- Client (Приложение) - то, которое просит доступ.\n- Authorization Server (Сервер Авторизации) - тот, кто проверяет пользователя и выдает токен.\n- Resource Server (API) - тот, кто отдает данные, проверив токен.\n\n<b>Пример:</b>\n- вход через Google / GitHub / Yandex или логин+пароль\n- доступ приложения к API от имени пользователя\n- Приложению разрешено читать профиль, но не менять пароль (scope доступ).\n\n<hr>\n<h5>3. Bearer Token</h5>\nBearer Token - это \"Способ предъявления\" (Схема) Это технический стандарт передачи ключа в сетевом запросе. \"Bearer\" = \"предъявитель\" кто предъявил - тот и имеет право. Передаётся так: Authorization: Bearer &lt; token &gt;\n\n<b>Для чего именно:</b> Он говорит серверу: \"Любой, кто предъявит (bears) этот токен в заголовке Authorization, получает доступ к ресурсам\". Это как ключ от номера в отеле: администратору не важно, кто именно вставляет карту в замок, важно, что карта действительна.\n- серверу не нужен пароль\n- серверу не нужен session id\n- токен можно проверить без состояния (stateless)\n- Если украли токен - украли доступ.\n\n<hr>\n<h5>3. JWT (JSON Web Token)</h5>\nJWT (JSON Web Token) - это \"Умный пропуск\" (Формат) Это способ упаковки информации о пользователе в одну строку. Чаще всего используемый как Bearer Token (в headers запросов Bearer &lt; token JWT &gt; в base64)\n<b>Для чего именно:</b> JWT - это самодостаточный контейнер. В нем сразу написано, кто такой пользователь, какая у него роль и когда пропуск сгорит. Серверу API не нужно переспрашивать у сервера авторизации \"Кто это?\", он видит это прямо внутри JWT и доверяет ему, проверив цифровую подпись.\n- не надо хранить сессии\n- сервер проверяет подпись\n- данные можно читать без БД\n- JWT не шифруется по умолчанию, а подписывается\n\n<b>Пример:</b>\n- { \"sub\": \"123\", \"role\": \"user\",  \"exp\": 1712345678 }\n\n<hr>\n<h5>Общая схема (простыми словами)</h5>\n1. Пользователь проходит аутентификацию \n   (логин/пароль или через OAuth 2.0 провайдера).\n\n2. Сервер авторизации выдаёт клиенту access token \n   (чаще всего в формате JWT).\n\n3. Клиент хранит access token.\n\n4. Клиент передаёт access token в каждом запросе:\n   Authorization: Bearer &lt; access_token &gt;\n\n5. Сервер:\n   - проверяет подпись и срок действия токена\n   - проверяет роли / scopes\n   - принимает решение о доступе:\n     • разрешить\n     • отказать\n<img src=\"https://sun9-28.userapi.com/s/v1/ig2/nTJNF-X70syCwFbzlXD2m0SUEEaRR5J-SE_ZjejBQLQbbMn25L2MEz2c8t0uBk4MEZxLQlXhP7cq7wiOb748ESoc.jpg?quality=95&amp;as=32x15,48x22,72x34,108x51,160x75,240x112,360x168,480x225,540x253,640x299,720x337,1080x505,1280x599,1440x674,1860x870&amp;from=bu&amp;cs=1860x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<hr>\n<h5>Что должен уметь QA на практике</h5>\n<b>OAuth 2.0:</b>\n- Редиректы: правильно ли перебрасывает на страницу логина и обратно.\n- Scope (права): если приложение просит доступ только к почте, не дает ли оно доступ к контактам.\n- Обработку ошибок: что будет, если пользователь нажмет \"Отмена\" на этапе авторизации.\n- и т.д. всё что связано с этапом авторизации\n\n<b>Bearer:</b>\n- Правильность заголовка: сервер должен принимать токен именно в ключе Authorization.\n- Безопасность: передается ли токен только через HTTPS (потому что любой, кто перехватит Bearer токен, сможет им воспользоваться).\n- Пустые и некорректные bearer\n- и т.д. всё что связано с передачей и хранением token\n\n<b>JWT:</b>\n- Expiration Date (exp): Что происходит, когда срок действия токена истекает (должна быть ошибка 401).\n- Payload: Нет ли в токене лишней чувствительной информации (паролей, номеров карт), так как Payload легко расшифровать.\n- Signature: Если изменить в токене хотя бы одну букву, сервер должен его отклонить.\n- и т.д. всё что связано с форматом данных JWT\n\n","path":"-"}},{"title":"JSON: Что это? Как читать / Составить","data":{"code":"-","description":"Для QA-инженера умение читать и составлять JSON - это базовый навык \"выживания\", так как 99% современных API обмениваются данными именно в этом формате.\n\n<b>JSON (JavaScript Object Notation)</b> - это текстовый формат обмена данными. Несмотря на название, он не зависит от языка программирования. Его легко читать человеку и легко парсить (разбирать) компьютеру.\n<b>Ключевое:</b>\n- не язык программирования\n- не формат БД\n- не тип данных\n- формат обмена\n\n<b>Используется:</b>\n- в REST API\n- в логах\n- в конфигурациях\n- в ответах/запросах клиента &lt; &gt; сервер\n\n<hr>\n<h5>Структура JSON</h5>\n<b>В JSON всего два типа структур:</b>\n<b>- Объект</b> - заключен в фигурные скобки { }. Это набор пар \"ключ\": \"значение\" или \"ключ\": [ массив ]. Пара \"ключ\" : \"значение\" - является свойством. \n<b>- Массив</b> - заключен в квадратные скобки [ ]. Это упорядоченный список значений.\n\n<b>Правила:</b>\n- ключи только строки\n- ключи в кавычках\n- : между ключом и значением\n- , между парами свойств (разделитель)\n- ключи в объекте должны быть уникальны\n- порядок ключей не гарантирован (логически)\n- Объект - это не массив, доступа по индексу нет\n\n<img src=\"https://sun9-21.userapi.com/s/v1/ig2/mDdI2MsKaRvmaBhfAbwd2a09Lx4bInACrWmHm0jGTDAztbSyBeuvV04DEa5nK8SntRea2K9TyVWz3FP3b00j-IrW.jpg?quality=95&amp;as=32x29,48x44,72x66,108x98,160x146,240x219,360x328,480x438,500x456&amp;from=bu&amp;cs=500x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-49.userapi.com/s/v1/ig2/vrAoRAj3kiMH3tQLjbQdYiZWWsVQK7iDJg7xF7CY6Zd3l3ioqmYgF7d9wOim-Yo3WXFSu0GpyafKwvMOCqhPI3dC.jpg?quality=95&amp;as=32x23,48x34,72x51,108x76,160x113,240x170,360x255,480x340,500x354&amp;from=bu&amp;cs=500x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-28.userapi.com/s/v1/ig2/8V89zffqHZx-IbSmtdsvTDU0B68HXS4Fzdad9L1Bd3Qct2Xr56c791GUlM1o3bRzg0DCd4uJdpyqB2kS83uv25zZ.jpg?quality=95&amp;as=32x23,48x35,72x53,108x79,160x117,240x176,360x264,480x351,500x366&amp;from=bu&amp;cs=500x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-60.userapi.com/s/v1/ig2/qjwLcIsYNbNWi2pa3G69_CaPJWf_inyEfbgFLKv-oX2QMgEQ-78Q06Uiw6vw0ih5c21K1dBVDXdaHpKS9CjO9tWf.jpg?quality=95&amp;as=32x27,48x40,72x60,108x90,160x133,240x200,360x300,480x399,500x416&amp;from=bu&amp;cs=500x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-80.userapi.com/s/v1/ig2/NaAb13F5dGMQsNy6ML6NV8lI9uaoJZ7TEuR9dv8oiOpj-xXv8lNC-5yGBjJyK6GRdgswptCjandXnomHLLmC3L2m.jpg?quality=95&amp;as=32x23,48x34,72x51,108x76,160x113,240x170,360x255,480x340,500x354&amp;from=bu&amp;cs=500x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Типы данных внутри JSON объекта:</b>\n- Строка: \"Текст\" (всегда в двойных кавычках).\n- Число: 123, 45.6 (без кавычек).\n- Логическое значение: true или false (без кавычек, маленькими буквами).\n- Null: null (пустое значение).\n- Объект или Массив: могут быть вложены друг в друга.\nНет:\n- undefined\n- NaN\n- функций\n- комментариев\n\n<hr>\n<h5>Как читать JSON</h5>\n<b>Сверху вниз, слева направо:</b> Ищи нужный ключ. Если значение в { }, значит, у этого параметра есть свои свойства.\nНе “глазами”, а структурно.\n<b>1. Определить корень:</b>\n- { } &gt; найти объект\n- [ ] &gt; найти массивы\n\n<b>2. Разложи структуру, а не значения:</b>\n- обязательные?\n- опциональные?\n- могут ли быть пустыми (null) ?\n\n<b>3. Проверяем каждое значение:</b>\n- Какой тип? (число, текст, логическое, массив)\n- Допустимый диапазон или формат?\n- Есть ли вложенные объекты или списки?\n\n<b>Использовать \"Красители\" (Prettify):</b> В сыром виде JSON может прийти одной строкой: {\"id\":1,\"firstName\":\"Ivan\"}. Чтобы его прочитать, в Postman или DevTools есть кнопка форматирования \"Pretty\". Так же есть онлайн сервисы json форматтеров, вставив туда JSON можно получить подсвеченный и разбитый на строки JSON.\n<b>JSON Path:</b> Если JSON очень большой (на 1000+ строк), для поиска конкретного поля используются выражения JSON Path (аналог поиска в папках).\nПример: $.profile.firstName вернет \"Иван\"\n\n<hr>\n<h5>Для QA нужно:</h5>\n- читать вложенные структуры\n<b>находить:</b>\n- отсутствующие поля\n- лишние поля\n- неверные типы\n<b>проверять:</b>\n- null / empty\n- границы чисел\n- формат строк\n- валидировать по схеме (Swagger / OpenAPI)\n\n<hr>\n<h5>Пример:</h5>\nТакже внутри JSON объекта могут быть вложенные объекты, внутри которых так же могут быть объекты. И внутри всех объектов есть \"ключи : значения\" и так же [ ] массивы. В реальных проектах поток данных внутри JSON достаточно велик. \n\n<img src=\"https://sun9-52.userapi.com/s/v1/ig2/dOKqAY82jvg8bbTuuYGDyQOEywa3heYaT-p7ykJ16Esds7_HeSmS07wYp5Uu2tnTBvePfVq6rmcE_goc6gHcU2-x.jpg?quality=95&amp;as=32x23,48x34,72x51,108x76,160x113,240x169,360x254,480x339,540x381,640x452,720x508,1024x723&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nРассмотрим строку подробно:\nСуществует объект обозначенный фигурными скобками <b>{ }</b>.\nВ объекте есть несколько пар имя/значение:\n<b>- \"orderID\": 12345</b> - Свойство с ключом \"orderId\" и целочисленным значением 12345\n<b>- \"shopperName\": \"Ваня Иванов\"</b> - Свойство с ключом \"shopperName\" и строковым значением \"Ваня Иванов\".\n<b>- \"shopperEmail\": \"johnsmith@example.com\"</b> - Свойство с ключом \"shopperEmail\" и строковым значением\"ivanov@example.com\"\n<b>- \"contents\": [ ... ]</b> - Свойство с ключом \"contents\", значение которого является массивом\n<b>- \"orderCompleted\": true</b> - Свойство с ключом \"orderCompleted\" и логическим значением true\n<b>- В массиве \"contents\"</b> есть 2 объекта, представляющие отдельные позиции в заказе. Каждый объект содержит 3 свойства: productID, productName, и quantity.","path":"-"}},{"title":"XML: Что это? Как читать / Составить","data":{"code":"-","description":"<span style=\"color:red\">Дисклеймер: в разделе про xml при составлении xml'a пришлось между стрелочками &lt; &gt; поставить пробелы, чтоб интерпретатор html не пытался включить эти данные как html документ.</span>\n\n<b>XML (eXtensible Markup Language - расширяемый язык разметки)</b> -  это универсальный текстовый формат для структурирования, хранения и передачи данных, который описывает их логическую структуру с помощью самоопределяемых тегов, делая данные понятными как для человека, так и для машины, что используется для обмена информацией между разными системами, например, в API и веб-сервисах,. Он похож на HTML (где теги предопределены), но в XML вы создаете свои собственные теги (например, &lt; книга &gt;, &lt; автор &gt;), чтобы описать данные. \n\n<b>XML</b> - используется в SOAP (всегда) и REST-запросах (реже).\n\n<b>Основные характеристики:</b>\n<b>- Расширяемый:</b> Вы сами определяете теги, которые описывают ваши данные.\n<b>- Структурированный:</b> Данные упорядочены иерархически (как вложенные теги), что облегчает их обработку программами.\n<b>- Универсальный:</b> Используется для обмена данными между разными приложениями, платформами и языками.\n<b>- Читаемый:</b> Легко читается и редактируется в любом текстовом редакторе, так как это текстовый формат. \n\n<hr>\n<h5>Структура XML</h5>\n<b>Файл расширяемого языка разметки (XML)</b> – это текстовый документ, который можно сохранить с расширением.xml. Можно писать XML аналогично другим текстовым файлам. Для создания или редактирования XML-файла можно использовать любое из указанных ниже действий. \nТекстовые редакторы, такие как:\n- Блокнот или Блокнот+\n- Онлайн редакторы XML\n- Веб-браузеры\n- Любой XML-файл включает указанные ниже компоненты.\n\n<b>1. Открывающийся и закрывающийся тег:</b> В XML используются открывающиеся и закрывающиеся теги для обозначения начала и конца элемента. Открывающийся тег записывается в угловых скобках и содержит имя элемента, например &lt; name &gt;. Он обозначает начало элемента и может содержать атрибуты. Закрывающийся тег также записывается в угловых скобках, но с косой чертой перед именем, например &lt; /name &gt;, и обозначает конец элемента. Имена открывающегося и закрывающегося тегов должны совпадать полностью, включая регистр, так как XML чувствителен к регистру символов.\n\n<img src=\"https://sun9-11.userapi.com/s/v1/ig2/IVXE_VALTkhOm3ZvlmHqG83j6Y0YlyRhao4vp_9RCwY9xCyq1amNOHAn-4HGcpY1bvXWzsyMUxugbq8oY45S2f_R.jpg?quality=95&amp;as=32x19,48x28,72x42,108x63,160x93,240x139,360x209,480x279,540x313,560x325&amp;from=bu&amp;cs=560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>2. Вложенность элементов:</b> Полная запись элемента состоит из открывающегося тега, содержимого и закрывающегося тега. Между тегами может находиться текстовое значение или другие вложенные элементы. Если тег открыт, он обязан быть закрыт, пропуск закрывающегося тега делает XML невалидным. Также запрещено перекрёстное закрытие тегов - элементы должны закрываться строго в обратном порядке их открытия, образуя корректную иерархию.\nЕсли элемент не содержит никакого значения и не имеет вложенных элементов, допускается использование самозакрывающегося тега. Такой тег открывается и закрывается в одной записи и по смыслу эквивалентен пустой паре тегов. Самозакрывающийся тег не является сокращением или вольностью синтаксиса, это полноценная форма записи пустого элемента. Выбор между парным и самозакрывающимся тегом зависит от семантики: если элемент хранит данные, используется парная форма, если элемент служит маркером, флагом или просто указывает на факт наличия - допустима самозакрывающаяся форма.\n\n<img src=\"https://sun9-62.userapi.com/s/v1/ig2/Bz5WHbH7fNWI6vku_36daFo0fNF14fVPmsJocmGci4WL8ECGG4QEcW9a0V5wnnA31VwTF_nFBBN3HLGLiS3N9BXL.jpg?quality=95&amp;as=32x21,48x32,72x48,108x72,160x107,240x160,360x241,480x321,540x361,600x401&amp;from=bu&amp;cs=600x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-74.userapi.com/s/v1/ig2/wIoY87nuiuKkBmPgVE04KRmKyLK38DSvQS-oEPEIcuDb9jiHbTLZ3w0ffUF5XI5mm_ggeKHsTFGCxGFAp1WLlUMR.jpg?quality=95&amp;as=32x20,48x30,72x46,108x69,160x102,240x152,360x229,480x305,540x343,600x381&amp;from=bu&amp;cs=600x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-38.userapi.com/s/v1/ig2/0S0NJv_DMBKtU0STl4VBb2eG0KXk9l0xQG5NbB0pC2OxPUeELhkkmRebXx9q0vIVmPAlDmNnKU1L2Ko2n1UWe-ex.jpg?quality=95&amp;as=32x19,48x28,72x42,108x63,160x94,240x140,360x211,480x281&amp;from=bu&amp;cs=480x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>4. Декларация XML:</b> XML-документ начинается с информации о самом XML. Например, в нем может быть указана следующая версия XML. Это открытие называется объявлением XML. Вот пример: \n&lt; ?xml version=\"1.0\" encoding=\"UTF-8\"? &gt;\n<b>- version 1.0</b> - версия xml \n<b>- encoding=\"UTF-8\"</b> - кодировка символов в UTF-8\n\n<b>5. Корневой элемент:</b> Теги &lt; xml &gt;&lt; /xml &gt; используются для обозначения начала и конца XML-файла (корневой элемент). Содержимое этих тегов (внутри корневого элемента) также называется XML-документом. Это первый тег, который будет искать любое программное обеспечение для обработки XML-кода. Так же корневой элемент можно называть по разному, будь то &lt; book &gt; &lt; /book &gt; или &lt; user &gt; &lt; /user&gt; и т.д.\n<b>Жёсткое правило:</b> В XML ВСЕГДА должен быть один корневой элемент.\n\n<img src=\"https://sun9-15.userapi.com/s/v1/ig2/uC27qt268SC1XLE5PFrBhDcowY8rcyHRI9vysUZnPJCy6C4PLrhKPkBpKHNVxaGtfg7HIjuJZQ_pubpyxjK5URxE.jpg?quality=95&amp;as=32x30,48x44,72x67,108x100,160x148,240x222,360x333,480x444,540x499,560x518&amp;from=bu&amp;cs=560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-5.userapi.com/s/v1/ig2/sgGs_S_oeKse7RCDzE70j3w7RYHmKVMOXlm30pEGXbnkYTovoWa6_eHUj1TBBUczTYdqyelBdk9SlL2bf-Tfk0H4.jpg?quality=95&amp;as=32x17,48x25,72x37,108x56,160x83,240x125,360x187,480x250,540x281,600x312&amp;from=bu&amp;cs=600x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>6. Элементы и их значения:</b> Все остальные теги, создаваемые в XML-документе, называются элементами XML. Значение элемента хранится между открывающим и закрывающим тегами (по всем правилам которые описаны выше). Это может быть число, строка, или даже вложенные теги.\n\n<img src=\"https://sun9-88.userapi.com/s/v1/ig2/3iKYBWGJ9MOBekefgqxokaqdOa2hls5Wi9Wn_2D15l0vcWMmytCboBhbYBNSWdHKpQA-RVekNAGOjocLgG9-zsJT.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x101,240x151,360x227,480x302,540x340,640x403,700x441&amp;from=bu&amp;cs=700x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Пример:</b> рассмотрим приведенный ниже XML-файл:\n&lt; ?xml version=\"1.0\" encoding=\"UTF-8\"? &gt;\n&lt; invitationlist &gt;\n&lt; family &gt;\n       &lt; aunt &gt;\n       &lt; name &gt;Кристин&lt; /name &gt;\n        &lt; name &gt;Стефани&lt; /name &gt;\n       &lt; /aunt &gt;\n&lt; /family &gt;\n&lt; /invitationlist &gt;\n<b>&lt; InvitationList &gt;</b> - является корневым элементом\n<b>семья (family) и тетя (aunt )</b> - другие имена элементов\n<b>Кристин и Стефани</b> - значения элементов\n\n<b>7. Атрибуты элемента:</b> У элемента могут быть атрибуты - один или несколько. Их мы указываем внутри отрывающегося тега после названия тега через пробел в виде: название_атрибута = \"значение атрибута\"\n\n<b>Зачем это нужно?</b> Из атрибутов принимающая API-запрос система понимает, что такое ей вообще пришло.\n\n<b>Пример:</b> мы делаем поиск по системе, ищем клиентов с именем Олег. Отправляем простой запрос: &lt; query &gt;Олег&lt; /query &gt;\nА в ответ получаем целую пачку Олегов! С разными датами рождения, номерами телефонов и другими данными. Допустим, что один из результатов поиска выглядит так:\n&lt; party type=\"PHYSICAL\" sourceSystem=\"AL\" rawId=\"2\" &gt;\n    &lt; field name=“name\" &gt;Олег &lt; /field &gt;\n    &lt; field name=\"birthdate\" &gt;02.01.1980&lt; /field &gt;\n    &lt; attribute type=\"PHONE\" rawId=\"AL.2.PH.1\" &gt;\n        &lt; field name=\"type\" &gt;MOBILE&lt; /field &gt;\n        &lt; field name=\"number\" &gt;+7 916 1234567&lt; /field &gt;\n    &lt; /attribute&gt;\n&lt; /party&gt;\n\n<b>party</b> - У него есть 3 атрибута:\n<b>- type  = \"PHYSICAL\" </b> - тип возвращаемых данных. Нужен, если система умеет работать с разными типами: ФЛ, ЮЛ, ИП. Тогда благодаря этому атрибуту мы понимаем, с чем именно имеем дело и какие поля у нас будут внутри. А они будут отличаться! У физика это может быть ФИО, дата рождения ИНН, а у юр лица - название компании, ОГРН и КПП\n<b>- sourceSystem = \"AL\" </b> - исходная система. Возможно, нас интересуют только физ лица из одной системы, будем делать отсев по этому атрибуту.\n<b>- rawId = \"2\"</b> - идентификатор в исходной системе. Он нужен, если мы шлем запрос на обновление клиента, а не на поиск. Как понять, кого обновлять? По связке sourceSystem + rawId!\n\n<img src=\"https://sun9-59.userapi.com/s/v1/ig2/6jZybux-4H8OVr2gFukOr-mbXX1YEcXB-Di8kCHRADwav8oIEf7P3Jbc-alteCubx4vePJ0JIgzQOkU1o9oyPK_h.jpg?quality=95&amp;as=32x21,48x32,72x48,108x73,160x108,240x161,360x242,480x323,540x363,640x430,720x484,750x504&amp;from=bu&amp;cs=750x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>field</b> - Внутри party есть элементы field\nУ элементов field есть атрибут <b>name</b>. Значение атрибута - название поля: имя, дата рождения, тип или номер телефона. Так мы понимаем, что скрывается под конкретным field.\nЭто удобно с точки зрения поддержки, когда у вас коробочный продукт и 10+ заказчиков. У каждого заказчика будет свой набор полей: у кого-то в системе есть ИНН, у кого-то нету, одному важна дата рождения, другому нет, и т.д.\n\n<img src=\"https://sun16-1.userapi.com/s/v1/ig2/00cGAW5sHldxM64JsnUulfwgnkm-IE89kKB-IcLw7mnvjyiIz8mEoLr2-fP06le6sUAn8i5SoE-1ml6JEd8oRR-C.jpg?quality=95&amp;as=32x16,48x24,72x36,108x53,160x79,240x119,360x178,480x237,540x267,640x317,720x356,750x371&amp;from=bu&amp;cs=750x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-32.userapi.com/s/v1/ig2/5XY4Z-YJHir7Bu5XQAflVA7W_m8DljUD03S2VMVkYPReTpTiskk2vbqb38OjIXT3A68TifpA9bswX0lsmF4NUeWR.jpg?quality=95&amp;as=32x16,48x24,72x36,108x53,160x79,240x119,360x178,480x237,540x267,640x317,720x356,750x371&amp;from=bu&amp;cs=750x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>attribute</b> Помимо элементов field в party есть элемент attribute.\nс точки зрения xml - это элемент (не атрибут!), просто его назвали attribute. XML все равно (почти), как вы будете называть элементы, так что это допустимо.\n\n<img src=\"https://sun9-88.userapi.com/s/v1/ig2/QVF6dO4CXTuv74AHN8yOVPftxMK9Yu0TUMDoRm7AsKJfMocrbKHMqDCSgZDnSRWlIOQPxqr7VMLsccPEswVCQ0rS.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x101,240x152,360x228,480x303,540x341,640x404,720x455,750x474&amp;from=bu&amp;cs=750x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>- type = \"PHONE\"</b> - тип атрибута. Они ведь разные могут быть: телефон, адрес, емейл...\n<b>- rawId = \"AL.2.PH.1\" </b>- идентификатор в исходной системе. Он нужен для обновления. Ведь у одного клиента может быть несколько телефонов, как без ID понять, какой именно обновляется?\n\n<img src=\"https://sun9-38.userapi.com/s/v1/ig2/rucCHL1Hoj4ZZTJR_cq7fIk_mW2IFX5Uas1bc4HjAh23EgW9ra2FW-8JZrsBjd3TeaB2lXBnY3RvJ_bIe4dLa18D.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x80,240x120,360x180,480x240,540x270,640x320,720x360,750x375&amp;from=bu&amp;cs=750x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n\n<img src=\"https://sun9-15.userapi.com/s/v1/ig2/1fgopYMxjuAj0Px-4QUc_kunNlsQj1MfAwknqMK1uVRKwnsUcGt2x_LAKW4_D1jc-G2EFFaDHPNnUJl5tED_mP-x.jpg?quality=95&amp;as=32x28,48x42,72x63,108x95,160x141,240x211,360x317,480x422,540x475,640x563,700x616&amp;from=bu&amp;cs=700x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nЕсли вы тестировщик, то при тестировании запросов в формате XML обязательно попробуйте нарушить каждое правило! Да, система должна уметь обрабатывать такие ошибки и возвращать адекватное сообщение об ошибке. Но далеко не всегда она это делает.\n\n<hr>\n<h5>Для чего нужен QA</h5>\nXML нужен QA не \"потому что он существует\", а потому что он до сих пор является контрактом в критичных системах. Если ты его не понимаешь -  ты тестируешь вслепую.\nВ реальных проектах XML чаще всего используется как формат обмена данными между системами, а не как хранилище. Это банки, страхование, гос-сервисы, телеком, медицина - там, где старые интеграции живут десятилетиями и переписывать их дорого и опасно. QA в таких системах проверяет не UI, а корректность контракта, и этот контракт часто описан именно XML.\n\nДля QA XML - это, в первую очередь, способ проверить, что система говорит именно то, что обещала. Ты смотришь не на «красиво / некрасиво», а на структуру ответа: пришёл ли обязательный элемент, допустима ли вложенность, корректен ли порядок элементов, что происходит при отсутствии тега, чем отличается пустой тег от отсутствующего. Это типичные точки отказа интеграций.\n\nВторая причина -  строгость формата. XML не прощает ошибок. Неправильно закрытый тег, нарушенная вложенность, спецсимвол без экранирования — и потребитель данных падает. Для QA это подарок: такие дефекты легко воспроизводимы и критичны. Если система иногда отдаёт невалидный XML — это баг уровня интеграции, а не «косметика».\n\nТретья причина - схемы (XSD - XML Schema Definition, схема описания XML). В нормальных системах XML почти всегда валидируется по схеме. QA должен уметь читать схему и понимать, какие элементы обязательны, какие опциональны, сколько раз они могут повторяться и какие значения допустимы. Без этого ты не тестируешь требования, ты просто смотришь на ответы.\n\nЧетвёртая причина - SOAP (Simple Object Access Protocol — протокол обмена сообщениями). Да, он старый, да, его не любят, но он жив. SOAP целиком построен на XML, и там важны не только данные, но и обёртки, неймспейсы, заголовки, ошибки. QA, который не понимает XML, в SOAP-проектах бесполезен примерно полностью.\n\nПятая причина - логирование и конфигурации. XML часто используется в логах, настройках, интеграционных файлах, тестовых фикстурах. QA сталкивается с ним при анализе причин дефектов, а не потому что \"так захотелось\".\n\n<img src=\"https://sun9-48.userapi.com/s/v1/ig2/vdti4rmOQCqEh0el-ErEm6Wc1xz3ZsBKmlS7ugvfp2QJmhVGK3lQTmsPZZe_fJUDVadXety6Ve2suJ96ElOkVqot.jpg?quality=95&amp;as=32x27,48x40,72x60,108x90,160x134,240x200,360x301,480x401,540x451,600x501&amp;from=bu&amp;cs=600x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-9.userapi.com/s/v1/ig2/qeEF579Cd8zkG8q5CuGJyFCuwV_fWvOz_OZeovEzEZEq2i22JO2FxjGzPoBL_KLafXLmfT90UACr3QKNfV-L2Ivm.jpg?quality=95&amp;as=32x29,48x43,72x65,108x98,160x144,240x217,360x325,480x434,540x488,630x569&amp;from=bu&amp;cs=630x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-45.userapi.com/s/v1/ig2/ZDku3ymDPk2HItQBLJZGyJZOxTxIkhDbHNOlt9VFn18fHj25jFXqOxYnGNa_uZ151_OcCLvFEE1ccKEAyxz3kd1x.jpg?quality=95&amp;as=32x25,48x38,72x57,108x86,160x127,240x190,360x285,404x320&amp;from=bu&amp;cs=404x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-49.userapi.com/s/v1/ig2/zB63TiH66e-61gfzaAnfe8B5ZbCFdJ6CHVBh1lQ5lZfi7-tABOrXX4mOJuwOzbX6ogS_k65QjiUskT45XEIN1EVe.jpg?quality=95&amp;as=32x19,48x29,72x43,108x64,160x95,240x143,360x214,480x285,540x321,640x381,681x405&amp;from=bu&amp;cs=681x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n","path":"-"}},{"title":"REST","data":{"code":"-","description":"<b>REST</b> - это архитектурный стиль и набор рекомендаций. Легкий, гибкий и быстрый способ общения между программами через HTTP, те же запросы GET, POST, PUT, DELETE, PATCH. Чаще всего обработка информации происходит в JSON формате.\n\n<h4>Основные идеи REST: </h4>\n<b>1) Ресурсы</b> - API работает с ресурсами: пользователи, товары, заказы и т. д.\nКаждый ресурс доступен по своему URL: \n/users\n/users/10\n/products/55\n<b>2) Методы HTTP соответствуют действиям</b>\nGET\t- получить данные\t\nPOST - создать новый ресурс\nPUT - заменить ресурс полностью\nPATCH - изменить частично\nDELETE - удалить\n<b>3) Нет состояния (stateless)</b>\nСервер не хранит контекст между запросами.\nКаждый запрос должен содержать всю нужную информацию (токен, параметры).\n<b>4) Единый формат данных</b>\nОбычно JSON:  { \"id\": 1, \"name\": \"Rasul\"}\n<b>5) Правильные коды ответов:</b>\n200 OK - всё нормально\n201 Created - ресурс создан\n400 Bad Request - ошибка клиента\n401 Unauthorized - нужно авторизоваться\n404 Not Found - ресурса нет\n500 Internal Server Error - ошибка на сервере\n\n<b>Например: </b>\nПолучить пользователя GET: /users/1\nСоздать пользователя POST: /users  body: {\"name\": \"Rasul\"}\nОбновить пользователя PUT: /users/1\nУдалить DELETE: /users/1\n\n<b>P.S:</b>\nREST легко тестируется через Postman/DevTools\nчерез REST быстрее ловятся баги, чем через UI\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/xzz6sz79K3RKjfsCZczGjBcN7JOfeEYacwNzYxoF-dPKHjuZkp8oUIIN3m5xq5ZEoljuZ-fXXdDcHMpPKbzr142W.jpg?quality=95&amp;as=32x14,48x21,72x32,108x48,160x71,240x106,360x159,480x212,540x238,640x283,720x318,1080x477,1280x565,1440x636,1560x689&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"SOAP","data":{"code":"-","description":"<b>SOAP (Simple Object Access Protocol)</b> - это протокол по которому вэб-сервисы взаимодействуют друг с другом. Взаимодействие происходит в XML формате. Это более сложный и строгий протокол, обеспечивающий надёжность и безопасность но требующий больше ресурсов.\n\n<h4>Основные особенности SOAP:</h4>\n<b>1) Передаёт данные строго в XML</b>\n<b>2) Жёсткий контракт</b> - WSDL\nСервис публикует WSDL - документ, который полностью описывает:\n- какие методы есть,\n- какие параметры принимают,\n- какие типы данных,\n- какие возможны ошибки,\n- как правильно вызывать.\nНевозможно вызвать SOAP-метод \"как хочешь\" - нужно строго следовать контракту.\n<b>3) Работает по разным протоколам</b>\nВ отличие от REST, который живёт в HTTP, SOAP может:\n- HTTP/HTTPS (чаще всего)\n- SMTP\n- JMS\n- TCP\n\n<b>Где SOAP лучше всего использовать: </b>в местах, где всё должно быть формально, безопасно и предсказуемо. Например в банкинге, госуслугах, корп сетях, медицине, страховании, бухгалтерских программах.\n\n<b>Пример SOAP-запроса:</b>\n&lt; soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" &gt;\n  &lt; soap:Header/ &gt;\n  &lt; soap:Body &gt;\n    &lt; GetBalance xmlns=\"http://example.com/bank\" &gt;\n      &lt; AccountID &gt;123&lt; /AccountID &gt;\n    &lt; /GetBalance &gt;\n  &lt; /soap:Body &gt;\n&lt; /soap:Envelope &gt;\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-43.vkuserphoto.ru/s/v1/ig2/rDfYzpmLztZ0wt1nnm-VlKbNzqzAU4fo8yEsx4G-LMU67zo96t7uwaL-vjrijoMSsvUeednFZElOd4c5xpc8SUKN.jpg?quality=95&amp;as=32x14,48x21,72x32,108x48,160x70,240x106,360x159,480x211,540x238,640x282,720x317,1080x476,1176x518&amp;from=bu&amp;cs=1176x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Монолит и микросервисы","data":{"code":"-","description":"<b>Монолит</b> - это одна большая программа, где всё связанно. Если нужно что-то изменить, приходится обновлять весь код.\n<b>Плюсы монолита:</b>\n- Простой запуск и разработка. Легче понять архитектуру новичку.\n- Отладка удобная. Один проект &gt; один дебаггер &gt; меньше хаоса.\n- Быстрый деплой. Одним файлом выкатил и пошёл пить чай.\n- Оптимален для малого/среднего продукта.\n<b>Минусы монолита:</b>\n- С ростом превращается в монстра. Любое изменение влияет на всё приложение.\n- Если падает - падает всё.\n- Масштабирование ограничено. Не можешь отдельно масштабировать, например, только загрузку файлов.\n- Зависимость команд друг от друга.\n<hr>\n<b>Микросервисы </b>- это набор небольших независимых сервисов, каждый отвечает за свою задачу. Их можно обновлять и масштабировать отдельно друг от друга. Общаются через API/очереди. \n<b>Плюсы микросервисов:</b>\n- Масштабирование по частям. Если у тебя тяжёлый модуль платежей - увеличиваешь мощности только ему.\n- Независимые деплои. Команды могут выкатывать обновления отдельно.\n- Гибкость технологий. Один сервис на Go, другой на Python - без проблем.\n- Отказоустойчивость. Один сервис падает &gt; остальные живут.\n<b>Минусы микросервисов:</b>\n- Усложнение инфраструктуры. Балансеры, очереди, мониторинг, CI/CD - всё это нужно строить.\n- Оркестрация. Kubernetes, сервис-меши - влетаешь в DevOps.\n- Сетевая задержка. Много запросов между сервисами &gt; выше latency.\n- Отладка сложнее. Ошибка может быть в трёх местах одновременно.\n<hr>\n<b>Главные отличия: </b>Монолит - всё в одном месте, микросервисы - каждая часть отдельно. \n<b>Разработка: </b>в монолите изменения затрагивают всю систему, в микросервисах можно изменять только один компонент.\n<b>Развёртывание: </b>монолит обновляется целиком, микросервисы можно обновлять по частям.\n<b>Масштабирование:</b> в монолите надо увеличивать ресурсы всей системы, в микросервисах только нужные части.\n<b>Стабильность: </b>ошибка в монолите ломает всё, в микросервисах только один компонент.\n<hr>\n<h4>Когда выбирать монолит, когда микросервисы?</h4>\n<b>Монолит, если:</b>\n- проект небольшой или средний;\n- команда &lt; 10 человек;\n- быстрые изменения важнее масштабирования;\n- нет огромной нагрузки.\n\n<b>Микросервисы, если:</b>\n- нагрузка большая и разнотипная;\n- много команд &gt; нужен независимый цикл разработки;\n- нужны разные технологии под разные задачи;\n- есть ресурсы на DevOps-инфраструктуру.\n<hr>\n<b>Пример:</b> \n<b>монолит </b>- смартфон, где аккумулятор не съёмный. Если он сломается, приходится чинить весь смартфон или полностью его поменять. \n<b>микросервисы </b>- это персональный компьютер, и если какая то делать в нём ломается, её можно поменять отдельно - допустим видеокарта. \n\n<b>Пример из разработки:</b>\nМонолит: интернет-магазин, где один сервер обрабатывает всё: товары, корзину, оплату, пользователей.\n\nМикросервисы:\n- сервис товаров\n- сервис оплаты\n- сервис пользователей\n- сервис доставки\nКаждый отдельно масштабируется и обновляется.\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-59.vkuserphoto.ru/s/v1/ig2/ko1rfPjBk2srp6mx6Ka6KDJ4PdzRRNNaEGx6Tar3fpyWA7pZUd0B2MYLowDGu1A8ArwC3MDq0oPMeajtNsfrYb5E.jpg?quality=95&amp;as=32x17,48x25,72x37,108x56,160x83,240x124,360x186,480x248,540x279,640x331,720x372&amp;from=bu&amp;cs=720x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Окружения в тестировании","data":{"code":"-","description":"<b>Окружение </b>- это изолированная копия приложения + инфраструктуры, созданная для выполнения конкретных задач (разработка, тестирование, релиз, эксплуатация).\n\nТо есть это не просто сервер, не просто \"место, где крутится сайт\", а целая связка:\n- код приложения\n- конфигурации\n- база данных (боевые, тестовые или моковые данные)\n- внешние интеграции (или их заглушки)\n- инфраструктура (серверы, балансировщики, очереди, хранилища)\n- настройки и доступы\n\nЕсли проще - окружение = мини-вселенная, в которой система работает как будто бы настоящая, но для разных целей.\n\n<h4>Главные виды окружений в тестировании:</h4>\n<b>1. Local / Dev (локальное окружение разработчика)</b>\nГде живёт: на компе у разработчика или на его внутренней стенде.\n<i>Для чего:</i>\n- разработчик проверяет, что его правки хотя бы запускаются;\n- быстрые проверки без CI/CD.\n<i>Проблема:</i>\n- нестабильное, хаотичное, часто с тестовыми костылями;\n- QA здесь обычно делать нечего.\nПолноценно тестировать на Dev окружении невозможно. Это как пробовать суп прямо из кастрюли, пока повар ещё соль сыпет.\n\n<b>2. Test / QA / SIT (System Integration Testing)</b>\nОсновное окружение для тестировщика.\n<i>Смысл:</i>\n- сюда выкладываются свежие сборки;\n- проверяются новые фичи;\n- проводится интеграционное тестирование (как блоки работают вместе).\n<i>Особенности:</i>\n- нестабильное, но уже ближе к реальности;\n- могут быть заглушки (моки), отключённые платежи и т.п.\n\n<b>3. Stage / Pre-prod / UAT (User Acceptance Testing)</b>\nПочти точная копия продакшена.\n<i>Для чего:</i>\n- проверка перед релизом;\n- регресс, нагрузка, приемочные тесты;\n- купить условный \"товар за 0.01\" можно только тут.\n<i>Главное:</i>\n- стабильность;\n- реальные настройки;\n- часто подключены боевые внешние сервисы, но с тестовыми данными.\n\n<b>4. Prod (продакшн)</b>\nБоевой сервер, реальные пользователи, реальные деньги.\n<i>QA-роль:</i>\n- мониторинг;\n- проверка логов;\n- A/B тесты;\n- работа с метриками.\n<i>Важно:</i>\nНа проде НЕ тестируют, если это не feature-toggle, канареечный релиз или A/B.\n\n<b>5. Sandbox (песочница)</b>\nОкружение специально для экспериментов.\n<i>Используется:</i>\n- для внешних интеграций (банки, платежи, API сторонних сервисов);\n- для безопасного теста запросов без влияния на прод.\n\n<b>6. DR / Backup (Disaster Recovery)</b>\nОкружение, которое проверяет отказоустойчивость.\n<i>Задача:</i>\n- моделирование \"всё упало\"\n- переключение на резервный кластер\n- тестирование отказоустойчивости.\n\n<h5>Упрощённая цепочка окружений:</h5>\n<b>Dev &gt; Test/SIT &gt; Stage/UAT &gt; Prod</b>\n<b>В зависимости от компании могут быть вариации:</b>\n- QA и DEV отдельные стенды\n- несколько тестовых\n- отдельное performance-окружение для нагрузочных тестов\n- environment per branch (редко, но бывает)\n\n<b>Пример:</b>\n<i>Автосервис по ремонту машин:</i>\n- Механик ремонтирует машину в сервисной зоне &gt; это Dev (грязно, шумно, но можно ковыряться).\n- Проверяют, что всё работает после ремонта &gt; Test.\n- Прогоняют финальную проверку перед выдачей &gt; Stage.\n- Машина уходит к клиенту на дорогу &gt; Prod.\nЕсли механик залезет чинить прямо на трассе -  чем это закончится? То же самое в ИТ.\n\n<b>Пример из реальной компании (упрощённо)</b>\n<i>Test (QA):</i>\n- свежие сборки\n- баги, падения, хаос - норма\n- можно ломать\n- данные тестовые\nцель: найти проблемы\n\n<i>Stage:</i>\n- всё максимально похоже на прод\n- стабильность важна\n- реальные интеграции\n- данные очищены/обезличены\nцель: проверить перед выпуском\n\n<i>Prod:</i>\n- реальные пользователи, деньги, статистика\n- любые ошибки = убытки\nцель: работать без сбоев\n\n<img style=\"max-width: 500px; cursor: pointer; max-height: 400px;\" src=\"https://sun9-29.vkuserphoto.ru/s/v1/ig2/sfZ_CQI019BIVXli1AJOryc6OeHAZrf-S3nvOW5U6f9_SrUv4aY09F2vYh728vUM4bXyWySNo88ALouuQy2bsES1.jpg?quality=95&amp;as=32x10,48x15,72x23,108x35,160x51,240x77,360x116,480x154,540x173,640x206,720x231,1080x347,1280x411,1440x463,1849x594&amp;from=bu&amp;cs=1849x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\">","path":"-"}},{"title":"Shift-left / Shift-right Тестирование","data":{"code":"-","description":"Изначально в разработке ПО не существовало отдельной фазы тестирования: программисты сами писали код, проверяли его и выкатывали в продакшен. Со временем стало очевидно, что дефекты, обнаруженные уже после релиза, приводят к серьёзным финансовым и временным потерям.\nВ результате в индустрии закрепилась последовательная модель разработки, где тестирование выделили в отдельный этап:\n<b>требования &gt; проектирование &gt; разработка &gt; тестирование.</b>\nОднако практика показала, что выявление ошибок на поздних стадиях обходится слишком дорого. Это привело к осознанию необходимости начинать работу с качеством как можно раньше в жизненном цикле разработки.\n\n<img src=\"https://sun9-61.userapi.com/s/v1/ig2/u3OC2LEyY5BCupPRTDCrvtbGAZbxsqm5uk5iWXJl8MpRSlpOXy9ZpdFVp37Fu4lzadB4FGvoBHVL5cTo9TAzvyVw.jpg?quality=95&amp;as=32x18,48x26,72x40,108x60,160x88,240x132,360x199,480x265,540x298,640x353&amp;from=bu&amp;cs=640x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nДефекты обходятся дешевле, если их выявить на ранней стадии разработки.\n\n<hr>\n<h5>Shift-left testing</h5>\n<b>Shift-left testing</b> - это подход к обеспечению качества, при котором тестирование и контроль качества смещаются как можно раньше (\"влево\") по жизненному циклу разработки ПО. Идея простая: ловить дефекты до того, как они стали дорогими.\n\nЭто значит:\n- Shift-left не означает что \"QA раньше нажал кнопки\"\n- тестирование начинается на <b>требованиях</b>, а не на готовом билде\n- ошибки ловятся <b>до кода</b> или во время его написания\n- QA участвует <b>до разработки</b>, а не \"после релиза, но срочно\"\n\n<img src=\"https://sun9-84.userapi.com/s/v1/ig2/x0JcWhzMovVCck4ph6lbIxZuYbxIrFdutYQgidgeR4ghtEkgkNvLb6eAN7y4QdOKdB8P-cH5I61tUrzZbfzMVarb.jpg?quality=95&amp;as=32x15,48x22,72x33,108x49,160x73,240x109,360x164,480x218,540x246,640x291,720x328,1080x492,1280x583,1440x655,1560x710&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Если упростить SDLC:</b> Идея &gt; Требования &gt; Дизайн &gt; Разработка &gt; Сборка &gt; Тест &gt; Релиз\n<b>Обычный подход:</b> QA живёт около Тест &gt; Релиз\n<b>Shift-left QA</b> активно работает уже на:\n- Требованиях\n- Дизайне\n- Коде (через автотесты, статический анализ, код ревью)\n\n<span style=\"font-size: 18px\"><b>Что конкретно делают при shift-left</b></span>\n<b>1. На этапе требований</b>\n- Анализ требований на: противоречия, двусмысленности, неполноту, формулирование критериев приёмки\n- Вопросы вида: \"А что если…?\", \"А это обязательное или опциональное?\", \"А при ошибке что пользователь увидит?\"\n- Ловим логические дефекты, а не баги.\n\n<b>2. На этапе дизайна</b>\n- Ревью макетов и архитектуры где проверяется: edge cases (граничные случаи), негативные сценарии, ограничения\n- Подготовка тест-кейсов до кода\n- Предотвращаем дефекты проектирования (самые дорогие).\n\n<b>3. На этапе разработки</b>\n- Unit-тесты\n- Контрактное тестирование\n- Статический анализ\n- Код ревью с фокусом на качество\n- Баг не \"нашли\", а не допустили.\n\n<b>4. Автоматизация как часть разработки</b>\n- Тесты пишутся параллельно коду\n- CI падает раньше, чем баг доедет до тестового стенда\n\n\n<span style=\"font-size: 18px\"><b>Плюсы shift-left testing</b></span>\n<b>1. Дешевле</b>\n- Исправить баг в требованиях = копейки\n- Исправить баг в проде = боль, деньги и репутация\n<b>2. Быстрее</b>\n- Меньше возвратов\n- Меньше \"горящих релизов\"\n<b>3. Качественнее</b>\n- Система логичнее\n- Меньше костылей\n\n\n<span style=\"font-size: 18px\"><b>Когда shift-left особенно нужен</b></span>\n<b>Обязательно:</b>\n- Agile / Scrum / Kanban\n- CI/CD\n- Частые релизы\n- Высокая цена ошибки (банкинг, медицина, финтех)\n\n<b>Очень желательно:</b>\n- Стартапы (денег на переделки нет)\n- сложные бизнес-правила\n- Микросервисы и API\n\n<b>Слабый эффект:</b>\n- Legacy без изменений\n- Проекты \"один раз и забыли\"\n- Команды, где QA зовут за день до релиза (там уже поздно, хоть shift-right, хоть магию)\n\nИ ещё раз простыми словами: <b>Shift-left testing</b> - это подход, при котором обеспечение качества начинается на ранних этапах SDLC (требования, дизайн, код), чтобы предотвращать дефекты, а не находить их в конце.\n\n<hr>\n<h5>Shift-right testing</h5>\n<b>Shift-right testing</b> - это подход, при котором тестирование смещается вправо, то есть после релиза, в реальной или почти реальной среде.\nЕсли shift-left про \"не допустить баг\", то shift-right про \"увидеть, как система ведёт себя в жизни, а не в вакууме\". Такая проверка помогает убедиться в устойчивости работы продукта, его безопасности и производительности даже под непредсказуемыми нагрузками.\n\n<img src=\"https://sun9-22.userapi.com/s/v1/ig2/Tsk-kMD3FiV91RkFlCnrnugsCNfrOitDXMaI6ukP2cc0PctmI6xxdKGnsmdJJmPVWYAyxEHEGlyHWqWYnMdcfGZ3.jpg?quality=95&amp;as=32x15,48x22,72x33,108x49,160x73,240x109,360x164,480x218,540x246,640x291,720x328,1080x492,1280x583,1440x655,1560x710&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Shift-right</b> = валидация продукта на реальных пользователях, данных и нагрузке.\n<b>То, что невозможно:</b>\n- полноценно смоделировать\n- предусмотреть требованиями\n- покрыть тест-кейсами\n\n<b>По SDLC данный тип тестирования находится на этапе релиза: </b>\nИдея &gt; Требования &gt; Дизайн &gt; Код &gt; Тест &gt; Релиз (shift-right) &gt; Эксплуатация\n\n<b>QA-фокус смещается на:</b>\n- прод\n- near-prod\n- реальное поведение пользователей\n\n<span style=\"font-size: 18px\"><b>Что относится к shift-right testing</b></span>\n<b>1. Мониторинг и наблюдение</b>\n- логи\n- метрики\n- трассировки\n- алерты\n-  Баг не \"нашли\", а заметили по симптомам.\n\n<b>2. Тестирование в проде</b>\n- smoke в проде\n- sanity после деплоя\n- проверка ключевых бизнес-флоу\n- Осторожно: не ломаем деньги и пользователей.\n\n<b>3. Feature flags</b>\n- включение фичи для: 1%, конкретного сегмента. внутренних пользователей\n- Контролируем риск.\n\n<b>4. A/B-тесты</b>\n- сравнение поведения пользователей\n- измерение метрик, а не \"кажется работает\"\n- QA &gt; продуктовая аналитика.\n\n<b>5. Chaos testing / fault injection (Хаос тестирование, Внедрение отказов)</b>\n- выключаем сервисы\n- режем сеть\n- ломаем зависимости\n- Проверяем устойчивость, а не happy path.\n\n<b>6. Canary / Blue-Green deployments (канареечное развертывание / сине-зелёное развертывание)</b>\n- новая версия живёт рядом со старой\n- смотрим на ошибки и метрики\n\n<span style=\"font-size: 18px\"><b>Для чего это нужно</b></span>\n<b>1. Реальность сильнее тестового стенда</b>\n- реальные данные\n- реальные интеграции\n- реальные пользователи (которые ведут себя как… пользователи)\n\n<b>2. Невозможные для предусматривания баги</b>\n- редкие комбинации\n- странные тайминги\n- неожиданные нагрузки\n\n<b>3. Проверка бизнес-гипотез</b>\n- \"работает\" != \"полезно\"\n- важно не только отсутствие ошибок, но и эффект\n\n\n<span style=\"font-size: 18px\"><b>Когда shift-right оправдан</b></span>\n<b>Обязательно:</b>\n- high-load системы (высоконагруженные системы)\n- распределённые системы\n- микросервисы\n- продукты с метриками (конверсия, удержание)\n\n<b>Уместно:</b>\n- mature DevOps / SRE\n- хорошая автоматизация\n- rollback за минуты, а не за молитвы\n\n<b>Опасно или бесполезно:</b>\n- медицина, банкинг без изоляции\n- отсутствие мониторинга\n- \"давайте выкатим и посмотрим\" без плана отката\n\nИ ещё раз простыми словами: Shift-right testing - это подход, при котором тестирование и валидация качества продолжаются после релиза, в реальной среде, с использованием мониторинга, feature flags, A/B-тестов и контролируемых экспериментов.\n\n<hr>\n<h5>Взаимосвязь shift-left и shift-right</h5>\nЭто не конкуренты, а связка:\n\n<table><thead><tr><th>Shift-left</th><th>Shift-right</th></tr></thead><tbody><tr><td>Предотвращает дефекты</td><td>Обнаруживает неизвестное</td></tr><tr><td>Работает с логикой</td><td>Работает с поведением</td></tr><tr><td>До релиза</td><td>После релиза</td></tr><tr><td>Про \"правильно ли сделали\"</td><td>Про \"нужно ли это и так ли работает\"</td></tr></tbody></table>\n\n<table><thead><tr><th>Характеристика</th><th>Тестирование влево (shift-left testing)</th><th>Тестирование вправо (shift-right testing)</th></tr></thead><tbody><tr><td>Когда проводится?</td><td>На ранних этапах разработки (до и во время написания кода).</td><td>После развёртывания в продакшене, в реальной среде эксплуатации.</td></tr><tr><td>Цель</td><td>Выявить дефекты как можно раньше, минимизировать затраты на исправление ошибок.</td><td>Проверка работы системы в реальных условиях, выявление проблем производительности, безопасности и UX.</td></tr><tr><td>Фокус тестирования</td><td>Валидация требований, проверка качества кода, корректности архитектурных решений, функциональное тестирование.</td><td>Нагрузочное тестирование, тестирование пользовательского опыта, мониторинг производительности и безопасности.</td></tr><tr><td>Инструменты</td><td>Юнит-тесты, интеграционное тестирование, CI, TDD (разработка через тестирование).</td><td>Мониторинг производительности, A/B-тестирование, canary releases, тестирование безопасности на продакшене.</td></tr><tr><td>Кто тестирует?</td><td>Тестировщики и разработчики, активно взаимодействующие на этапе разработки.</td><td>SRE-инженеры, операционные команды и специалисты по мониторингу, иногда совместно с тестировщиками.</td></tr><tr><td>Как тестируется?</td><td>Автоматические и ручные тесты запускаются на основе симуляций и тестовых данных.</td><td>Тестирование на реальных данных и под реальной нагрузкой.</td></tr><tr><td>Типы ошибок</td><td>Логические ошибки, дефекты в коде, ошибки в проектировании, нарушения требований.</td><td>Проблемы производительности, уязвимости безопасности, сбои при реальных сценариях использования.</td></tr><tr><td>Риски</td><td>Основная сложность — это возможность пропустить ошибки, которые проявляются только при взаимодействии с другими модулями или системами.</td><td>Основная сложность — риск возникновения критических ошибок в продакшене, которые могут негативно повлиять на бизнес.</td></tr></tbody></table>\n<hr>\n<h5>Пример</h5>\n<b>Кейс:</b> онлайн-платёж в высоконагруженном сервисе (финтех, деньги, SLA, пользователи нервные)\n<b>Флоу:</b> пользователь &gt; вводит сумму &gt; подтверждает &gt; платёж &gt; статус\n\n<span style=\"font-size: 18px\"><b>1. Shift-left (до релиза)</b></span>\n\n<b>1.1 На требованиях</b>\n<b>Проверка бизнес-логики:</b>\n- что если платёж прошёл, но ответ не вернулся?\n- повторная отправка запроса?\n- идемпотентность (idempotency) ключей\n<b>Анализ рисков:</b>\n- двойное списание\n- зависшие статусы\n\n<b>1.2 На дизайне</b>\n<b>Проверка API-контракта (API contract):</b>\n- обязательные поля\n- коды ошибок\n<b>Edge cases (краевые случаи): </b>\n- таймауты\n- отмена операции\n\n<b>1.3 На коде</b>\n- Unit tests (модульные тесты)\n- Integration tests (интеграционные тесты)\n- Проверка retry-логики\n- Всё ещё QA / QC, даже если часть делает разработчик.\n\n<span style=\"font-size: 18px\"><b>2. Shift-right (после релиза)</b></span>\nТеперь система уже в проде, и начинается другой мир.\n\n<b>2.1 Canary deployment (канареечный деплой)</b>\n- 1% пользователей\n- QA следит: ошибки платежей, рост latency (задержек)\n- Это валидирование гипотезы, не эксплуатация.\n\n<b>2.2 Smoke checks в проде (дымовые проверки)</b>\n- успешный платёж\n- отмена\n- возврат\n- Это тестирование, но контролируемое.\n\n<b>2.3 A/B testing (A/B-тестирование)</b>\n- новый UX оплаты\n- сравнение конверсии\n- QA участвует в формировании критериев успеха.\n\n<span style=\"font-size: 18px\"><b>3. Где начинается SRE, а не тестирование</b></span>\n<b>SRE / DevOps зона\n3.1 Monitoring (мониторинг)</b>\n- метрики\n- алерты\n- dashboards (дашборды)\n- QA может смотреть, но не владеет системой.\n\n<b>3.2 Chaos testing (хаос-тестирование)</b>\n- отключение сервисов\n- задержки сети\n- Если: сценарии подготовлены заранее QA. эксперименты в проде = SRE\n<b>3.3 Auto-rollback (автоматический откат)</b>\n- по ошибкам\n- по latency\n-  Это эксплуатация, не тестирование.\n\nQA отвечает за вопросы \"что может пойти не так?\"\nSRE отвечает за \"что делать, когда это уже пошло не так\".\n\n<span style=\"font-size: 18px\"><b>4. Таблица для фиксации</b></span>\n<table><thead><tr><th>Практика</th><th>Shift-left</th><th>Shift-right</th><th>QA</th><th>SRE</th></tr></thead><tbody><tr><td>Анализ требований</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>Unit tests (модульные)</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>Canary deployment</td><td>❌</td><td>✅</td><td>⚠️</td><td>✅</td></tr><tr><td>Smoke в проде</td><td>❌</td><td>✅</td><td>✅</td><td>⚠️</td></tr><tr><td>Monitoring</td><td>❌</td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td>Chaos testing</td><td>❌</td><td>✅</td><td>⚠️</td><td>✅</td></tr></tbody></table>\n⚠️ - зона пересечения\nShift-left снижает вероятность дефекта, shift-right снижает ущерб от дефекта.","path":"-"}},{"title":"TCP/UDP - теория","data":{"code":"-","description":"<b>TCP и UDP</b> - это протоколы транспортного уровня сети.\nОни лежат выше IP и обеспечивают доставку данных между процессами (не просто между машинами). Их задача - дать приложению способ обмениваться информацией через сеть:\nTCP делает это надёжно и упорядоченно, создавая поток байтов. UDP делает это быстро и просто, отправляя отдельные пакеты без гарантий.\nТо есть TCP и UDP - это инструменты, с помощью которых приложения общаются по сети, каждый со своими правилами надёжности, порядка и скорости.\n\n\n<b>TCP (Transmission Control Protocol)</b> - это ориентированный на соединение, надёжный, упорядоченный протокол доставки байтового потока между двумя конечными точками. Здесь нет \"сообщений\". Есть поток байт. \n\n<h5>Основные свойства TCP</h5>\n<b>1. Соединение (connection-oriented)</b>\n- Перед передачей данных создаётся соединение \"Three-way handshake\"\n- После этого стороны синхронизируют состояния.\n<b>2. Надёжность</b>\nTCP гарантирует:\n- доставку\n- отсутствие дубликатов\n- сохранение порядка\n<b>3. Контроль потока (flow control)</b>\nИспользуется sliding window:\n- получатель говорит, сколько может принять\n- защищает от переполнения буфера\n<b>4. Контроль перегрузки (congestion control)</b>\n- TCP адаптируется к состоянию сети.\n<b>5.  Упорядоченность</b>\nПакеты могут прийти вразнобой - TCP:\n- пересобирает\n- отдаёт приложению строго по порядку\n<b>7. Завершение соединения</b>\n- Корректное закрытие:\nFIN &gt; ACK &gt; FIN &gt; ACK\n- Или аварийное:\nRST\n\n<b>TCP: плюсы и минусы</b>\n- Плюсы:\nнадёжность\nпредсказуемость\nпростота для приложений\n- Минусы:\nзадержки\noverhead\nhead-of-line blocking\n<hr>\n<b>UDP (User Datagram Protocol)</b>- это безсоединительный, ненадёжный протокол доставки датаграмм между процессами.\nЗдесь есть сообщения, но нет гарантий.\n<h5>Основные свойства UDP</h5>\n<b>1. Нет соединения</b>\n- нет handshake\n- нет состояния\n- каждый пакет сам по себе\n<b>2. Нет гарантий</b>\nUDP не гарантирует:\n- доставку\n- порядок\n- уникальность\n<b>3. Минимальный overhead</b>\nЗаголовок UDP - 8 байт\nTCP - минимум 20 байт\n<b>4. Сообщения, а не поток</b>\n- одно send ≈ одно сообщение\n- границы сообщений сохраняются\n\n<b>UDP: плюсы и минусы</b>\n- Плюсы:\nминимальная задержка\nпростота\nподходит для real-time\n- Минусы:\nвсё остальное - ответственность приложения\n\n<hr>\n<h5>Где что используется (и почему)</h5>\n<h6>TCP</h6>\n- HTTP/1.1\n- HTTP/2\n- HTTPS\n- FTP\n- SMTP\n<b>Причина:</b> данные важнее задержки.\n\n<h6>UDP</h6>\n- DNS\n- VoIP\n- Online games\n- Streaming\n- QUIC (поверх UDP!)\n<b>Причина:</b> задержка важнее потерь.\n<hr>\nКоротко:\nTCP:\n- Соединение устанавливается заранее (connection-oriented)\n- Надёжный: гарантирует доставку, порядок и отсутствие дубликатов\n- Поток данных (stream), а не отдельные сообщения\n- Контролирует перегрузку и поток\n- Задержка больше, overhead выше\n\nUDP:\n- Без соединения (connectionless)\n- Ненадёжный: доставка не гарантируется, порядок не сохраняется\n- Отправка отдельных сообщений (datagrams)\n- Минимальный overhead, низкая задержка\n- Надёжность и порядок - ответственность приложения\n\nГлавное различие:\nTCP = надёжный поток\nUDP = быстрые сообщения без гарантий","path":"-"}},{"title":"Логи / Логирование / Уровни / Типы","data":{"code":"-","description":"Если сравнить программу с живым организмом, то баг в ней - это болезнь. На возникновение \"болезни\" может повлиять целый ряд факторов и окружение, особенно, если мы рассматриваем веб-платформу в качестве запуска. Иногда причинно-следственная связь очень сложная, и баг, который нашли при тестировании - результат целого ряда событий.\nКак и при человеческих недугах, где лучше пациента никто не объяснит свои симптомы, ни один тестировщик не сможет рассказать, что произошло, лучше, чем сама программа. Поэтому существуют логи.\n\n<b>Лог (log)</b> - это файл с записями о событиях, происходящих в системе. Это как чёрный ящик в самолете, только для программ: в случае чего в лог‑файлах фиксируется информация, помогающая отслеживать поведение процессов в работе системы. \n\n<b>Логирование</b> - процесс формирования логов, то есть фиксация и структурирование информации о работе системы в отдельные лог‑файлы, чтобы можно быстро получить к ним доступ.\n\n<b>Логи записывают разную информацию:</b> от скорости работы приложения (время отклика) до данных об ошибках, исключениях и проблемах.\n\n<b>В тестировании:</b> Настроенные логи и доступ к ним для тестировщика ускорят разбор инцидентов на продакшене, так как описание проблемы часто бывает неполным или нечётким при воспроизведении дефекта. \nВо время тестирования различных интеграций лучше иметь доступ к логам задействованных сервисов, так как на каком‑либо уровне или этапе процесса может произойти отказ или сбой, отследить который без углубления в логи может оказаться проблематично. Например, фронт может ничего не сказать нам об ошибке и просто не подтянуть данные из смежного сервиса. Как раз здесь на помощь приходят логи.\n\n<b>Какую информацию может смотреть тестировщик в логах:</b>\n- Запросы и ответы, коды состояния\n- выполнение операций, последовательность событий\n- исключения (механизмы, обрабатывающие нетипичные ситуации и не прекращающие работу)\n- трассировку стека (список методов, которые были вызваны до момента, когда в приложении произошло исключение)\n- сообщения об ошибках или недостаточных данных\n- выполнение определенных операций, использование ресурсов (например, процессора, памяти)\nТак же логи бывают разных типов и уровней детализации и критичности. \n\n<img src=\"https://sun16-1.userapi.com/s/v1/ig2/YGjSk3B_Spip8QCuZatGYe3Zh43pscEDF_mLGdMmGvS36x2SBzxw7sNnzb4ufih7rUQN4ou38gTJNNERW2H3NNEt.jpg?quality=95&amp;as=32x27,48x40,72x61,108x91,160x135,240x202,360x303,480x404,540x455,640x539,720x606,1080x910,1280x1078&amp;from=bu&amp;cs=1280x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n\n<h5>Уровни логирования</h5>\nУровни логирования определяют, насколько важная информация будет записываться в лог-файлы или выводиться при выполнении программы. На верхнем уровне находятся самые важные сообщения. На них стоит обращать внимание в первую очередь. Чем ниже уровень логирования, тем менее критичная, но более подробная информация содержится в логе. \n\n<b>В тестировании:</b> Тестировщику они нужны для понимания того, есть ли ошибка / насколько она серьёзная и нужно ли заводить баг и отнести баг-репорт.\n\n<b>Уровни логирования бывают: </b>\n<b>1. FATAL:</b> является наивысшим уровнем критичности логов и указывает на самые критические ошибки и проблемы, которые могут привести к немедленному завершению программы или системы. Логи с уровнем FATAL обычно означают серьезные сбои, которые требуют немедленного вмешательства и исправления. \n\n<b>2. ERROR:</b> этот уровень используется для записи ошибок и проблем, которые могут привести к некорректной работе приложения. Логи с уровнем ERROR указывают на проблемы, которые требуют вмешательства и исправления.\n\n<b>3. WARN:</b> уровень WARN указывает на предупреждения и потенциальные проблемы, которые не являются критическими ошибками. Логи с уровнем WARN могут включать сообщения о неправильном использовании приложения, некорректных данных или других ситуациях, требующих внимания.\n\n<b>4. INFO:</b> этот уровень предоставляет информацию о ходе работы приложения и важных событиях. Логи с уровнем INFO содержат сообщения, которые помогают отслеживать основные операции и состояние приложения. Например, они могут сообщать о начале и окончании определенных операций, загрузке ресурсов, отправке и получении запросов, изменении состояния приложения и других событиях, которые могут быть полезны для отслеживания хода выполнения программы.\n\n<b>5. DEBUG:</b> содержат подробности о ходе выполнения приложения, значимые переменные и другие данные, которые могут быть полезными при обнаружении и исправлении ошибок.\n\n<b>6. TRACE:</b> это наиболее подробный уровень логирования. Логи с уровнем TRACE содержат очень подробную информацию о состоянии приложения, включая значения переменных, шаги выполнения и другие детали. Они обычно используются во время отладки и разработки для более глубокого анализа приложения.\n\n\nТестировщик чаще всего работает с ошибками (ERROR, реже FATAL) и c предупреждениями (WARN). Но для получения информации иногда, бывает, обращается к информационным логам (INFO). \nУровень логирования может быть настроен в зависимости от потребностей разработчика или тестировщика. \nОбычно в продакшене уровень детализации не устанавливается на самый высокий, чтобы не перегружать логи большим объёмом информации. В то время как во время разработки или отладки можно использовать такие уровни детализации, как DEBUG или TRACE, для более глубокого анализа и отслеживания проблем.\n<img src=\"https://sun9-31.userapi.com/s/v1/ig2/CJ-zg9nRM2fyQwXiWw27k_9n1nH1T7VH1LiCtOdvx2MLLLaCzR7IWqaBrBW37XYis5VPCnCnMO9oCwnMfjc9hloW.jpg?quality=95&amp;as=32x18,48x27,72x41,108x62,160x91,240x137,360x205,480x274,540x308,640x365,720x410,1080x615,1280x729,1440x821,1560x889&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<img src=\"https://sun9-69.userapi.com/s/v1/ig2/2KLatDKVNlIE4vwBPB6aZ2ZE34_xVYShOa-madCj5S4ARP22YwWncs6cxLNrTmtukDIIPcXQKVhMM_bIAERWA8bU.jpg?quality=95&amp;as=32x12,48x19,72x28,108x42,160x62,240x93,360x139,480x186,540x209,640x247,720x278,768x297&amp;from=bu&amp;cs=768x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<hr>\n<h5>Типы (виды) логов</h5>\nСуществует несколько различных типов логов, которые широко используются в программировании и системном администрировании.\n<b>В тестировании:</b> Чтобы понимать, к какому типу логов обратиться для проверки и дебага сервера или клиента,  например при тестировании бэкенда, нам скорее всего понадобятся логи сервера. Тестировщик чаще всего работает с логами приложения, логами сервера и системными логами.\n\nЧтобы понимать, на каком этапе произошла ошибка и к какому логу обратиться, логи делятся на следующие типы:\n<b>1. Системные (System logs)</b>\nСоздаются операционной системой и содержат информацию о её работе, включая запуск и завершение процессов, ошибки файловой системы и другие события. Они помогают отслеживать работу приложения на уровне операционной системы и выявлять проблемы, связанные с конфигурацией или взаимодействием с другими приложениями.\n\n\n<b>2. Логи приложения  (Application logs)</b>\nСоздаются самим приложением и содержат информацию о его работе: сообщения об ошибках, предупреждения и информацию о выполненных действиях. Такие логи помогают выявлять и исправлять ошибки в приложении, а также понимать его внутреннее состояние и последовательность действий.\n\n<b>3. Логи сервера (Server logs)</b>\nСодержат информацию о запросах к серверу и других событиях, происходящих на сервере. Серверные логи отслеживают взаимодействие приложения с сервером, выявляют проблемы с производительностью и обрабатываемостью запросов.\n\n<b>4. Логи базы данных (DataBase Logs)</b>\nСодержат информацию о выполняемых запросах к базе данных, изменениях данных и других событиях. Такие логи помогают отслеживать выполнение запросов, выявлять проблемы с производительностью и целостностью данных.\n\n<img src=\"https://sun9-78.userapi.com/s/v1/ig2/xkmCfVS3Cxlcv6wis4nrabQu3BQHe2AO7SaRmsPgNMJ-8dqmT728zgbWnuWVfQ5aP1PDIRcv4WczJ-q7MgRTPuWZ.jpg?quality=95&amp;as=32x20,48x30,72x45,108x67,160x99,240x148,360x223,480x297,540x334,640x396,720x445,1080x668,1280x792,1440x891,1560x965&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<h5>Что хранится в логах, пример</h5>\nРазные виды и логи разной детализации содержат в себе информацию разного вида. Информация в логах также зависит от того, что туда решил положить разработчик, также от решения разработки зависит, какие уровни детализации и критичности логов будут использованы. \n\nБольшинство разработчиков стараются придерживаться общих правил написания логов. К примеру, практически любой лог имеет:\n- системную информацию (время и дата события, ID события и другая служебная информация);\n- уровень лога;\n- текст сообщения (например, сообщения об ошибке);\n- контекст (дополнительная информация).\n\n<img src=\"https://sun9-19.userapi.com/s/v1/ig2/1IeHj1Es70NJnFMzlueQKOdMyDqZ1hqPeQXAn0n2U5EWCYeYGkBDw1oy8TBB9fgpKMCtbUy-3GmyBRe3rgKwt4nq.jpg?quality=95&amp;as=32x9,48x14,72x21,108x32,160x47,240x71,360x107,480x142,540x160,640x190,720x214,1080x321,1280x380,1440x427,1560x463&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Дата и время:</b> 2023-05-18 10:23:45 - указывает точное время, когда произошла ошибка.\n<b>Уровень лога:</b> [ERROR] - указывает на уровень ошибки.\n<b>Контекст:</b> [Server] - указывает на компонент или модуль системы, в котором произошла ошибка.\n<b>Сообщение об ошибке:</b> Exception occurred while processing request - описание самой ошибки.\n<b>Стек вызовов:</b> Последующие строки показывают стек вызовов и указывают на классы и методы, в которых произошла ошибка. В данном примере указывается, что ошибка возникла в методе handleRequest класса MyController (строка 32), затем в методе processRequest класса Server (строка 87) и так далее.\n\n<img src=\"https://sun9-19.userapi.com/s/v1/ig2/8PWgjlPSaDZ8h-bKR7HjT5My0_nUizFJD4pomlGxckw5GSDJXdEUJ2_BNjGGbHq8plubwgup93HkCWB4zd1OC1_P.jpg?quality=95&amp;as=32x11,48x16,72x24,108x36,160x53,240x80,360x120,480x160,540x180,640x214,720x240,1080x361,1280x427,1440x481,1560x521&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nОбладая знаниями о логировании системы, тестировщик может легко понять, что происходит во время его работы с приложением, быстро отследить ошибки и лучше описывать ошибки внутри своих репортов. Это серьёзно ускорит процесс исправления бага, а значит, и скорость разработки новых фич и релиза. \n\nВ логах обычно происходит очень много событий, и зафиксировать какой то момент достаточно проблематично. Поэтому существуют инструменты для грамотного управления логами. Elasticsearch + Kibana / Kafka / Openshift  и т.д.","path":"-"}},{"title":"Базы Данных / Типы / СУБД","data":{"code":"-","description":"<h5>Базы данных:</h5> \nВ большинстве случаев информацию хранят в Excel таблицах, это удобно до поры до времени, пока данных не становится слишком много. Тогда происходит затруднение с поиском и фильтрацией нужной информации, особенно когда это необходимо сделать быстро. Отсюда появляется потребность в инструментах которые могут работать с большим объёмом информации. Для этих целей используются базы данных.\n\n<b>База данных (БД)</b> -  это упорядоченный набор данных, хранящийся в электронном виде и предназначенный для хранения, поиска, извлечения и управления информацией, обычно с помощью систем управления базами данных (СУБД). \n\n<img src=\"https://sun9-31.userapi.com/s/v1/ig2/FO0SEH17fY5-vOe3n0ja3fKd-R-FiK3cPYqqaEiAsIdmECdXdbQ37Sy0tkkaAxEJIdCOgbpM9URVBu0u6IIfjVEo.jpg?quality=95&amp;as=32x15,48x22,72x33,108x49,160x73,240x109,360x164,480x218,540x245,640x291,660x300&amp;from=bu&amp;cs=660x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<h5>Типы баз данных:</h5> \nПомимо самой сущности как БД она внутри себя классифицируется на типы. От типа БД зависит способ структурирования информации, а также способ взаимодействия с базой.\n\n<h6>Различают несколько типов БД:</h6>\n<b>1. Текстовые БД</b>\nПростейшие файлы разных форматов (txt, csv), в которых данные располагаются построчно, а поля разделены (запятой/точкой с запятой/двоеточием/пробелом). Текстовые базы данных просты в использовании, но не дают возможность зафиксировать связи между записями и подходят далеко не для всех типов данных.\n<img src=\"https://sun9-16.userapi.com/s/v1/ig2/-BkGdcOczS8HtQuMmXxnsFuhTLRC5XrGtALVnbEFzyF3aEj0pJFB-qgoWhuKi5mnaSs-3dYFRCd24U0e7_wzOGqA.jpg?quality=95&amp;as=32x21,48x31,72x47,108x70,160x104,240x156,360x234,480x313,540x352,640x417,720x469,955x622&amp;from=bu&amp;cs=955x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Примеры</b>: etc/passwd и etc/fstab в Unix-подобных системах, csv-файлы, ini-файлы и др.\n\n<b>2. Иерархические БД</b>\nЭти БД тоже одни из простейших и похожи на текстовые. Основное отличие в том, что здесь можно настроить связи между хранимыми объектами. Действует иерархический принцип связей: новые записи разветвляются от \"родительской\", причём каждое ответвление может иметь только одного родителя. У каждой записи возникает физическая связь только с одной предыдущей записью. Отношения между объектами выражены как физические указатели. Представьте путь к любой папке в вашем компьютере - аналогичная древовидная структура используется и в иерархических БД.\n<img src=\"https://sun9-49.userapi.com/s/v1/ig2/AdFkx6RSKQOSLapow9iE9_HsU6ttAlZsocef9kCEkbRYl1o32NHiOBVD0fp44GNbyb-DNscoKbBnzacbYL-ovEj1.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x203,480x270,540x304,640x360,720x405,1080x608,1280x720,1440x810,1525x858&amp;from=bu&amp;cs=1525x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Примеры:</b> Организация файловых систем; DNS и LDAP-соединения.\n\n<b>3. Сетевые БД</b>\nБолее сложный способ организации массивов данных, при котором у каждой записи может быть не один \"родитель\", а несколько. Здесь можно настроить больше связей и моделировать разнообразные отношения между записями, поэтому сетевые БД визуализируют как общий граф.\n<img src=\"https://sun9-50.userapi.com/s/v1/ig2/cw6L5fV5sialnuP0SFQrQBF14T6sIRhhc6_Rz64iPj92hKQSA5xes52C1EWBed8K3laTO8CCPMKd1nMxyShwvPae.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x203,480x270,540x304,640x360,720x405,1080x608,1280x720,1440x810,1525x858&amp;from=bu&amp;cs=1525x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Пример:</b> IDMS - специализированная СУБД для мейнфреймов.\n\n<b>4. Реляционные базы данных</b>\nЭти БД также часто называют SQL-базами - потому что с помощью этого языка они создаются, преобразовываются и управляются. Они используются для хранения и организации точек данных с заданными отношениями, что гарантирует быстрый доступ к информации. \nВ реляционных БД записи и связи между ними хранятся в табличном виде. В строках содержится информация об объектах, а в столбцах - свойства объектов (поля). У этих таблиц предусмотрены поля для внешнего ключа и ссылки на другие таблицы (таким образом, таблицы могут быть взаимосвязаны).\n<img src=\"https://sun9-28.userapi.com/s/v1/ig2/AIHPmv_CZrUHlHJ33xZc-qHLRsr7JMSD7Bnulu48mjYd3U3iCQ3Bg5Rmu_IS9yS6BLOHKgFPMpIOnd-SvgoX22JF.jpg?quality=95&amp;as=32x23,48x34,72x51,108x77,160x114,240x171,360x257,480x342,540x385,640x457,720x514,1080x771,1280x913,1440x1027,1525x1088&amp;from=bu&amp;cs=1525x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Пример:</b> моделирование сложных взаимоотношений в реляционных БД приведен на рисунке выше. Здесь мы видим модель базы данных учебного заведения, где есть следующие объекты: ученик, курс, преподаватель, отдел, направление обучения. \nСвязь преподавателя с отделом организована через секцию и курс (внешние ключи id курса и id преподавателя в таблице Секция, а также Отдел в таблице Курс). Связь ученика с направлением обучения реализована через таблицу Направление обучения студента (внешние ключи id студента и id направления обучения). \nТаким образом, чтобы посчитать, например, количество студентов на курсе и детализировать статистику по преподавателям, необходимо написать запрос с присоединением учеников к направлению, курсу и преподавателям, сделав соответствующую группировку по преподавателям.\n\n<b>5.Нереляционные БД</b>\nНереляционные базы данных ориентированы на работу с вложенными структурами данных и используют отличные от SQL запросы. Поэтому их также называют NoSQL БД. Если в реляционных БД присутствует жёсткая структура сведений об объектах, а хранение и обработку плохо или вообще не структурированных данных из разных источников организовать крайне сложно, то NoSQL позволяет обойти эти ограничения.\nВ таких БД применяется модель, оптимизированная под требования типа хранимых данных. Нереляционные базы данных используют везде, где требуется масштабируемость и высокая скорость обработки запросов. Примером инструментов для работы с такими БД можно назвать Redis, mongoDB.\n\n<details>\n<summary>Разновидности нереляционных БД</summary><div>\n<b>5.1 Графовые БД</b>\nИнтересная модель хранения в виде графа и его обобщений. Графовые базы данных дают возможность определять взаимосвязи и находить ответы на сложные вопросы о том, как точки данных соотносятся друг с другом. Идея такой организации информации в том, что в БД используются узлы для хранения сущностей данных и рёбра для хранения взаимосвязей между сущностями. У ребра всегда есть начальный и конечный узел, тип и направление. У записи в графовой БД может быть неограниченное количество связанных с ней свойств. Допустим в БД хранится карточка сотрудников с ФИО, возрастом и должностью, а рёбра показывают задачи или другие параметры, которые объединяют этих людей.\n<img src=\"https://sun9-35.userapi.com/s/v1/ig2/ijJ86pLcrUkIXMsTqzIE4vH9XUxlMTe7DMAP43pzwp2yhblV6MUS_FvZRjXRqVfY5CGlmDMF65Txacp4eRqPx7V1.jpg?quality=95&amp;as=32x24,48x37,72x55,108x82,160x122,240x183,360x274,480x366,540x411,600x457&amp;from=bu&amp;cs=600x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>5.2 Колоночные БД</b>\nКолоночные базы данных тоже предлагают хранение данных в табличном виде. Отличие от реляционных БД в том, что структура колонок не регламентирована, их можно объединять в колоночные семейства, имеющим определённый формат. У строк колоночного семейства формируется уникальный идентификатор. Такой подход эффективен для работы аналитических систем и сервисов, использующих большие наборы данных. Поэтому колоночные БД используют в аналитических системах класса business intelligence (ROLAP) и аналитических хранилищах данных (data warehouses).\n<img src=\"https://psv4.userapi.com/s/v1/d2/uxiI6PvGf-FsITOpLyG8jIaenpIeCo_5VL41Nnvdi0rO8p4lT4FxRpjH4xzevYfcP4ll7I7K21xQHti7p4zfAQlOciSWJYKMujnnNPwyJLAwrgH3wuyHpyt1VhZFEoi9NPY1coyyUfYN/column-oriented-d082e49b7743d4ded32c7952bfdb028f.gif?dl=1\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>5.3 Объектно-ориентированные БД</b>\nВ ООБД информация представлена в виде объектов, которым присваивается уникальный идентификатор. Также в БД есть атрибуты, описывающие состояние объекта, методы и классы. Объектно-ориентированные базы данных используются в случаях, когда нужна высокопроизводительная обработка сложноструктурированных данных. ООБД позволяет определять абстракции, облегчает проектирование связей и поддерживает новый набор предикатов сравнения. В ряде случаев такие БД обеспечивают более высокую производительность по сравнению с реляционными, обеспечивают версионность и поддержку транзакций.\n<img src=\"https://sun9-17.userapi.com/s/v1/ig2/YL9_3dwrAsf35LZohTF5peor5FmW9FjYxg61oIR9ZH6hN8--xfJeP_5OqzPo-nMn_UUUT051PNgTQUywXsMMxQ0O.jpg?quality=95&amp;as=32x23,48x35,72x53,108x79,160x117,240x176,360x264,480x352,540x396,640x470,720x528,861x632&amp;from=bu&amp;cs=861x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>5.4 NewSQL БД</b>\nПодход, совмещающий реляционную модель, язык SQL-запросов и масштабируемые, горизонтально распределённые базы данных NoSQL. NewSQL - это ответ на потребности бизнеса, которые не способны удовлетворить привычные базы данных. Для таких БД характерно использование алгоритмов обеспечения консенсуса (например, Paxos, Raft), шардирование, горизонтальная масштабируемость и более быстрая работа благодаря эффективным \"движкам\". Используют их в сферах, работающих с критическими данными. Это здравоохранение, финтех и т. д. Важно помнить, что NewSQL базы данных предъявляют высокие требования к ресурсам.\n</div></details>\n\n<h5>Важная пометка</h5>\nИерархические и сетевые базы данных относятся к нереляционным моделям данных, так как не используют табличную реляционную модель. В то же время они стали \"нереляционными\" в тот момент когда появились \"реляционные\", поэтому не имеют отношения к NoSQL. Который в свою очередь в наше время является основоположником нереляционных БД. Текстовые хранилища формально тоже нереляционные, но чаще рассматриваются как файловые форматы, а не полноценные СУБД.\n\n<img src=\"https://sun9-87.userapi.com/s/v1/ig2/-7OUq5aFlUIM1jhodxYW27L3Yc2aO51oTaIjBdb14e1PENNAwNZj8MnKjVi6NHHY01VqndbCSSL9n1mFsfQF7XF9.jpg?quality=95&amp;as=32x19,48x29,72x43,108x64,160x95,240x143,360x215,480x287,540x322,640x382,720x430,1032x616&amp;from=bu&amp;cs=1032x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<hr>\n<h5>СУБД:</h5> \n<b>Система управления базами данных (СУБД)</b> – это комплекс программно-языковых средств, позволяющих создать базы данных и управлять данными. Иными словами, СУБД - это набор программ, позволяющий организовывать, контролировать и администрировать базы данных. Большинство сайтов не могут функционировать без БД, поэтому СУБД используется практически повсеместно.\n\n<b>Основные функции СУБД:</b>\n- управление данными во внешней памяти (на дисках);\n- управление данными в оперативной памяти с использованием дискового кэша;\n- журнализация изменений (сохранение истории), резервное копирование и восстановление базы данных после сбоев;\n- поддержка языков БД (язык определения данных, язык манипулирования данными).\n<img src=\"https://sun9-84.userapi.com/s/v1/ig2/rFbiF02UI8vpdsKPwCoD5Kd4eiEEHqUKwxAYIzvl8rBnh55su8_jleKse79P-26ijNFTPNXxs5pM414tk_-ooX-l.jpg?quality=95&amp;as=32x24,48x37,72x55,108x82,160x122,240x183,360x275,480x367,540x412,640x489,720x550,1080x825,1280x978,1440x1100,1503x1148&amp;from=bu&amp;cs=1503x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n\n<b>По модели данных СУБД бывают:</b>\n<b>- Иерархические.</b> В этой модели данных используется представление БД в виде древовидной структуры, состоящей из данных разных уровней.\n<b>- Сетевые.</b> Данная модель является расширением иерархического подхода. Иерархическая модель подразумевает, что запись-потомок может иметь строго одного предка, в то время как в сетевой структуре потомок может иметь любое количество предков.\n<b>- Реляционные.</b> СУБД, ориентированные на организацию данных как набор связанных записей и атрибутов в двумерной таблице.\n<b>- Объектно-ориентированные.</b> Для управления БД, основанными на объектной модели данных. Как правило основываются на объектно-ориентированных языках программирования.\n<b>- Объектно-реляционные.</b> Объединяет в себе концепции реляционной модели с дополнительными объектно-ориентированными возможностями.\n\n<h6>SQL и реляционные БД:</h6>\nСегодня по-прежнему наиболее популярными при создании веб-приложений и сервисов остаются реляционные базы данных. Для управления реляционными базами данных используется язык SQL (Structured Query Language - структурированный язык запросов). Изначально SQL был инструментом работы пользователя с базой данных, однако со временем язык усложнился и стал скорее инструментом разработчика, чем конечного пользователя.\n\n<img src=\"https://sun9-21.userapi.com/s/v1/ig2/ruGP4S5Fr3TtFQwzIfuSRsXIv0Ye73jT6Y9TyfQZghXZ-OREV4-7QcU5d3rsUX8k1pV9Xe-4Vx0aWbPvbP9btsGb.jpg?quality=95&amp;as=32x5,48x7,72x11,108x16,160x24,240x36,360x54,480x73,540x82,640x97,720x109,1080x163,1263x191&amp;from=bu&amp;cs=1263x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Наиболее популярные реляционные СУБД:</b>\n<b>1. MySQL</b>\nСчитается одной из самых распространенных СУБД. MySQL - реляционная СУБД с открытым исходным кодом, главными плюсами которой являются ее скорость и гибкость, которая обеспечена поддержкой большого количества различных типов таблиц.\nКроме того, это надежная бесплатная система с простым интерфейсом и возможностью синхронизации с другими базами данных. В совокупности эти факторы позволяют использовать MySQL как крупным корпорациям, так и небольшим компаниям.\n\n<b>2. Microsoft SQL Server</b>\nКак следует из названия, фирменная СУБД, разработанная Microsoft. Оптимальная для использования в операционных системах семейства Windows, однако может работать и с Linux.\nСистема позволяет синхронизироваться с другими программными продуктами компании Microsoft, а также обеспечивает надежную защиту данных и простой интерфейс, однако отличается высокой стоимостью лицензии и повышенным потреблением ресурсов.\nВ целом, однако, сохраняет свою популярность, в немалой степени из-за того, что продукты корпорации Microsoft используются многими компаниями.\n\n<b>3. PostgreSQL</b>\nСУБД PostgreSQL - еще одна популярная и бесплатная система. Наибольшее применение нашла для управления БД веб-сайтов и различных сервисов. Она универсальна, то есть подойдет для работы с большинством популярных платформ.\nПри этом PostgreSQL - объектно-реляционная СУБД, что дает ей некоторые преимущества над другими бесплатными СУБД, в большинстве являющимися реляционными.\n\n<b>4. Oracle</b>\nПервая версия этой объектно-реляционной СУБД появилась в конце 70-х, и с тех пор зарекомендовала себя как надежная, функциональная и практичная. СУБД Oracle постоянно развивается и дорабатывается, упрощая установку и первоначальную настройку и расширяя функционал.\nОднако существенным минусом данной СУБД является высокая стоимость лицензии, поэтому она используется в основном крупными компаниями и корпорациями, работающими с огромными объемами данных.","path":"-"}},{"title":"Основы безопасности: SQLi, XSS, CSRF, OWASP Top 10","data":{"code":"-","description":"Основы безопасности для QA начинаются с понимания того, что ты проверяешь не взлом, а устойчивость системы к ожидаемо неадекватному вводу и поведению пользователя. SQLi, XSS и CSRF - это не \"хакинг\", а следствие ошибок проектирования и реализации. OWASP - это не страшная аббревиатура, а список самых типовых и дорогих косяков.\r\n\r\n<hr>\r\n<h5>SQLi</h5>\r\n<b>SQLi (SQL Injection - SQL-инъекция)</b> - возникает, когда пользовательский ввод напрямую влияет на SQL-запрос к базе данных. Ключевая предпосылка здесь простая: если данные из формы, URL или тела запроса попадают в запрос без параметризации и экранирования, пользователь начинает управлять логикой запроса. Для QA важно понимать, что это не только про ' OR 1=1 --, а про любые ситуации, где ввод меняет структуру запроса, а не только его значения. Если при неверном вводе система возвращает SQL-ошибки, различает \"логин не найден\" и \"неверный пароль\" или ведёт себя по-разному при кавычках - это уже сигнал. \r\n\r\n<img src=\"https://sun9-76.userapi.com/s/v1/ig2/5bwOrVCE48aIRlCVDiHcE9LEDNw2Rm1OuMaVBGodLrODiayjiJYbUbXmBrY7m_lJnkZVepekH2h3gZog2kgBo6HZ.jpg?quality=95&amp;as=32x23,48x34,72x51,108x76,160x113,240x169,360x254,480x338,540x381,640x451,701x494&amp;from=bu&amp;cs=701x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<details>\r\n<summary>Как это работает</summary><div>\r\nКогда вы вводите данные на сайте, например, логин или поисковый запрос, они отправляются на сервер. Серверная программа берет этот текст и вставляет его в готовую команду для базы данных.\r\n<b>Суть SQL-инъекции</b> - пользовательские данные перестают быть просто данными и становятся частью управляющей логики запроса.\r\n\r\n<b>Техническая цепочка выглядит так:</b>\r\n<b>1. Сбор данных:</b> программа собирает информацию отовсюду - не только из полей, которые вы заполнили вручную, но и из скрытых параметров: название вашего браузера, адрес предыдущей страницы, технические файлы cookies.\r\n<b>2. Склейка команды:</b> программа берет шаблон команды и просто добавляет к нему полученный текст.\r\n<b>3. Исполнение:</b> база данных получает итоговую строку и выполняет её.\r\n\r\n<b>В чем проблема</b>\r\nУязвимость возникает, если программа не выполняет два обязательных действия перед склейкой:\r\n<b>- Валидация (проверка):</b> программа не проверяет, соответствует ли ввод ожидаемому формату - например, что в поле «возраст» пришло число, а не текст команды.\r\n<b>- Экранирование:</b> программа не нейтрализует спецсимволы : кавычки, точки с запятой. В итоге база данных воспринимает часть вашего текста как часть своего собственного системного кода.\r\nЕсли эти два этапа пропущены, любой символ, введенный пользователем, может изменить смысл всей операции в базе данных.\r\n\r\n<img src=\"https://sun9-64.userapi.com/s/v1/ig2/VDFBdiuXxicRENfdpZYkZG7dYfvoHh7vMI3Vu-PhX-FR1GJPapvUvioTD_9dNZ8UHmL2_xJrdl3lLqS0l8No_Cvu.jpg?quality=95&amp;as=32x17,48x26,72x39,108x59,160x87,240x131,360x197,480x262,540x295,640x349,720x393,1024x559&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div></details>\r\n\r\n<details>\r\n<summary>Почему такие ошибки часто встречаются на веб-проектах?</summary><div>\r\n<b>Эта уязвимость не исчезает по нескольким причинам:</b>\r\n<b>- Legacy-код.</b> Мир полон проектов, написанных десять лет назад, где безопасность не была приоритетом. Переход на безопасные технологии, такие как ORM или Prepared Statements, требует времени и ресурсов, и часто откладывается.\r\n<b>- Новые фреймворки обычно защищены от SQLi</b>, но разработчики могут её обойти. Использование \"сырых\" запросов для оптимизации или нестандартных сценариев мгновенно создаёт уязвимость.\r\n<b>- Человеческий фактор и недостаток обучения</b>. Студенты и молодые специалисты часто фокусируются на скорости и функциональности, а не на безопасности. Базовые принципы безопасной разработки (secure coding) редко преподают в вузах.\r\n<b>- Слабый контроль.</b> Часто проверка безопасности не входит в стандартный цикл контроля качества <b>(QA)</b>. Если в команде не выделена отдельная роль для ИБ-инженера, уязвимости с высокой вероятностью попадают в рабочую среду.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Типы SQL Инъекций</summary><div>\r\nSQL-инъекция не требует прямого доступа к серверу или сложных инструментов. Достаточно одной уязвимой формы, URL-параметра или даже заголовка, чтобы неверно обработанные данные превратились в управляемый SQL-запрос.\r\nЕсть несколько подходов к классификации SQL-инъекций. Один из них - по способу взаимодействия с базой данных:\r\n<b>In-band</b> - атакующий получает результат сразу, в том же канале, откуда отправил запрос. Примеры: Error-based, Union-based.\r\n<b>Inferential (Blind)</b> - результат нельзя получить напрямую, но можно вывести логическую информацию по реакции сервера. Примеры: Boolean-based, Time-based.\r\n<b>Out-of-band</b> - взаимодействие происходит через сторонний канал, например, DNS-запрос или HTTP-пинг.\r\n<b>Second-order</b> - вредоносные данные сохраняются в системе и срабатывают позже, при повторной обработке.\r\n\r\n<b>Классические сценарии поиска уязвимостей:</b>\r\n<b>Сценарий 1: Классический обход авторизации</b>\r\nЭтот приём - классика жанра, но до сих пор встречается в рабочих проектах, особенно в старых системах авторизации. Он позволяет злоумышленнику войти в систему без знания логина и пароля, подменяя логику запроса.\r\n<b>Пример:</b> Представим стандартную форму авторизации, где значения из полей username и password напрямую вставляются в SQL-запрос.\r\nАтакующий вводит в поле username строку:  ' OR '1'='1' --\r\nи любое значение в поле password.\r\nВ результате SQL-запрос, который отправляется в базу данных, выглядит так:\r\nSELECT * FROM users WHERE username = '' OR '1'='1' --' AND password = 'anything'\r\nЧто происходит: СУБД выполняет username = », а затем встречается с OR '1'='1'.\r\nТак как выражение 1'='1 всегда истинно (TRUE), таким же всё условие. Часть запроса после двойного дефиса (--) воспринимается как комментарий и игнорируется. БД возвращает первую строку из таблицы users, которая обычно принадлежит администратору.\r\nЭтот пример наглядно демонстрирует, как вставка данных без параметризации открывает прямой путь к полному обходу авторизации.\r\n\r\n<b>Сценарий 2: </b>  Раскрытие структуры БД через UNION SELECT\r\nЕсли приложение выводит данные из базы напрямую в интерфейс, хакер может использовать UNION SELECT чтобы получить сведения о других таблицах и столбцах, даже без доступа к ним. Этот сценарий подчёркивает важность изоляции пользовательского ввода и строгой фильтрации вывода.\r\n- Шаг 1: Поиск таблиц. Злоумышленник находит уязвимый URL (например, с параметром id=). Он использует UNION SELECT для запроса к системной таблице, которая хранит метаданные, например information_schema.tables .\r\nurl.com/?id=1 UNION SELECT null, table_name, null FROM information_schema.tables\r\nЕсли приложение не отфильтровало вывод, в результате будет отображён список всех таблиц базы данных: users, orders, admin_log и т.д.\r\n\r\n- Шаг 2: Извлечение столбцов. Определив нужную таблицу (users), атакующий повторяет атаку, но уже запрашивает имена столбцов: url.com/?id=1 UNION SELECT null, column_name, null FROM information_schema.columns WHERE table_name='users'. На экране появится список: id, username, password_hash, email. Теперь у хакера есть вся необходимая информация для дальнейших атак.\r\nЭтот сценарий показывает, как неконтролируемый вывод данных из базы может стать инструментом для кражи конфиденциальной информации.\r\n\r\n<b>Сценарий 3:</b> Скрытая атака на изменение и удаление данных\r\nSQL-инъекция - это не только чтение, но и изменение. Если у пользователя базы данных есть права на запись (UPDATE, DELETE), злоумышленник может использовать эту уязвимость для изменения или удаления информации. Такая атака не сразу заметна, поэтому особенно опасна.\r\nАтакующий подставляет дополнительную команду SQL в текстовое поле, например, для смены пароля администратора: username=admin'; UPDATE users SET password='new_b_password' WHERE username='admin';--\r\n\r\nЧто происходит: Уязвимый код сформирует два запроса:\r\n- SELECT * FROM users WHERE username = 'admin' ...\r\n- UPDATE users SET password='new_b_password' WHERE username='admin';\r\n\r\nПосле выполнения первого запроса второй запрос изменит пароль администратора, и атакующий получит полный контроль над системой.\r\n\r\nЭтот пример показывает, как SQL-инъекция может стать инструментом для саботажа и полного компрометирования системы, если права пользователя базы данных не ограничены.\r\n\r\nЕсли вы - разработчик, <b>тестировщик</b>, аналитик или владелец сервиса, важно не просто знать о таких атаках, а понимать, где они могут возникнуть. Примеры выше помогут распознать уязвимость до того, как её найдёт кто-то другой.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Что тестировать QA?</summary><div>\r\n<b>1. Валидация и очистка ввода:</b> Проверка полей на наличие спецсимволов (', \", ;, --, /*, */), а также их правильное экранирование (замена на безопасные эквиваленты, например, \\').\r\n<b>2. Обработка ошибок:</b>  Убедиться, что ошибки базы данных не выводятся пользователю, чтобы не дать подсказок атакующему.\r\n<b>3. Принцип наименьших привилегий:</b> Убедиться, что учетная запись, под которой приложение работает с БД, имеет минимально необходимые права.\r\n<b>4. Использование параметризованных запросов (Prepared Statements):</b> Это основной метод защиты, где SQL-код и данные разделены. \r\n</div></details>\r\n\r\n<hr>\r\n<h5>XSS</h5>\r\n<b>XSS (англ. Cross-Site Scripting - \"межсайтовый скриптинг\")</b> - довольно распространенная уязвимость, которую можно обнаружить на множестве веб-приложений. Ее суть довольно проста, злоумышленнику удается внедрить на страницу JavaScript-код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда жертвы (обычные пользователи) будут заходить на страницу приложения, куда этот код был добавлен.\r\n\r\n<b>Тестировщик должен уметь проверять свое веб-приложение на уязвимости. Однако, использование XSS-уязвимостей на чужих ресурсах является незаконным.</b>\r\n\r\n<img src=\"https://sun9-88.userapi.com/s/v1/ig2/FxzvkZQXnIPwPQ6EhcU_7dMqnao4DJEYowCIflcmn1A5AXp_kYEn2hnoM7kWqlCxQ7FHiJfm_89sguuZIEvXHXun.jpg?quality=95&amp;as=32x21,48x32,72x48,108x72,160x107,240x160,360x240,480x320,512x341&amp;from=bu&amp;cs=512x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<details>\r\n<summary>Как это работает</summary><div>\r\nJavaScript внедряется туда, где пользовательский ввод сохраняется и затем отображается другим пользователям без экранирования. Типичные точки - профиль пользователя, комментарии, отзывы.\r\n\r\nЗлоумышленник вводит текст с JavaScript-кодом. Этот ввод сохраняется на сервере. Когда любой другой пользователь открывает страницу, вместе с данными загружается и внедрённый JavaScript, который выполняется при рендеринге страницы. Уязвимость срабатывает, если сохранённый текст не был очищен или экранирован.\r\n\r\n<b>Это stored XSS (хранимая XSS)</b> - код выполняется у всех посетителей страницы, а не только у атакующего.\r\n\r\nВозможные последствия:\r\n- кража авторизационных данных и захват аккаунта;\r\n- незаметный редирект на фишинговую страницу-клон с целью перехвата sensitive data (чувствительных данных);\r\n- выполнение любых действий, доступных JavaScript в контексте страницы.\r\n\r\n<b>Причина уязвимости:</b> приложение доверяет сохранённым данным и выводит их без учёта контекста исполнения. Злоумышленнику не нужен доступ к исходному коду - достаточно точки ввода, данные из которой попадают в HTML без корректной обработки.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Почему такие ошибки часто встречаются на веб-проектах?</summary><div>\r\n<b>XSS часто возникает потому, что браузер не различает \"текст\" и \"код\"</b>. Он интерпретирует содержимое по контексту:\r\n- внутри &lt; script &gt; - как JavaScript;\r\n- внутри &lt; style &gt; - как CSS;\r\n- всё, что выглядит как HTML-теги, - как HTML.\r\n\r\n<b>Если приложение выводит пользовательский ввод \"как есть\", браузер пытается выполнить его как код.</b>\r\n\r\nЧтобы текст выглядел как код, но не исполнялся, его нужно предварительно обработать - <b>экранировать (escaping, экранирование)</b>. Без экранирования браузер не знает, что это просто текст, а не инструкция к исполнению.\r\n\r\nВторая частая причина - уязвимость находится не в бизнес-коде разработчика, а в подключённой библиотеке или фреймворке. Подключая зависимость, разработчик может унаследовать уже существующую XSS-дыру, даже не подозревая об этом.\r\n\r\n<b>В итоге:</b>\r\n- браузер делает ровно то, что ему сказали;\r\n- код доверяет данным больше, чем должен;\r\n- уязвимость \"приезжает\" вместе с зависимостями.\r\n- Выявление таких проблем часто ложится на <b>тестирование</b>, а не на разработку.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Чем опасна XSS-уязвимость?</summary><div>\r\nXSS опасна тем, что позволяет выполнять произвольный JavaScript в браузере жертвы, в контексте доверенного сайта.\r\n<b>Типичный сценарий</b> - кража сессионных cookie (cookie сессии).\r\n<b>Механика:</b>\r\n- веб-приложение использует сессионную cookie для идентификации авторизованного пользователя;\r\n- наличие cookie = пользователь авторизован, значение cookie = идентификатор сессии на сервере.\r\n\r\n<b>Если злоумышленник внедрил JavaScript на страницу, этот код:</b>\r\n- выполняется у каждого посетителя страницы;\r\n- имеет доступ к document.cookie (если cookie не защищены).\r\n\r\n<b>Далее</b> код отправляет значение cookie на внешний сервер злоумышленника, например через AJAX-запрос: www.zloy-site.ru/stolen={cookie}\r\n\r\nЗапрос уходит с браузера жертвы, домен принадлежит злоумышленнику, значения параметров логируются. Получив cookie, злоумышленник подставляет её в свои запросы и получает доступ к аккаунту жертвы без пароля.\r\n\r\n<b>Ключевой момент:</b> атака происходит на стороне клиента, сервер жертвы ничего \"подозрительного\" не видит - он получает корректные запросы с валидной сессией.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Пример XSS атаки на демо сайте</summary><div>\r\nXSS ищут там, где пользователь может влиять на отображаемый контент. Если введённый текст возвращается на страницу - это потенциальная точка XSS.\r\n\r\n<b>Пример</b>: <a href=\"https://playground.learnqa.ru/demo/xss\" target=\"_blank\">https://playground.learnqa.ru/demo/xss</a>\r\n\r\nЭто каталог книг с поиском. Поиск по \"Рей Брэдбери\" работает штатно, введённый текст передаётся через GET-параметр q и отображается в URL:\r\n\r\n<img src=\"https://sun9-77.userapi.com/s/v1/ig2/Ax8IBVVhM6KSzlLg5Ng7qZXN52s6ZYLD73Dbu6ssan6ABBHOwaGDT8J-h1adyR68jc3LP77yVjF-c3-pFx8mqyba.jpg?quality=95&amp;as=32x9,48x14,72x21,108x31,160x46,240x69,360x103,480x137,540x154,640x183,720x206,1080x309,1280x366,1440x412,1560x446&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nЕсли ввести случайную строку (fwefewf), поиск ничего не находит, а введённый текст выводится в сообщении об ошибке:\r\n\r\n<img src=\"https://sun9-75.userapi.com/s/v1/ig2/tif8rfvXl-9rU1XcKtQwtpbZxadS9dzN4NuI3ewmPW8Lnismu_IJA6CW7sZWsNJv92mwbsvpJgr5aqOwpWvM33VF.jpg?quality=95&amp;as=32x7,48x10,72x15,108x22,160x33,240x50,360x74,480x99,540x111,640x132,720x149,1080x223,1280x264,1440x297,1560x322&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>Это ключевой момент:</b> пользовательский ввод рендерится на странице &gt; потенциальная XSS-точка.\r\n\r\nПопытка вставить &lt; script &gt;alert(123)&lt; /script &gt; через форму не проходит - форма валидируется и принимает только буквы и цифры:\r\n\r\n<img src=\"https://sun9-44.userapi.com/s/v1/ig2/kV8dGZ_jEtDS9wdgP9K4ozxRZTCK7O09yvVWsDwPcY08Dwv339jyyu7M4wX4ZMWsvR8bCHBNV7eCFfSOci79-nxu.jpg?quality=95&amp;as=32x6,48x9,72x13,108x20,160x29,240x43,360x65,480x87,540x98,640x116,720x130,1080x195,1280x231,1440x260,1560x282&amp;from=bu&amp;cs=1560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>Но валидация формы != защита от XSS.</b>\r\n\r\nЗначение поиска передаётся через GET-параметр q, например: playground.learnqa.ru/demo/xss?q=Рей+Брэдбери\r\n\r\nURL пользователь может изменить вручную, без ограничений формы. Если подставить туда JavaScript: https://playground.learnqa.ru/demo/xss?q=&lt; script &gt;alert(123)&lt; /script &gt; - код исполняется, появляется alert:\r\n\r\n<img src=\"https://sun9-20.userapi.com/s/v1/ig2/MRgxy77ogKKNuA11D1Zkcl3qKD557cGc3YcN1zX-ZCFsZt8upaqAdFoIB_YCl40wct-Un4LtHUtf6Ishc5ghWwv6.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x201,540x227,640x269,720x302,972x408&amp;from=bu&amp;cs=972x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>Причина:</b> значение q без экранирования вставляется в текст ошибки. Валидация формы есть, а экранирования вывода нет. Валидацию обошли через URL.\r\n\r\nАналогично можно вывести cookie: &lt; script &gt;alert(document.cookie)&lt; /script &gt;\r\n\r\nЗащита:\r\n- экранирование пользовательского ввода при выводе;\r\n- HttpOnly для cookie (JavaScript не сможет их прочитать);\r\n- комплексные меры, а не \"одна проверка на форму\".\r\n\r\nПри обнаружении XSS - передавать разработчикам для исправления.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Что тестировать QA?</summary><div>\r\n<b>1. Все точки ввода пользователя</b>\r\nБазовая предпосылка: любой ввод = потенциальный код.\r\nПроверяешь не форму, а путь данных.\r\nТочки:\r\n- поля ввода (поиск, логин, профиль, комментарии);\r\n- URL / GET-параметры;\r\n- POST-параметры;\r\n- заголовки HTTP (HTTP-заголовки: User-Agent, Referer, X-Forwarded-For);\r\n- cookies;\r\n- данные из БД, которые ранее вводил пользователь.\r\n<b>Контраргумент к частой ошибке:</b>\r\n\"Форма валидируется\" &gt; не аргумент. Валидация формы != экранирование вывода.\r\n<hr>\r\n<b>2. Где и как данные отображаются</b>\r\nXSS -  это всегда ошибка вывода, а не ввода.\r\n<b>QA проверяет:</b>\r\n- вывод в HTML;\r\n- вывод в HTML-атрибутах;\r\n- вывод внутри &lt; script &gt;;\r\n- вывод внутри &lt; style &gt;;\r\n- вывод в JS-переменных;\r\n- вывод в шаблонах (React, Vue, server-side rendering).\r\nОдин и тот же ввод безопасен в одном контексте и опасен в другом.\r\n<hr>\r\n<b>3. Отражённая XSS (Reflected XSS, отражённая XSS)</b>\r\n<b>Проверяешь:</b>\r\n- параметры URL;\r\n- ошибки валидации;\r\n- страницы «ничего не найдено»;\r\n- редиректы;\r\n- сообщения об ошибках.\r\n\r\n<b>Минимальный тест:</b>\r\n- вставленный ввод отражается ли на странице;\r\n- экранируется ли;\r\n- исполняется ли код.\r\n<hr>\r\n<b>4. Хранимая XSS (Stored XSS, сохранённая XSS)</b>\r\nСамая опасная.\r\n<b>QA проверяет:</b>\r\n- сохраняется ли ввод в БД;\r\n- отображается ли другим пользователям;\r\n- исполняется ли код при открытии страницы.\r\n\r\n<b>Особое внимание:</b>\r\n-профили;\r\n- комментарии;\r\n- описания;\r\n- админки (часто доверяют данным).\r\n<hr>\r\n<b>5. DOM-based XSS (DOM-ориентированная XSS)</b>\r\nТут сервер ни при чём.\r\n<b>Проверяешь:</b>\r\n- document.location\r\n- document.cookie\r\n- innerHTML\r\n- eval\r\n- setTimeout(string)\r\n- location.hash\r\n\r\nЕсли данные из URL &gt; JS &gt; DOM без очистки - это XSS.\r\n<hr>\r\n<b>6. Защитные механизмы</b>\r\nQA не \"верит\", QA проверяет.\r\n<b>Проверить:</b>\r\n- есть ли экранирование вывода;\r\n- включён ли HttpOnly для cookie;\r\n- SameSite для cookie;\r\n- Content Security Policy (CSP, политика безопасности контента);\r\n- нет ли inline-скриптов там, где не должно быть.\r\n<hr>\r\n<b>7. Ложные ощущения безопасности</b>\r\nОтдельно тестируешь и ломаешь мифы:\r\n- \"Мы используем фреймворк - он защищает\"\r\n- \"У нас только цифры в форме\"\r\n- \"Это внутренний сервис\"\r\n- \"Пользователь себе же навредит\"\r\n\r\nQA обязан доказать обратное или зафиксировать риск.\r\n</div></details>\r\n\r\n<hr>\r\n<h5>CSRF</h5>\r\n<b>CSRF (Cross-Site Request Forgery -межсайтовая подделка запроса)</b> ломает не код, а модель доверия браузера. Если пользователь авторизован, браузер автоматически прикладывает cookies, и внешняя страница может заставить его выполнить запрос к целевому сайту. \r\nВажно понять: CSRF возможен только там, где действие выполняется по факту запроса, без дополнительной проверки намерения пользователя. Для QA красный флаг - изменение состояния по GET-запросу, отсутствие CSRF-токенов, одинаковое поведение при запросе из приложения и извне. Типичная ошибка - путать CSRF с XSS. XSS - это выполнение кода, CSRF - это выполнение действия без ведома пользователя.\r\n\r\n<img src=\"https://sun9-7.userapi.com/s/v1/ig2/MVDKXXZZYnswmdl7LoVz8QwYuJArbySLvoyulHUdQI_9Ohf9HG6Hs_52dhqYlblcVp2j-ead9PhPVBpxWRQcd2Ol.jpg?quality=95&amp;as=32x17,48x25,72x38,108x57,160x84,240x126,360x188,480x251,540x283,640x335,720x377,1080x565,1200x628&amp;from=bu&amp;cs=1200x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<details>\r\n<summary>Как это работает</summary><div>\r\nCSRF основана на том, что браузер автоматически прикладывает cookie ко всем запросам. Сам запрос уходит на домен, где пользователь уже авторизован.\r\n\r\n<b>CSRF возможна из-за двух фактов, которые вместе дают дыру:</b>\r\n- браузер автоматически прикладывает cookie к запросам на домен, где пользователь уже авторизован;\r\n- сервер не проверяет, что запрос был инициирован самим пользователем.\r\n\r\n<b>Последовательность всегда одна и та же:</b>\r\n- пользователь авторизуется на целевом сайте;\r\n- браузер сохраняет сессионную cookie;\r\n- пользователь открывает чужой сайт или письмо;\r\n- браузер отправляет запрос к целевому сайту;\r\n- cookie прикладываются автоматически;\r\n- сервер считает запрос легитимным.\r\n<hr>\r\n<b>Основные виды:</b>\r\n<b>GET-CSRF</b> - действие выполняется по GET-запросу (критическая ошибка дизайна);\r\nGET-CSRF Используется, когда опасное действие доступно по GET.\r\n<b>Пример:</b> /deleteAccount?id=123\r\nБраузеру достаточно открыть ссылку или загрузить картинку.\r\n\r\n<b>POST-CSRF</b> - подмена POST-запроса через форму или JS;\r\nИспользуется чаще всего. Форма создаётся на стороне злоумышленника и отправляется автоматически.\r\n\r\n<b>CSRF через img / iframe / link</b> - браузер сам инициирует запрос;\r\nПодходит, если действие вызывается без тела запроса (или через query).\r\n\r\n<b>CSRF через auto-submit form</b> - форма отправляется автоматически при загрузке страницы.\r\nИспользуется, если CORS настроен слабо или SameSite=None.\r\n\r\n<b>Ключевая мысль:</b>\r\n<b>CSRF</b> - это атака на доверие сервера к браузеру, а не к пользователю.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Почему такие ошибки часто встречаются на веб-проектах?</summary><div>\r\nCSRF появляется не из-за \"кривого кода\", а из-за неявных допущений.\r\n\r\n<b>Разработчики:</b>\r\n- считают, что \"если есть cookie -  значит пользователь согласен\";\r\n- защищают форму, но не endpoint;\r\n- используют POST и считают, что этого достаточно;\r\n- полагаются на Referer / Origin (ненадёжно);\r\n- забывают, что браузер != пользователь.\r\n<hr>\r\n<b>Особенно часто CSRF живёт:</b>\r\n- в старых проектах;\r\n- во внутренних сервисах;\r\n- в админках;\r\n- в API, которые \"не для браузера\", но вызываются из него.\r\n\r\n<b>Типичное когнитивное искажение:</b> \"Если запрос пришёл с нашей сессией - значит его отправил пользователь»\" - Нет. Его отправил браузер.\r\n\r\n</div></details>\r\n\r\n<details>\r\n<summary>Чем опасна CSRF-уязвимость?</summary><div>\r\nCSRF позволяет управлять действиями пользователя, а не красть данные напрямую.\r\n\r\n<b>Последствия зависят от функциональности:</b>\r\n- смена email, пароля;\r\n- перевод средств;\r\n- оформление заказов;\r\n- изменение настроек безопасности;\r\n- привязка сторонних аккаунтов;\r\n- действия в админке <b>(особенно опасно).</b>\r\n\r\n<b>Важно:</b>\r\n- данные не крадутся напрямую;\r\n- жертва может вообще ничего не заметить;\r\n- сервер считает действия легитимными.\r\nCSRF = тихий контроль действий, а не кража данных.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Пример</summary><div>\r\n<b>Условие:</b>\r\n- есть сайт bank.test;\r\n- пользователь залогинен;\r\n- перевод денег выполняется POST-запросом:\r\nPOST https://bank.test/transfer\r\namount=1000\r\nto=attacker\r\n- CSRF-токена нет\r\n<hr>\r\n<b>1. Злоумышленник размещает страницу с формой:</b>\r\n&lt; html &gt;\r\n  &lt; body onload=\"document.forms[0].submit()\" &gt;\r\n    &lt; form action=\"https://bank.test/transfer\" method=\"POST\" &gt;\r\n      &lt; input type=\"hidden\" name=\"amount\" value=\"1000\" &gt;\r\n      &lt; input type=\"hidden\" name=\"to\" value=\"attacker\" &gt;\r\n    &lt; /form &gt;\r\n  &lt; /body &gt;\r\n&lt; /html &gt;\r\n- Никакого JavaScript-хакерства. Чистый HTML.\r\n- action &gt; https://bank.example/transfer\r\n- поля &gt; сумма, получатель\r\n- форма auto-submit при загрузке страницы.\r\n<hr>\r\n <b>2. Жертва заходит на страницу:</b>\r\n- пользователь уже авторизован в bank.test;\r\n- открывает эту страницу (сайт, письмо, реклама, iframe).\r\n<hr>\r\n<b>3. Что делает браузер</b>\r\n- загружает страницу;\r\n- автоматически отправляет форму;\r\n- прикладывает cookie от bank.test.\r\n<hr>\r\n<b>4. Что видит сервер</b>\r\n- корректный POST-запрос;\r\n- валидная сессия;\r\n- корректные параметры.\r\n\r\nПароль не вводился. Кнопка не нажималась.\r\nС точки зрения сервера - всё легально.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Что тестировать QA?</summary><div>\r\nQA проверяет не UI, а доверительную модель.\r\n\r\n<b>Перед тестированием задаёшь вопрос:</b> Можно ли выполнить это действие без явного участия пользователя?\r\n<hr>\r\n<b>Проверка руками</b> \r\n Для каждого state-changing действия:\r\n- попытаться повторить запрос из Postman / curl;\r\n- удалить CSRF-токен &gt; проверить реакцию;\r\n- отправить запрос без UI;\r\n- изменить метод (POST &gt; GET);\r\n- воспроизвести запрос из HTML-формы.\r\n<hr>\r\n<b>Проверка защиты</b> QA проверяет:\r\n- наличие CSRF-токена;\r\n- проверяется ли он на сервере;\r\n- уникален ли на сессию;\r\n- нельзя ли его угадать;\r\n- работает ли SameSite=Lax|Strict;\r\n- отклоняются ли запросы без Origin / Referer.\r\n<hr>\r\n<b>Красные флаги</b>\r\n- Это POST, значит безопасно;\r\n- Токен есть в форме, значит всё ок;\r\n- Это внутренний сервис;\r\n- Никто так не сделает.\r\n</div></details>\r\n\r\n<details>\r\n<summary>Что такое CSRF Token</summary><div>\r\n<b>CSRF Token</b> - это дополнительное доказательство намерения пользователя, которое сервер требует вместе с cookie, чтобы выполнить опасное действие.\r\n<b>CSRF Token</b> - это секрет, который сервер требует вместе с cookie, чтобы убедиться, что запрос инициирован самой страницей, а не браузером по чужой инициативе.\r\n\r\nЕсли cookie отвечает на вопрос \"кто ты?\",\r\nто CSRF-токен отвечает на вопрос \"ты правда хотел это сделать?\".\r\n\r\n<hr>\r\n<b>Зачем он вообще нужен</b>\r\n\r\n<b>Проблема CSRF в том, что:</b>\r\n- cookie отправляется браузером автоматически;\r\n- злоумышленник не может её прочитать;\r\n- но может заставить браузер отправить запрос.\r\n\r\nCSRF-токен решает это, добавляя в запрос секрет, который браузер сам придумать не может.\r\n<hr>\r\n<b>Базовый принцип работы</b>\r\n\r\n<b>Модель всегда одна и та же:</b>\r\n- Сервер генерирует случайный токен.\r\n- Токен привязывается к сессии (или пользователю).\r\n- Токен отдаётся клиенту.\r\n- Клиент обязан вернуть токен в каждом state-changing запросе.\r\n- Сервер сверяет токен &gt; выполняет действие или отклоняет запрос.\r\n\r\n<b>Ключевой момент:</b> Злоумышленник не может угадать или прочитать токен с другого сайта.\r\n\r\n<hr>\r\n<b>Где живёт CSRF Token</b>\r\nЭто важно для QA, тут много ошибок.\r\n\r\n<b>Токен может передаваться:</b>\r\n- в скрытом поле формы (&lt; input type=\"hidden\" &gt;);\r\n- в HTTP-заголовке (часто X-CSRF-Token);\r\n- в JS-переменной (для SPA).\r\nНо:\r\n- никогда только в cookie;\r\n- никогда без серверной проверки.\r\n\r\n<hr>\r\n<b>Почему CSRF Token работает</b>\r\n\r\nCSRF ломается, потому что:\r\n- браузер отправляет cookie сам;\r\n- злоумышленник управляет запросом, но не контентом чужой страницы.\r\n\r\n<b>CSRF-токен:</b>\r\n- доступен только странице целевого сайта;\r\n- не доступен стороннему сайту из-за Same Origin Policy (политика одного источника).\r\n\r\n<b>Злоумышленник может:</b>\r\n- отправить POST;\r\n- подставить любые поля;\r\n- но не может подставить корректный токен.\r\n</div></details>\r\n\r\n<hr>\r\n<h5>OWASP Top 10</h5>\r\n<b>OWASP Top 10</b> - это список 10 наиболее критических угроз безопасности веб-приложений, который составляет некоммерческая организация OWASP (Open Web Application Security Project) на основе анализа реальных атак и уязвимостей; это ключевой ориентир для разработчиков и специалистов по ИБ а так же QA, помогающий приоритизировать защиту и предотвращать распространенные атаки, такие как инъекции, ошибки аутентификации и небезопасная конфигурация.  <a href=\"https://owasp.org/www-project-top-ten/\" target=\"_blank\">Ссылка</a>\r\n\r\n<img src=\"https://sun9-65.userapi.com/s/v1/ig2/ILSmKzWI7PWm3UunqFqObbv57ULTN9EXtl4kvRvBd-G5NnyTaUo8SXPvKeKlEDHytsyIymlprCuZ4gEpxDeCtJp1.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x133,360x200,480x267,540x300,640x356,720x400,900x500&amp;from=bu&amp;cs=900x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<details>\r\n<summary>Для чего нужен OWASP Top 10</summary><div>\r\n<b>- Справочник по безопасности:</b> Это общепризнанный стандарт и руководство для понимания самых опасных рисков, с которыми сталкиваются веб-приложения, сфокусированный на наиболее распространенных и критических уязвимостях. \r\n<b>- Регулярное обновление:</b> Список периодически пересматривается и обновляется, отражая актуальные тренды и новые угрозы в кибербезопасности. \r\n<b>- Практическая польза:</b> Он предоставляет разработчикам и компаниям понятные рекомендации, как устранять эти уязвимости и строить более защищенные приложения. \r\n</div></details>\r\n\r\n<details>\r\n<summary>Категории угроз OWASP Top 10</summary><div>\r\n<b>Основные категории угроз (примеры, могут варьироваться в разных версиях):</b>\r\n<b>- Инъекции:</b> Атаки, при которых вредоносные данные внедряются в приложение (например, SQL-инъекции). \r\n<b>- Нарушение контроля доступа:</b> Ошибки, позволяющие неавторизованным пользователям получить доступ к конфиденциальным функциям или данным. \r\n<b>- Небезопасная конфигурация:</b> Ошибки в настройках сервера или приложения. \r\n<b>- Использование компонентов с известными уязвимостями:</b> Применение устаревших или небезопасных библиотек. \r\n<b>- Ошибки аутентификации:</b> Уязвимости в механизмах входа и управления сессиями. \r\n</div></details>\r\n\r\n<details>\r\n<summary>Что тестировать QA?</summary><div>\r\n<b>OWASP Top 10 нужен QA</b> не как \"требование безопасности\", а как практический чеклист того, что обязательно проверять в веб-приложении. Если игнорировать его, ты пропускаешь самые частые и критичные уязвимости.\r\n\r\n<b>QA использует его, чтобы:</b> Понимать типичные точки риска. Каждая категория из Top 10 - это конкретная проблема: SQLi, XSS, CSRF, неправильная авторизация, утечка данных и т.д. Без этого QA тестирует наугад.\r\n\r\n<b>Составлять тест-кейсы с \"интеллектом\":</b> Ты не просто проверяешь форму или кнопку, а задаёшь вопросы: \"Что произойдет, если сюда попадут неожиданные данные?\", \"Можно ли изменить запрос извне?\", \"Что если авторизация сломана?\".\r\n\r\n<b>Оценивать критичность багов:</b> Если баг связан с одной из категорий Top 10, это сигнал, что ошибка может быть катастрофичной в реальном мире, даже если UI выглядит нормально.\r\n\r\n<b>Документировать риски:</b> В отчетах QA можно ссылаться на OWASP, показывая менеджеру или заказчику, что обнаруженная уязвимость попадает в Top 10 и требует приоритетного исправления.\r\n\r\n<b>Согласовывать понимание с security-командой:</b> QA и pentest часто используют один язык: OWASP Top 10 — это общий стандарт, который позволяет обсудить баг без длинных объяснений.\r\n\r\n<b>Важно понимать:</b> OWASP Top 10 не учит взламывать, он учит QA распознавать условия, в которых уязвимость возможна. Твоя задача как QA - находить такие \"точки входа\" и фиксировать их, а не эксплуатировать.\r\n<hr>\r\n<b>Список проверок:</b>\r\n<b>1. A01 - Broken Access Control (Нарушение контроля доступа)</b>\r\nQA проверяет, что пользователи не могут делать то, что им не положено. Это проверка прав доступа на всех уровнях: страницы, API, действия. Примеры: пользователь с ролью «гость» не должен удалять товары, менять данные других, видеть чужие отчёты. Проверяется через прямые URL, API-запросы и обход интерфейса.\r\n<hr>\r\n<b>2. A02 - Cryptographic Failures / Sensitive Data Exposure (Слабое шифрование, утечка данных)</b>\r\nQA проверяет, что конфиденциальные данные не передаются и не хранятся в открытом виде. Примеры: пароли, токены, персональные данные, кредитки. Проверяется: использование HTTPS, хеширование паролей, отсутствие секретов в URL, логах, HTML-коде.\r\n<hr>\r\n<b>3. A03 - Injection (Инъекции)</b>\r\nСюда входит SQLi, LDAPi, Command Injection и др. QA проверяет, что ввод пользователя не ломает логику сервера или базы. Фокус на: формы, поля поиска, API, query-параметры, cookie, заголовки. Любой \"неожиданный\" символ не должен ломать систему или возвращать внутренние ошибки.\r\n<hr>\r\n<b>4. A04 - Insecure Design / Security Misconfiguration (Неправильная конфигурация и ошибки проектирования)</b>\r\nQA проверяет, что система защищена по умолчанию: отключены лишние сервисы, админки недоступны, небезопасные заголовки безопасности включены (CSP, X-Frame-Options). Часто это про \"продукт выдан как есть\" - QA фиксирует то, что может быть сразу опасно.\r\n<hr>\r\n<b>5. A05 - Security Misconfiguration (Дублируется с A04, в старых версиях OWASP были нюансы)</b>\r\nQA проверяет неправильные права доступа к файлам, директориям, API, серверам, чтобы никто не мог скачать / изменить что-либо без прав.\r\n<hr>\r\n<b>6. A06 - Vulnerable and Outdated Components (Уязвимые компоненты)\r\n</b>\r\nQA фиксирует, что приложение не использует устаревшие библиотеки с известными уязвимостями, особенно если это фронт/бэкэнд или сторонние плагины. Проверяется через версию библиотек, NPM/PIP/Gemfile, CVE-отчёты.\r\n<hr>\r\n<b>7. A07 - Identification and Authentication Failures (Ошибки идентификации и аутентификации)</b>\r\nQA проверяет, что логин, сессии, токены работают корректно. Примеры: невалидные пароли не дают доступ, нельзя обойти 2FA, нельзя захардкодить сессию. Сюда входит тестирование куков, JWT, session fixation, brute-force защита.\r\n<hr>\r\n<b>8. A08 - Software and Data Integrity Failures (Нарушение целостности данных и ПО)</b>\r\nQA проверяет, что данные не изменяются посторонними способами. Примеры: payload в API не ломает объект, файлы не подменяются, обновления ПО подписаны. Особенно важно для финансовых систем и интеграций.\r\n<hr>\r\n<b>9. A09 - Security Logging and Monitoring Failures (Ошибки логирования и мониторинга)</b>\r\nQA фиксирует, что критичные действия и ошибки логируются корректно, чтобы можно было обнаружить попытку взлома. Примеры: неудачные логины, удаление ресурсов, изменение прав. Не тестируется глубоко как SIEM, но QA проверяет, что события фиксируются и видны.\r\n<hr>\r\n<b>10. A10 - Server-Side Request Forgery (SSRF) / Insufficient Logging (в разных версиях OWASP)</b>\r\nQA проверяет, что сервер не делает запросы туда, куда не должен, и что такие попытки фиксируются. Примеры: пользовательский URL не может вызвать внутренний API или сервис, отсутствует обход ограничений.\r\n</div></details>","path":"-"}},{"title":"Базовые сетевые знания: DNS, DHCP, NAT, firewall","data":{"code":"-","description":"<h5>DNS</h5>\n<b>DNS (Domain Name System, система доменных имён)</b> - это телефонная книга интернета: переводит доменное имя в IP-адрес. Серверу и браузеру не нужны имена, им нужны IP.\n<b>Как работает (упрощённо, но правильно):</b>\nБраузер спрашивает: \"Где находится api.site.com?\" &gt; DNS отвечает: \"Это IP 1.2.3.4\" &gt; Браузер идёт по IP и устанавливает соединение.\nЕсли DNS не сработал - приложение не существует.\n<b>DNS</b> - по сути своей это сервер который хранит ip адреса доменов для передачи их клиенту.\n\n<img src=\"https://sun9-2.userapi.com/s/v1/ig2/5_qwP629PUm7tOUj3yXPOkd3qyDrW21sCbcMD4IvHf3W6-4XBaHTKsHnNC5gepNoJaZQeo1UxDXerjTtT2WYGVqD.jpg?quality=95&amp;as=32x14,48x21,72x32,108x48,160x71,240x107,360x160,480x213,540x240,640x284,720x320,765x340&amp;from=bu&amp;cs=765x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Почему это важно для QA</b>\nПроблемы, которые выглядят как баги приложения, часто - DNS.\n<b>Типовые симптомы:</b>\n- сайт \"иногда не открывается\";\n- API работает по IP, но не по домену;\n- staging и prod путаются;\n- редиректы на старые домены.\n\n<b>Что тестировать QA</b>\n<b>Подводка:</b> QA проверяет не DNS как сервис, а зависимость приложения от DNS.\n- домен резолвится корректно;\n- нет захардкоженных IP;\n- корректная работа с поддоменами;\n- HTTPS-сертификат соответствует домену;\n- кэш DNS не ломает обновления.\n\n<hr>\n<h5>DHCP</h5>\n<b>DHCP (Dynamic Host Configuration Protocol, протокол динамической настройки хоста)</b> - это механизм, который выдаёт устройству сетевые настройки автоматически.\n\n<img src=\"https://sun9-29.userapi.com/s/v1/ig2/-88vofhhrIvx460tIC-EaJAb47OqQ7vJOlfiNvbzCgUWoTFRNOGpUMEZ7RFfzMSiN07yHJZQKB-t7hMUlDjD3UBx.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720,1440x810,1920x1080&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Без DHCP:</b>\n- вручную IP;\n- вручную шлюз;\n- вручную DNS.\n\n<b>Как работает</b>\nПри подключении к сети устройство получает:\n- IP-адрес;\n- маску сети;\n- шлюз;\n- DNS-сервер.\n- Для пользователя это \"просто заработал интернет\".\n\n<b>DHCP</b> - это по сути сервер который определяет настройки подключения к интернету/локальной сети для клиента (компьютера). \n\n<b>Почему QA это вообще должен знать</b>\nDHCP ломается &gt; сеть есть физически, но логически её нет.\n<b>Симптомы:</b>\n- приложение \"не подключается\";\n- сервер \"не виден\";\n- локальный стенд работает у одного QA и не работает у другого.\n\n<b>Что тестировать QA</b>\n<b>Подводка:</b> QA не чинит DHCP, но должен распознать проблему.\n- приложение доступно в другой сети?\n- работает ли через мобильный интернет?\n- меняется ли поведение при смене сети?\n- одинаково ли ведёт себя на VPN?\n\n<hr>\n<h5>NAT</h5>\n<b>NAT (Network Address Translation, трансляция сетевых адресов)</b> - это маскарад для IP-адресов. Внутри сети - частные IP. Снаружи - один публичный IP.\n\n<img src=\"https://sun9-86.userapi.com/s/v1/ig2/lZ46uIB2R7jAfK4hP1BnZ6wtJEtd8k6JPN0u6QQ5LQzO7UVLhapmZc8YaJ6qf3FwqWce9_6yP4TLX46fSfzBh9xg.jpg?quality=95&amp;as=32x23,48x34,72x51,108x77,160x114,240x171,360x256,480x342,540x384,640x456,720x513,1024x729&amp;from=bu&amp;cs=1024x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>Как работает</b>\n- устройство с IP 192.168.1.10 выходит в интернет;\n- NAT подменяет исходный IP на публичный;\n- ответы возвращаются обратно.\n- Снаружи все выглядят как один адрес.\n\n<b>Почему это важно для QA</b>\n<b>Типовые проблемы:</b>\n- привязка сессий к IP;\n- rate limit по IP;\n- блокировки \"по IP пользователя\".\n- Для сервера 100 пользователей за NAT = 1 IP.\n\n<b>Что тестировать QA</b>\n<b>Подводка:</b> QA проверяет ошибочные допущения про IP.\n- нет ли логики \"1 IP = 1 пользователь\";\n- корректен ли rate limit;\n- корректна ли работа антифрода;\n- не ломается ли авторизация при смене IP.\n\n<hr>\n<h5>Firewall </h5>\n<b>Firewall (Firewall (межсетевой экран)</b> - это фильтр трафика по правилам.\n<b>Он решает:</b>\n- что можно;\n- что нельзя;\n- куда можно;\n- откуда нельзя.\n\n<img src=\"https://sun9-88.userapi.com/s/v1/ig2/eMujOXpaKY4_VklgHZjOpc39KgG5UhAiZRxZgJB8JLu_SvHFV8_yw7cpSl1DSrGlAQiahJSKrzvCum4o5_yKlbmM.jpg?quality=95&amp;as=32x18,48x26,72x40,108x59,160x88,240x132,360x198,480x264,540x297,640x352,720x396,764x420&amp;from=bu&amp;cs=764x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Как работает</b>\nКаждый сетевой пакет проверяется по правилам:\n- IP;\n- порт;\n- протокол;\n- направление.\n- Запрещено &gt; пакет отброшен.\n- Разрешено &gt; пакет проходит.\n\n<b>Firewall</b> - по сути сущность которая следит за входящим и исходящим трафиком. И исходя из условий настроек может пропустить трафик (входящий или исходящий).\n\n<b>Почему QA сталкивается с firewall постоянно:</b> Firewall - главный источник \"мистических\" багов.\n\n<b>Симптомы:</b>\n- \"у меня работает, у тебя нет\";\n- API падает по таймауту;\n- работает локально, но не на стенде;\n- падает только в корпоративной сети.\n\n<b>Что тестировать QA</b>\n<b>Подводка:</b> QA тестирует поведение при ограничениях, а не firewall.\n- доступность портов;\n- корректные таймауты;\n- понятные ошибки;\n- работа через VPN / прокси;\n- корректные retry-механизмы.\n\n<hr>\n<h5>Как это всё связано (важно!)</h5>\n<b>Последовательность всегда такая:</b>\n- DNS - находим куда идти\n- DHCP - понимаем откуда мы идём\n- NAT - как нас видит внешний мир\n- Firewall - пускают ли нас вообще\n\nЕсли что-то сломалось выше - ниже даже не начнётся.\n<hr>\n<b>P.S:</b> для более глубокого анализа по работе сетевых технологий (которые по сути своей не относятся к QA) можете ознакомиться отдельно. Там много обширных тем и дискуссий, которые займут очень много времени на изучение. По сути для этого существует отдельная профессия как \"Системный Администратор\" / \"Специалист ИТ\". ","path":"-"}}]},{"header":"QA инструменты","links":[{"title":"Swagger","data":{"code":"-","description":"Swagger - это инструмент, который позволяет разработчикам описывать, документировать и тестировать API. Он облегчает взаимодействие с веб-службами, предоставляя понятное описание и возможность протестировать запросы и ответы напрямую в интерфейсе. Так же автогенерируемая документация к API, построенная на OpenAPI Specification.\n\n<details>\n<summary>Для чего нужен Swagger</summary><div>\n1. Swagger показывает:\n- какие эндпоинты есть,\n- какие параметры принимает запрос,\n- какие типы данных ожидаются,\n- какие обязательные и необязательные поля,\n- какие коды ответов возвращаются,\n- структуры тела запросов/ответов.\n\n2. Swagger позволяет прямо в браузере отправлять запросы\nЭто значит:\n- можно отправить GET/POST/PUT/DELETE прямо в Swagger UI,\n- менять параметры,\n- проверять обязательность полей,\n- тестировать реакции API на разные payload.\n\n3. Swagger сам ловит несоответствия данных\nСразу видно:\n- валидацию,\n- ограничения,\n- обязательные параметры,\n- схемы объектов.\n\n4. Swagger показывает все ошибки прямо в интерфейсе\nНапример:\n- 400 Bad Request\n- 401 Unauthorized\n- 403 Forbidden\n- 404 Not Found\n- 500 Internal Server Error\n\n5. Swagger часто используется в разработке микросервисов\n- Каждый микросервис генерирует свой Swagger.\n\n6. Swagger помогает делать API-тесты быстрее, чем Postman\nPostman - тяжёлая артиллерия.\nSwagger - \"пистолет на поясе\".\nС помощью Swagger QA быстро:\n- проверяет работоспособность эндпоинта,\n- смотрит контракты,\n- изучает структуры данных,\n- валидирует вход/выход.\n</div></details>\n<hr>\n<b>Зачем Swagger для QA?</b>\nКоротко:\n- Чтобы понимать API так, как его видит разработчик.\n- Чтобы тестировать API быстрее.\n- Чтобы видеть контракты и баги валидации.\n- Чтобы сравнивать документацию с фактическим поведением API.\n<hr>\n<details>\n<summary>Откуда берётся SWAGGER и как его получает QA</summary><div>\nДля QA по сути работа со SWAGGER'ом подразумевает разбор API запросов которые описаны в этом документе. Документ предоставляют разработчики. Исходя из этого документа QA специалист реализует API тестирование в Postman, или частичные проверки прям в Swagger.\nЕсть три распространённых сценария:\n<b>Сценарий 1</b>: Бэк развернул Swagger-UI на Dev/Staging\nРазработчики поднимают Swagger UI вместе с сервисом.\nНапример:\nhttps://dev.api.company.kz/swagger\nhttps://staging.company.kz/api/docs\nQA получает:\n- ссылку\n- тестовый токен\n- список ограничений (например, не ломать продовые данные)\n- иногда Postman коллекцию для сложных запросов\nЭто стандарт. В 90% команд так.\n\n<b>Сценарий 2</b>: Swagger отдаётся как JSON-файл\nЕсли UI не развернут, разработчик присылает:\n- openapi.json\n- openapi.yaml\nQA открывает это в Swagger Editor:\n<a href=\"https://editor.swagger.io/\" target=\"_blank\">https://editor.swagger.io/</a>\nИ работает как обычно.\n\n<b>Сценарий 3</b>: Swagger встроен в DevTools админки\nНекоторые проекты дают Swagger прямо в админке:\nНапример:\nАдминка  &gt; API Docs &gt; Swagger UI\nВстречается в хороших проектах с микросервисами.\n</div></details>\n<hr>\n<details>\n\t<summary>SWAGGER пример</summary><div>\nТестовые данные:\n<a href=\"https://petstore.swagger.io/\" target=\"_blank\">petstore.swagger.io</a>, представляет собой пример документации API, созданный с помощью фреймворка Swagger.\n<hr>\n<a href=\"https://petstore.swagger.io/\" target=\"_blank\">petstore.swagger.io</a> - это не настоящий сайт зоомагазина. Эта страница демонстрирует, как можно использовать Swagger для документирования API. Она использует тему зоомагазина, чтобы продемонстрировать различные функции фреймворка.\n<hr>\nОсновная цель Swagger - это документирование API. Основная цель Postman - это тестирование. В swagger, в отличие от postman нельзя писать автотесты, создавать коллекции, переменные, запускать run-ы и т д.\n<hr>\nИ так, на сайте мы можем работать с животными, с заказами и с пользователями, а также у нас есть описание моделей разных сущностей, с которыми мы будем работать.\n<img src=\"https://sun9-82.vkuserphoto.ru/s/v1/ig2/9_H5-l1DF7NvZJk8IE6b4kuE2f2cVPcUzdrjyEvZsuylm2kh9iuvva9jBpba8zsJLzNg6arbKc0J42Ph7mz9T3w7.jpg?quality=95&amp;as=32x25,48x38,72x57,108x85,160x126,240x190,360x284,480x379,540x427,640x506,720x569,1080x853,1239x979&amp;from=bu&amp;cs=1239x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте развернем модель животного (pet) и посмотрим что там есть. У pet есть id c типом integer (число), также pet относится к какой-то категории (Category) У Category есть id с типом  integer (число) и есть название категории (name) c типом string (строка). Также у животного есть имя (name) c типом String (строка)\n<img src=\"https://sun9-79.vkuserphoto.ru/s/v1/ig2/3ba1IHfZi8NhkAh3zyzUi1S8CKCVcZk0FFIipouzin_0HKvr0_22O4ngsKTbQYgcoRbzcFKdQL8xsGxOb6_Q4NV7.jpg?quality=95&amp;as=32x25,48x37,72x56,108x84,160x125,240x187,360x280,480x374,540x420,569x443&amp;from=bu&amp;cs=569x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь давайте попробуем добавить новое животное в магазин через метод  POST /pet где мы будем передавать данные в теле body  при помощи json.\n<img src=\"https://sun9-71.vkuserphoto.ru/s/v1/ig2/R64iArcMqJfNij3s7_DiI6thjWZ-TfYHhAdK7iqYCzq80X12DwD65E3xFMjbtF1ybeZ7ihJ1NhOg4jl02IjYHeNW.jpg?quality=95&amp;as=32x22,48x32,72x48,108x73,160x108,240x161,360x242,480x323,540x363,640x430,720x484,1080x726,1231x828&amp;from=bu&amp;cs=1231x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажимаем на Try it out\n<img src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/PVOg3iSpdPt3DzP-iAwRdB4_hAKHKVK82RsCh_plEyqTGbCrzD95uP0J1ILw4N2wzUM_2JJByDzgqNQuNksEqkHW.jpg?quality=95&amp;as=32x21,48x32,72x48,108x73,160x107,240x161,360x242,480x322,540x363,640x430,720x484,1080x726,1222x821&amp;from=bu&amp;cs=1222x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь в json указываем те данные, которые мы хотим, чтобы были у нашего животного. Пусть id животного будет 555777\nId категории будет 4444, название категории будет  \"dogs\". Имя животного будет \"Jack\", остальные атрибуты оставляем без изменений и нажимаем на \"Execute\"\n<img src=\"https://sun9-48.vkuserphoto.ru/s/v1/ig2/Y4--zwj54jLStu1eFmf9JtNY5iXBCoMkgNPfNFNw-7qbBMKObXWz3ErUnx1eJGLlrbBAM5KqW4CHJwcNKFP7kH3f.jpg?quality=95&amp;as=32x19,48x29,72x43,108x64,160x96,240x143,360x215,480x287,540x322,640x382,720x430,1080x645,1206x720&amp;from=bu&amp;cs=1206x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте посмотрим что нам вернулось. Нам вернулся запрос, отправленный при помощи curl (curl позволяет нам обращаться к серверу через командную строку). Нам вернулся Request URL на который мы обращались, чтобы отправить наш запрос.  Нам вернулся код ответа 200 — это значит что запрос выполнился успешно, вернулось тело ответа в виде json. И также вернулся список заголовков (headers)\n- <b>Server</b>: Информация о сервере, обрабатывающем запрос.\n- <b>Date</b>: Дата и время создания запроса или ответа.\n- <b>Content-Type</b>: Тип контента, передаваемого в теле запроса или ответа (например, текст, изображение, JSON)\n<img src=\"https://sun9-79.vkuserphoto.ru/s/v1/ig2/XWzhpmVzfw9pjDjPeJkiFvI0cS4SLYfkfL0yEPQAZXfYx5yaROdjsyROEaqWubzIuiVMrhxk6qhfhNRoPH5PflAf.jpg?quality=95&amp;as=32x27,48x41,72x62,108x93,160x137,240x206,360x309,480x412,540x464,640x550,720x619,1080x928,1209x1039&amp;from=bu&amp;cs=1209x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте попробуем создать еще одно животное, но уже через curl. Скопируем тот curl, который нам вернулся, поменяем id животного на 555778, id и название категории оставим неизменными, а имя животного изменим на «Barsik» Вставляем наш запрос в командную строку ( на mac это будет terminal)\n<img src=\"https://sun9-88.vkuserphoto.ru/s/v1/ig2/-OFq-aZODyRee1TiyPiF2HJPbVQOpa4YwI7Gpd6Pkp-q8Fr5Mzt5s_NyDGD97wEvkZVadobucCaV0jbFjjTahgGh.jpg?quality=95&amp;as=32x26,48x39,72x59,108x89,160x132,240x197,360x296,463x381&amp;from=bu&amp;cs=463x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nи нажимаем на Enter и видим что нам вернулся json c новым животным\n<img src=\"https://sun9-1.vkuserphoto.ru/s/v1/ig2/ziX8mf6NH-iAUvHKEWbrabxXEbFqykDaose26nLf6QlCfuQfbRGzHSn9Mkg_xeQspfm02uWAc5_f8UsoD9LgVMr-.jpg?quality=95&amp;as=32x18,48x26,72x39,108x59,160x88,240x132,360x197,480x263,540x296,640x351,653x358&amp;from=bu&amp;cs=653x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте в этом убедимся и найдем оба наших животных при помощи метода get /pet/{petID}\n<img src=\"https://sun9-47.vkuserphoto.ru/s/v1/ig2/I8clPDU9y85E3Ih0ovb4BrRRzV8UzYYjuu5Vud1K3IZEXb2B2Lu4ugHD8jicBsGgz6sEtx5MPtGJnir1faPFVEu-.jpg?quality=95&amp;as=32x31,48x46,72x69,108x104,160x154,240x231,360x347,480x462,540x520,640x617,720x694,986x950&amp;from=bu&amp;cs=986x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДля этого нажмем на \"Try it out\"\n<img src=\"https://sun9-81.vkuserphoto.ru/s/v1/ig2/_mMn4Fqq8nUj6PtbhKGEUNFu_rwrMUQ6Is7HizJiKiwnWCmC5-9GZzhyne4LPYuMgUNQO2ljUfxm_vL9-Gz80ff5.jpg?quality=95&amp;as=32x31,48x46,72x69,108x104,160x154,240x231,360x346,480x461,540x519,640x615,720x692,986x948&amp;from=bu&amp;cs=986x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВведем в поле petID id нашего первого животного 555777, которое мы добавляли через swagger. Название ( path) означает, что это path параметр, он передается в строке. Подробнее обо всех параметрах, мы будем говорить в следующих уроках, посвященных postman. И нажимаем на execute.\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/tJ5ZmFtYQdcL8S0cIiGFN-r-0uzysQUfwslE39nn037Rb9QDC3NZVJ6rcYfJvkyF5e8FdsuyYt56g69OOLDqyvpg.jpg?quality=95&amp;as=32x32,48x48,72x72,108x108,160x160,240x240,360x359,480x479,540x539,640x639,720x719,988x986&amp;from=bu&amp;cs=988x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ как мы видим нам вернулся 200 код ответа ( это значит что запрос выполнен успешно) с телом ответа, в котором будут данные наши животного с id 555777\n<img src=\"https://sun9-16.vkuserphoto.ru/s/v1/ig2/_vYlnyMsS9jLMR9GaH9Io_WcUV6eQ2lMd_Eqj9yiHWQjy1VLZLTLxvf0Y3oVXWUSePgqNGvoVbzu7_7NZPBb94cf.jpg?quality=95&amp;as=32x23,48x34,72x52,108x78,160x115,240x172,360x259,480x345,540x388,640x460,720x517,1034x743&amp;from=bu&amp;cs=1034x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте теперь аналогично сделаем для нашего животного которое мы создавали при помощи curl c id 555778\n<img src=\"https://sun9-81.vkuserphoto.ru/s/v1/ig2/krT1VkQXKniK_ep2Bl7L7LFJr8kDW3tfbNA9KKZNh6ojGH4Aqq0zegyALz7rAowdGCjmq-YNM7j0O_kf2FGIWMXo.jpg?quality=95&amp;as=32x13,48x19,72x29,108x43,160x64,240x96,360x145,480x193,540x217,640x257,720x289,1050x422&amp;from=bu&amp;cs=1050x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ как мы видим и здесь нам вернулся 200 код ответа ( это значит что запрос выполнен успешно) с телом ответа, в котором будут данные нашего животного с id 555778, которое мы добавляли через curl\n<img src=\"https://sun9-23.vkuserphoto.ru/s/v1/ig2/e8DtNArTS3qpzNmilJwkgSjX3X6KqD-xbw8GQVRRd_oWQvrZ2P85UuA-SIliKjYCHnYu57ezQ27pDV0W-b6woyBU.jpg?quality=95&amp;as=32x37,48x55,72x82,108x123,160x183,240x274,360x411,480x548,540x616,640x730,720x821,1043x1190&amp;from=bu&amp;cs=1043x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>","path":"-"}},{"title":"Postman","data":{"code":"-","description":"<p style=\"color: red\">Внимание, для полноты понимания Postman необходимо предварительно ознакомится со Swagger в предыдущей теме.</p>\nPostman - это популярный инструмент для работы с API (Application Programming Interface), который позволяет отправлять и тестировать HTTP-запросы, анализировать ответы сервера и автоматизировать тестирование. Он предоставляет удобный графический интерфейс для создания, отладки и документирования API, а также поддерживает автоматизированные тесты, написанные на JavaScript.  \n\n<details>\n\t<summary>Интерфейс Postman</summary><div>\n\t<img src=\"https://sun9-43.vkuserphoto.ru/s/v1/ig2/U8xZqgANcOg01Jr-dLigkufY5DNseGcsmUTHYSyGWtlAri1tbTBjlKf2tg5faAeLLroPoTtXaXBheTVriFIPgnZ3.jpg?quality=95&amp;as=32x20,48x31,72x46,108x69,160x102,240x153,360x229,480x306,540x344,640x408,720x459,1080x688,1280x816,1440x918,1920x1224&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nИ так, сам интерфейс postman похож на интерфейс браузера, того же Chrome.\n<hr>\n<b>1) HOME</b> показывает список рабочих пространств, к которым вы недавно обращались. Это позволяет вам быстро вернуться к работе над проектами, над которыми вы уже работали. Также вкладка Home содержит ссылку на Postman Learning Center, где вы можете найти обучающие материалы, документацию и другие ресурсы, которые помогут вам начать работу с Postman.\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/TMnbex9t5D2TWWPkf_bdxDpuYbBieJ4j-Tm7J74OfypLwbGXdfcNiFes4XE3yr07g0FuJYn4MFf4G3jggzP_EW1k.jpg?quality=95&amp;as=32x21,48x31,72x46,108x69,160x103,240x154,360x231,480x308,540x347,640x411,720x462,1080x694,1280x822,1440x925,1954x1255&amp;from=bu&amp;cs=1954x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>2) Workspaces</b> - Вкладка workspaces:\n- Организует ваши API-проекты.\n- Группирует коллекции, среды и другие элементы.\n- Помогает вам работать с другими людьми.\n- Позволяет делиться своими проектами.\n- Управляет вашими настройками\n<img src=\"https://sun9-83.vkuserphoto.ru/s/v1/ig2/Ooz0F8DJLRmPCt_yR8_ykKFu8dEkHM3g8GXRzVFx1zppga590m7G_igZV6DWQWqugs5hk8qYRSrxU3cixttxGkB6.jpg?quality=95&amp;as=32x22,48x33,72x50,108x75,160x111,240x166,360x249,480x332,540x373,640x443,681x471&amp;from=bu&amp;cs=681x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>3) New</b> - При клике по NEW мы можем создать workspace, коллекцию, enviroment, http запрос и другие сущности, которые есть в postman\n<img src=\"https://sun9-18.vkuserphoto.ru/s/v1/ig2/G4nWiTyCSBtqGztM76RasAj1Cpf-ZL3efivPcV5w_CBblQEyyMWox0LUjrPXYPsSruAgwfkENbg7mOJlJ58EOc6q.jpg?quality=95&amp;as=32x26,48x40,72x59,108x89,160x132,240x198,360x297,480x397,540x446,640x529,720x595,1041x860&amp;from=bu&amp;cs=1041x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>4) Import</b>\nВкладка import позволяет Импортировать:\n- Коллекции\n- Запросы\n- Среды\n- Тесты\n- Данные\n\nИз разных источников:\n- Файлов (JSON, Postman Collection v1, HAR)\n- URL-адресов\n- GitHub\n- Postman Public Workspace\n<img src=\"https://sun9-86.vkuserphoto.ru/s/v1/ig2/ww3afY6eJcN1As992eBp4wgtrWY-WMemuyh6p0Nsx7ulwAm-I7BEPsOl1PyiEN1XAOSE32GsEHuAqV1pLgaQcIyz.jpg?quality=95&amp;as=32x25,48x38,72x57,108x86,160x127,240x191,360x287,480x382,540x430,640x510,720x574,1080x860,1126x897&amp;from=bu&amp;cs=1126x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>5) Search</b> - Вкладка поиска в postman позволяет\n- Находить коллекции, запросы, среды, папки и переменные.\n- Фильтровать результаты поиска по типу, имени, описанию и тегам.\n- Сохранять поисковые запросы для быстрого доступа.\n<img src=\"https://sun9-43.vkuserphoto.ru/s/v1/ig2/-cO3VT6yyrv20XAp8NnQaX7o6xejihiKALPcETN5j08vDypKdWffVmQauYKhagL65TNPbZY-VtozESVLopudf1ZQ.jpg?quality=95&amp;as=32x16,48x25,72x37,108x55,160x82,240x123,360x185,480x246,540x277,640x329,720x370,1080x554,1198x615&amp;from=bu&amp;cs=1198x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>6) Настройки postman</b> - в настройках postman мы можем поменять язык, отображения элементов интерфейса, шрифты и т д, например можем поменять тему postman на темную.\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/JFPdvy1vSboSc8NdFL2bzk-JcyFq4gvzPExPdoOSUjSgPTQiWII0TyMLcUMKlxX4K8VbX_blZvrU9ODf039uBqWf.jpg?quality=95&amp;as=32x27,48x40,72x60,108x90,160x133,240x200,360x300,480x400,540x450,640x533,720x600,1080x899,1268x1056&amp;from=bu&amp;cs=1268x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>7) Настройки профиля</b> - В настройках профиля, можно поменять имя, пароль, настроить двухфакторную аутентификацию и т.д.\n<img src=\"https://sun9-49.vkuserphoto.ru/s/v1/ig2/0M3bk9AKRsfR4AIfEQl20Wub0Jz6X-w2Ontn03DlFNPAKyLsE6s6ZQJSlUX2AO6vs1ngVrqY5j9iQpmbqrIvROJZ.jpg?quality=95&amp;as=32x30,48x46,72x69,108x103,160x152,240x228,360x343,480x457,540x514,620x590&amp;from=bu&amp;cs=620x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>8) Выбор Environment</b>-  Мы можем выбрать envoroment, которые мы создали, из списка\n<img src=\"https://sun9-24.vkuserphoto.ru/s/v1/ig2/w4g_TJtQnV5MLehR8iOllGIvqoecseSt1YskyRntg9cwOgZITdCAStcotyVsgGBcHm55mIG2kS7wSaz0G_dwVbnS.jpg?quality=95&amp;as=32x30,48x46,72x68,108x103,160x152,240x228,360x342,480x456,510x485&amp;from=bu&amp;cs=510x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>9) Просмотр Environment</b> - При клике на глазик мы можем посмотреть какие переменные мы создали для выбранного нами environment-а\n<img src=\"https://sun9-70.vkuserphoto.ru/s/v1/ig2/idCVPO5zz4wFx9ckEsOPsVszvz-X3qMGZSg1CbkAkfhI59Ev02nbRhE3sRayE38dco62c8dkq1Q4bUfPIHetRSj2.jpg?quality=95&amp;as=32x26,48x40,72x59,108x89,160x132,240x198,360x297,480x396,540x445,640x528,720x594,1080x890,1093x901&amp;from=bu&amp;cs=1093x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>10) Комментарий</b> - на этой вкладке можно оставить комментарий, допустим какую то доп.информацию о http запросе, пометку для себя или других участников команды\n<img src=\"https://sun9-13.vkuserphoto.ru/s/v1/ig2/wk3GIC-wRkRD4W5ekbbltNtN3WVJNQYDg8hBy5Zre1rSYlAQ5Zl6FQLMchVgvYexv_UIjqMRvK4E-KCPEKfFnBil.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x76,240x114,360x171,480x228,540x257,640x304,720x342,875x416&amp;from=bu&amp;cs=875x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>11) Code snippet</b> - На этой вкладке мы можем посмотреть как отправленный http запрос может выглядеть в других сущностях, например на других языках программирования или как он выглядит при отправке через curl\n<img src=\"https://sun9-54.vkuserphoto.ru/s/v1/ig2/f5s81gZN-aATRzy227ehHe34rhjtHMZxAhikvg8CLT9c8a_7XdbXsznRjHSgUYGw9J4ZQq3EpnbrZ1MnGKBc5MN4.jpg?quality=95&amp;as=32x25,48x38,72x57,108x85,160x126,240x189,360x283,480x377,540x424,640x503,720x566,1080x848,1280x1006,1399x1099&amp;from=bu&amp;cs=1399x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>12) Информация об ответе от сервера</b> - На вкладке внизу у нас отображается информация об ответе от сервера, здесь отображается тело ответа, код ответа, который нам вернул сервер, заголовки и т.д.\n<img src=\"https://sun9-5.vkuserphoto.ru/s/v1/ig2/Z18fVUCrHHOD6XHf1UN49g0_a_Bw4czdSQuaATD2731vg-rjqSArrqSEaNKvvSh35IGqh2qzdnrnTX9jGfbmJJ_T.jpg?quality=95&amp;as=32x19,48x28,72x42,108x63,160x94,240x140,360x211,480x281,540x316,640x375,720x421,786x460&amp;from=bu&amp;cs=786x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>13) History.</b> На вкладке history мы можем просматривать историю своих запросов.\n<img src=\"https://sun9-14.vkuserphoto.ru/s/v1/ig2/iCCXoqRA76mhqC7zDgdAbghMnDMKwvrsAnX-gSQbak8_numhsch4gDKsccUSnwmi8hklkE9CJfXtSRt7j2BCrGr9.jpg?quality=95&amp;as=32x27,48x40,72x60,108x90,160x133,240x199,360x298,480x398,540x448,555x460&amp;from=bu&amp;cs=555x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>14) Environments.</b> На вкладке Environments мы можем управлять переменными окружения для разных сред (dev, test, prod).\n<img src=\"https://sun9-62.vkuserphoto.ru/s/v1/ig2/6K6kYBqyL9AhmgVU3aiXCzT8uSH2FHsv-kTvuh_NhRDNBLPVkvjOtxLDRNznVVk8HlRh_oxAJz6zQlno9rs8p8jW.jpg?quality=95&amp;as=32x28,48x43,72x64,108x96,160x142,240x213,360x320,480x426,540x480,582x517&amp;from=bu&amp;cs=582x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>15) Collections.</b> Коллекции нам позволяют  группировать  запросы для удобства.\n<img src=\"https://sun9-17.vkuserphoto.ru/s/v1/ig2/nhU-avRNjrsyVpfNuZI0ngb4i7ATntXerSOmBnGCiqsi0eOvLmibjlUeAsva502zd5mvzqXOYLf5NTUFjXVqsL4v.jpg?quality=95&amp;as=32x52,48x78,72x117,108x176,160x261,240x392,360x587,480x783,540x881,557x909&amp;from=bu&amp;cs=557x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>16) Create new collection</b> - Через + мы создаем новую чистую коллекцию, либо коллекцию на основе имеющихся шаблонов в postman: коллекция для интеграционного тестирования, регрессионного тестирования и т.д.\n<img src=\"https://sun9-38.vkuserphoto.ru/s/v1/ig2/WRDWxpXY-rIJKJZz92QbJXL-WFgbl7RTU9U8_tEmMt0cVDW9h1imsKp_OEDXkQsrvnRsnQa4G2-IOM4Nzci41wVg.jpg?quality=95&amp;as=32x27,48x40,72x61,108x91,160x135,240x202,360x304,472x398&amp;from=bu&amp;cs=472x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>17) Console.</b> Внизу мы можем открыть консоль, которая похожа на консоль в любом браузере. И здесь мы можем смотреть какие были запросы, группировать запросы по информационным или где были ошибки, можем почистить всю текущую информацию в консоли.\n<img src=\"https://sun9-63.vkuserphoto.ru/s/v1/ig2/q5UJT_dg5RRQIAFLd68K2X3AD5HlN4m9bfKsmbybBNMay7v7_MJIvkVjN8CFMg7V-Dm6qJUVNj7lPU1QdI--Plcl.jpg?quality=95&amp;as=32x11,48x16,72x24,108x37,160x54,240x81,360x122,480x163,540x183,640x217,720x244,1080x367,1280x435,1437x488&amp;from=bu&amp;cs=1437x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<b>18) Runner.</b> На этой вкладке мы можем:\n- Запускать запросы вручную.\n- Запускать коллекции целиком.\n- Запускать запросы по расписанию.\n- Интегрировать Postman с CI/CD.\n<img src=\"https://sun9-51.vkuserphoto.ru/s/v1/ig2/b0bFbBRvLDaJey6xzHgjryYBfeiE9v0gjvR5bLbWcMhjAVCyltxSfbKeG0vmpd5YFtXS9EYtah0U2KL2DEkWoOlT.jpg?quality=95&amp;as=32x50,48x75,72x113,108x169,160x251,240x376,360x564,480x752,540x846,640x1003,698x1094&amp;from=bu&amp;cs=698x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<hr>\nВся работа в Postman связана с запросами. В запросах естественно присутствуют определённые параметры, пути, заголовки, коды ответов. Для начала поймём что за что отвечает\n\n<details>\n<summary>Query, Path, Body, Headers</summary><div>\n<b>Query</b> параметры:\n- Расположение: В конце URL после знака ?.\n- Формат: Ключ-значение, разделенные &amp;.\n- Пример: https://api.example.com/users?name=John&amp;age=30.\n- Использование: Передача небольших объемов данных, таких как фильтры, сортировка, пагинация.\n<hr>\n<b>Path</b> параметры:\n- Расположение: В URL между слэшами /.\n- Формат: Ключ-значение, без разделения.\n- Пример: https://api.example.com/users/123.\n- Использование: Определение конкретного ресурса, например, пользователя с ID 123.\n<hr>\n<b>Body</b> параметры:\n- Расположение: В теле запроса.\n- Формат: JSON, XML, URL-encoded, multipart/form-data.\n- Пример: { \"name\": \"John\", \"age\": 30 }.\n- Использование: Передача больших объемов данных, например, создание нового пользователя.\n<hr>\n<b>Headers</b> параметры заголовка запроса:\n- Передаются в виде отдельных строк в заголовке запроса.\n- Используются для передачи метаинформации о запросе, такой как тип контента, язык, аутентификация или кеширование.\n- Пример: Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikxv\n</div></details>\n<hr>\n\n<h3>Коллекции, папки, http методы в Postman</h3>\n<details> \n<summary>Коллекции</summary><div>\nКоллекция - это структурированный набор API-запросов, оформленных как:\n- тестовые сценарии,\n- рабочее окружение,\n- последовательные цепочки запросов,\n- документация,\n- автоматизация.\nВнутри каждой коллекции можно хранить собственные локальные данные (для текущей коллекции) так называемые окружения. Окружения позволяют быстро менять токены, адреса, параметры. \n\nИ так, вначале мы создадим \"workspace\" (Коллекцию)\n<img src=\"https://sun9-49.vkuserphoto.ru/s/v1/ig2/pOVLBpaqP58mmHVoNTCLyqyBC_blBrqiTxhsFOzEwbokXQGv4E_r-XVvX9TIPrCzIL_DWfYSGiF4h1f3kU-lne2D.jpg?quality=95&amp;as=32x19,48x29,72x43,108x65,160x96,240x144,360x216,480x288,540x325,640x385,720x433,842x506&amp;from=bu&amp;cs=842x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВыберем \"Blank workspace\" и нажмем на \"Next\"\n<img src=\"https://sun9-6.vkuserphoto.ru/s/v1/ig2/ot9dbyH4LiTwIFnQFRW-zlLTX3DV1UPhw9kjike5g8Rz2YMl3zxr_946tHvQY8ESdhQ1x2C-z7qrzPORCZXFxhrt.jpg?quality=95&amp;as=32x29,48x44,72x66,108x99,160x147,240x221,360x331,480x441,540x497,640x589,720x662,970x892&amp;from=bu&amp;cs=970x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНа следующем шаге придумаем название для нашей workspace и нажмем на \"Create\"\n<img src=\"https://sun9-53.vkuserphoto.ru/s/v1/ig2/rpW_jlnMahOmct8pIQb_tN5eAQ8umQgnUcLQSH0vySNsEGYFwcx4KkbhCuA3Hz4fxq1J3MjzgScEcDaHDuY_U-XL.jpg?quality=95&amp;as=32x47,48x71,72x106,108x160,160x237,240x355,360x532,480x710,540x799,639x945&amp;from=bu&amp;cs=639x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь создадим нашу первую коллекцию, для того чтобы это сделать, необходимо нажать на \"+\" в интерфейсе postman. Выбираем \"Blank collection\".\n<img src=\"https://sun9-77.vkuserphoto.ru/s/v1/ig2/ETZewl-rtrC54NmE1LUF0swMFOioZiQNRVmdX5T1rOdSKx3pGb6AtTWXEbqDRJpOzi_6DNOUQBhha0iAOAVyMHmm.jpg?quality=95&amp;as=32x28,48x42,72x63,108x94,160x139,240x209,360x313,480x418,540x470,585x509&amp;from=bu&amp;cs=585x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте назовем нашу коллекцию \"Pet Store\" и нажмем на \"Enter\"\n<img src=\"https://sun9-32.vkuserphoto.ru/s/v1/ig2/_auAoFL6PBeYgw-7U-wXecLYGbYnKLkcmeLIsPWsr5SXH9X-9iB1Ik4J33d1mAWUGHcbNDUIFlXxxh-I4jvmCna4.jpg?quality=95&amp;as=32x21,48x32,72x48,108x71,160x106,240x159,360x238,480x318,540x357,640x424,720x476,819x542&amp;from=bu&amp;cs=819x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details> \n<summary>Папки</summary><div>\nПапки - это структура внутри коллекции. Они нужны для группировки запросов по логике.\nПапки позволяют:\n- логично распределить запросы;\n- запускать только часть коллекции (например, регресс по модулю Cart);\n- писать общие pre-requests и tests на уровне папки.\nПростая аналогия: \n- Коллекция - как корневой каталог проекта.\n- Папки - как подпапки с модулями.\n- Запросы - как отдельные файлы.\n\nВернемся к нашему <a href=\"https://petstore.swagger.io/\" target=\"_blank\">https://petstore.swagger.io/</a>  и мы видим, что нам нужно работать с тремя сущностями с заказами в нашем интернет-магазине, с животными и с пользователями\n<img src=\"https://sun9-66.vkuserphoto.ru/s/v1/ig2/DZmhL-hwdK5ISb2pDqW11X_IADpSCkN0NgSCNb1VVLmVPbX0RlQ-PgrmUn4fVOya2Wtl_7NcSHEXhUec41oBz849.jpg?quality=95&amp;as=32x16,48x25,72x37,108x56,160x82,240x124,360x185,480x247,540x278,640x330,720x371,1080x557,1209x623&amp;from=bu&amp;cs=1209x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте так и назовем наши папки \"pet\", \"store\", \"user\". Для того чтобы это сделать, нам нужно нажать на три точки возле нашей созданной коллекции и в выпадающем списке выбрать \"Add folder\"\n<img src=\"https://sun9-15.vkuserphoto.ru/s/v1/ig2/9NsiqOvO53KZhgIe1BjaSzznyvdjvEdmak3lNpco5kL-kxDzPL-hvgQr2B-hYm7Ph6oZiASlw0EcIcrZlwgt1OsF.jpg?quality=95&amp;as=32x27,48x41,72x61,108x92,160x136,240x205,360x307,480x409,540x460,640x546,720x614,834x711&amp;from=bu&amp;cs=834x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНазываем папку \"pet\" и нажимаем на \"Enter\"\n<img src=\"https://sun9-54.vkuserphoto.ru/s/v1/ig2/gH1KQECo2ChU-pW2hFmLaR6l-jFk4dFdxJRWLjm18ittwGW5NElU6l5v-2oDwGkMjD8ZDCrzCw5JpJmD_4aYDlxW.jpg?quality=95&amp;as=32x20,48x29,72x44,108x66,160x98,240x147,360x220,480x293,540x330,640x391,720x440,1018x622&amp;from=bu&amp;cs=1018x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nАналогично создаем следующие папки, и у нас должна получится следующая картина\n<img src=\"https://sun9-49.vkuserphoto.ru/s/v1/ig2/z8JakPhEa3uoWNQRf6kWuP6DTykbB2crV2HWLoTjcZk_S85p_0IlLTaUnMAzBacAMC6EYx8WdSCmWgZMHD7gpVlI.jpg?quality=95&amp;as=32x29,48x43,72x65,108x97,160x144,240x216,360x324,480x431,540x485,640x575,663x596&amp;from=bu&amp;cs=663x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details>\n<summary>Первый POST запрос</summary><div>\nPostman позволяет создавать любые типы запросов. В данном случае мы создадим первый POST запрос.\n\nНам нужно создать http запрос,  есть три места (способа), откуда это можно сделать:\n- Первый способ через \"Add a requets\" под нужной нам папкой:\n<img src=\"https://sun9-66.vkuserphoto.ru/s/v1/ig2/fmeqcEl95OTRGfO91l3jvp8r3DRwaEoELG2WxuPxivJaw64ghEYgY2tq2MH8VuSoGJNbD8tpZzAkD6yuxK3v_U6Z.jpg?quality=95&amp;as=32x29,48x43,72x65,108x97,160x144,240x216,360x325,480x433,540x487,640x577,720x649,913x823&amp;from=bu&amp;cs=913x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n- Через контекстное меню нужной нам папки:\n<img src=\"https://sun9-86.vkuserphoto.ru/s/v1/ig2/8WrMdfirl5wZCd2Y7VsAxpQ2a0h9nnTmLeHlmLiWg02rjRxcPlD7nYr-8xeag5mIuOq4CVNrz9gs_uV8VQqpur-_.jpg?quality=95&amp;as=32x34,48x52,72x77,108x116,160x172,240x258,360x387,480x517,540x581,640x689,720x775,762x820&amp;from=bu&amp;cs=762x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n- Через New &gt; HTTP:\n<img src=\"https://sun9-2.vkuserphoto.ru/s/v1/ig2/OfeORtoRZxh0z6Y8g3NgOu-IENe_cHx0qufU78aN7UPNsXvxvv5OfKmqlTzoN8uy-WhVlJI6dQCljk80WPkTn64O.jpg?quality=95&amp;as=32x25,48x38,72x56,108x84,160x125,240x188,360x281,480x375,540x422,640x500,720x563,1080x844,1280x1000,1295x1012&amp;from=bu&amp;cs=1295x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ давайте попробуем создать запрос POST /pet , который добавляет новое животное в магазин, для этого мы идем в  <a href=\"https://petstore.swagger.io/\" target=\"_blank\">https://petstore.swagger.io/</a>,  смотрим описание метода и видим, что все данные в запросе передаются в body, через json.  Нажимаем на \"Try it out\"\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/2gQ9j8WkPHABtOOuWP76oPxgJFjdrnWr0zVsod9pkb1QFCosOmjq1WaAtfVJSgv0JRk-d7SAlQm3sluxAiKA_9Ef.jpg?quality=95&amp;as=32x18,48x27,72x41,108x61,160x90,240x136,360x203,480x271,540x305,640x361,720x407,1080x610,1280x723,1440x813,1475x833&amp;from=bu&amp;cs=1475x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВ Postman так и называем метод \"Add a new pet to the store\"\n<img src=\"https://sun9-77.vkuserphoto.ru/s/v1/ig2/PEgrX9jUJFjXccTApXUXj6Rkii7GK0RkaeQVw1J-v9Ms5jZ8K-xvvRwzL-h9dRD2dzpr2HT0aSzAnA5bSs38nmAR.jpg?quality=95&amp;as=32x13,48x19,72x29,108x43,160x64,240x95,360x143,480x191,540x215,640x254,720x286,1080x429,1235x491&amp;from=bu&amp;cs=1235x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь нам нужно выбрать тип запроса и эндпоинт, которому мы будем обращаться.  Эндпоинт (от англ. endpoint - конечная точка) - это адрес, по которому можно получить доступ к данным или функциям приложения, веб-сервиса или API. Проще говоря, это «точка входа» для взаимодействия с программой.\nТип запроса мы можем увидеть вот здесь\n<img src=\"https://sun9-81.vkuserphoto.ru/s/v1/ig2/j0pT6tvKBmohBiiOVFJRi4tsQWBRwua5oCJYv_vcZtx6W_Az6giV84Q2bq1czwCgUgTSGtM14nUdy568zeCjujy4.jpg?quality=95&amp;as=32x17,48x25,72x38,108x57,160x84,240x126,360x189,480x252,540x284,640x336,720x378,742x390&amp;from=bu&amp;cs=742x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nЭндпоинт у нас складывается из базового урла и из окончания урла, которое оказано в описании метода.\n<img src=\"https://sun9-56.vkuserphoto.ru/s/v1/ig2/h4TDKw0JO5UDX7KCkoyd43eEZttRsnP2mkjKAM4-9dzluyfMhH87M_LSu6TH_xJmah4cg6qfXsd2Fd41ri1qE1tv.jpg?quality=95&amp;as=32x39,48x59,72x88,108x132,160x196,240x294,360x441,480x589,540x662,640x785,663x813&amp;from=bu&amp;cs=663x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nИ того итоговый урл будет\nhttps://petstore.swagger.io/v2/pet и метод post, вставляем эту информацию в Postman\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/Ysncfk4OhtG6ilU8qRTqTWuUdnf5iA7oKtsemxtLSGIqfo5Z9vYPvz0xWhUawGDrSg549gVRDmGPhOp7b-GDCri5.jpg?quality=95&amp;as=32x15,48x22,72x33,108x49,160x73,240x110,360x165,480x220,540x247,640x293,720x330,1080x495,1280x587,1440x660,1715x786&amp;from=bu&amp;cs=1715x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТак информация у нас передается в body в виде json, копируем наш json со swagger\n<img src=\"https://sun9-40.vkuserphoto.ru/s/v1/ig2/ThDPnMhLlBtcIZkCCwveEjT3ub_xYTNiackmKNn5vHQG7Ji8g414JXmRYSTz8CJBR1XOod9cTH0XbGF1l9lzp5QJ.jpg?quality=95&amp;as=32x18,48x26,72x40,108x60,160x88,240x132,360x199,480x265,540x298,640x353,720x397,1080x596,1280x706,1437x793&amp;from=bu&amp;cs=1437x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее в postman переключаемся на Body &gt; raw &gt; JSON и вставляем наш JSON\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/cjhAwCYKgltAQWUMY4giHA9XwnWWtvQvOHrbkRC_IkQY3s_1vWWufbxMyIsSMDkkErYYIA5ZkqcfnyD-w6R6asnU.jpg?quality=95&amp;as=32x19,48x28,72x43,108x64,160x95,240x142,360x213,480x284,540x320,640x379,720x426,1080x639,1280x758,1440x852,1514x896&amp;from=bu&amp;cs=1514x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПусть будет id животного 444555, id категории 4444, имя категории dogs, имя животного Jack. Введем все эти данные  в Postman и нажмем на \"Send\"\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/cAcIy8pIW96w5_M84Xq3WF7wp_dOlSRIT3YZbYoSlOzZy0Q-2xsiPLHZw79GngPC4Ljx_nYSewnu_-vKxrba94cO.jpg?quality=95&amp;as=32x24,48x36,72x53,108x80,160x118,240x178,360x267,480x356,540x400,640x474,720x533,1080x800,1280x948,1440x1067,1527x1131&amp;from=bu&amp;cs=1527x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nМы видим, что нам вернулся 200 код, значит что запросы выполнен успешно, и также вернулось тело ответа с нашими созданными данными. Давайте нажмем на SAVE, чтобы сохранить наш запрос. \n<img src=\"https://sun9-19.vkuserphoto.ru/s/v1/ig2/2F4SYZyIQUlLioqJktfzE_0Z4HkQ0q4-PCTX322e-d8CaFkmy6Q2HgTsoRlHDrV1VGS3viPRWLX_DhTcYnwmLVJt.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x134,360x201,480x268,540x301,640x357,720x402,1080x602,1280x714,1440x803,2056x1147&amp;from=bu&amp;cs=2056x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nПоздравляю, мы выполнили наш первый запрос в postman!\n</div></details>\n<details>\n<summary>POST запрос (импорт cURL из Swagger в Postman)</summary><div>\nДля удобства и простоты переноса запросов из Swagger в Postman можно брать cURL из Swagger. И далее уже адаптировать под свои нужды.\n\nДля этого выполняем запрос в Swagger, как мы с вами это уже делали и копируем сформированный curl из swagger\n<img src=\"https://sun9-68.vkuserphoto.ru/s/v1/ig2/eaMg3K5u2ZA8xUPCmQ60tjRv3Xo4P-zVG5WgSQvP3a_pR1daTpyz273mMfqME359b8rMl84p5XlY4_KPbNI_urOe.jpg?quality=95&amp;as=32x15,48x22,72x33,108x50,160x74,240x110,360x166,480x221,540x248,640x294,720x331,1080x497,1280x589,1440x663,1517x698&amp;from=bu&amp;cs=1517x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nОткрываем postman и нажимаем на import\n<img src=\"https://sun9-10.vkuserphoto.ru/s/v1/ig2/54FsghvNeQcy0NZVcbSMcykIH8MwRxyapAmWnNTN9ZihuPtghbQNBhBJh7-i2y8cHdWhpnVxP9gcu8jhveTaL2kA.jpg?quality=95&amp;as=32x16,48x23,72x35,108x53,160x78,240x117,360x176,480x235,540x264,640x313,720x352,1080x528,1280x626,1409x689&amp;from=bu&amp;cs=1409x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nB прямо в input вставляем скопированный нами curl. И у нас автоматом сформировался нужным нам запрос в postman со всеми параметрами, нам остается только отправить запрос нажав на Send:\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/tNgYhxsoIGQJXOsoCU8zIMgDxojNKTwLf2AETZdWcAjKD_zyRTkGAK23YCMNXKNSIyWXJ7b-0EJ790xrXJpl-TXL.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x133,360x200,480x267,540x300,640x355,720x400,1080x600,1280x711,1440x800,1532x851&amp;from=bu&amp;cs=1532x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details>\n<summary>POST запрос с файлом</summary><div>\nТеперь давайте создадим второй запрос POST /pet/{petId}/uploadImage. Как мы видим из документации swagger здесь нам нужно через path параметр передать id животного, у которого мы хотим обновить изображение и метаданные, а также нам нужно в теле через formData передать сам file с типом file и additionalMetadata с типом String\n<img src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/gq3GkUkNWkjUUQevxFyAosfGWnKAsphK5SGklJj-aRKJlrK9VnYERtWIaj4Rf4TUEL2yg6r5oGrC8bwXkVxPG8NQ.jpg?quality=95&amp;as=32x13,48x20,72x29,108x44,160x65,240x98,360x146,480x195,540x220,640x260,720x293,1080x439,1280x521,1440x586,1480x602&amp;from=bu&amp;cs=1480x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте сделаем это. И задублируем в postman запрос, который мы создавали.\n<img src=\"https://sun9-48.vkuserphoto.ru/s/v1/ig2/hezm4oRq78zxhy47JsMFeF9i5MlWJINBl6Plca05KzmzHCvZjPSYUxlTjPd-o1tIqL7Ie9xeZtp0nZi5_BN9S30g.jpg?quality=95&amp;as=32x30,48x46,72x68,108x103,160x152,240x228,360x342,480x456,540x513,640x609,720x685,815x775&amp;from=bu&amp;cs=815x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nУ нас задублировался второй метод\n<hr>\nДавайте поменяем в нем урл, где в урле укажем id животного, к которому мы будем добавлять изображение и мета данные. Прошлое животное, которое мы создали было с id 444555, это id будет в урл и это как раз будет path параметром. И переименуем название, метод отправки будет таким же POST\n<img src=\"https://sun9-52.vkuserphoto.ru/s/v1/ig2/BPo5nvWyOiGhbxuaFZaVAcWbxwfhJLY6IGOHE0QoGjaNXLwsGkNEZlreuI5wnMT6sL4B9SDhyWVQGQKv1yhisd7A.jpg?quality=95&amp;as=32x11,48x16,72x24,108x36,160x54,240x81,360x121,480x161,540x181,640x215,720x242,1080x363,1280x430,1440x484,2065x694&amp;from=bu&amp;cs=2065x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь нам нужно переключиться на вкладкy  body и formData\n<img src=\"https://sun9-25.vkuserphoto.ru/s/v1/ig2/HWSmwEZDuegaBz2lDQX1ByuqAaTVPBsfDegCvQAGKBrnrhh3dOtgjB8tUzGUV5PYobrNvLJFZEIicBXcs_At5b0b.jpg?quality=95&amp;as=32x20,48x29,72x44,108x66,160x98,240x147,360x221,480x294,540x331,640x392,720x441,1057x648&amp;from=bu&amp;cs=1057x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЗаполняем additionalMetadata и file. После того как напротив ключа file мы выберем в выпадающем списке file, postman позволит нам выбрать файл с компьютера, что мы и сделаем.\n<img src=\"https://sun9-46.vkuserphoto.ru/s/v1/ig2/MewPZUbz1ixhI5Tp-rc40zJVjza42s5NhdjXnVvxnoCiVWpku4bXLyG2tMsZBol9-CfqJ_y9Jqbd6qIWZ3O55ZfY.jpg?quality=95&amp;as=32x21,48x32,72x47,108x71,160x105,240x158,360x237,480x316,540x356,640x422,720x474,812x535&amp;from=bu&amp;cs=812x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажимаем на Send и видим, что запрос прошел успешно, вернулся 200 код ответа. Также вернулось тела ответа в виде JSON где мы можем в message увидеть информацию о том, что файл и метаданные добавились, и также в теле ответа возвращается 200-ый успешный код и не забываем как обычно сохранить.\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/TY6FxNeFe40yR-qPmYLMJSSc0Sa4gK8STLZnmQ1ha2DLdY6ayLnY1sk0XpYMn3YzUW4Evv28FP1RblXntcRTiIwJ.jpg?quality=95&amp;as=32x22,48x33,72x49,108x73,160x109,240x163,360x244,480x326,540x366,640x434,720x488,1080x733,1280x868,1440x977,1508x1023&amp;from=bu&amp;cs=1508x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь у нас есть два добавленных POST метода\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/tDBMRtRCGL-r4jCj61SjGX4XEZrF40dnw77QV-4MfBJBbOciLDS8rzN5dBkBAIllXbA5iSN4RzfcPWwnsBCzRuti.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x100,360x150,480x200,540x225,640x267,720x300,1080x450,1280x533,1440x600,2055x856&amp;from=bu&amp;cs=2055x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details>\n<summary>GET запрос</summary><div>\nТеперь возвращаемся в swagger и добавим метод, который будет работать c querry параметром. Согласно документации, в этот метод мы должны передать один query параметр с ключом status и со значением либо available, либо pending, либо sold, и в отличие от двух предыдущих запросов, где мы отправляли данные через POST, здесь же мы получаем данные через GET\n<img src=\"https://sun9-57.vkuserphoto.ru/s/v1/ig2/0c-zF3vBrPTediKjLXFavcq5LFCQ6ZUjI_oZD_oEcpAtI0eLmjVq4KPfnhHgcNHoaULP4XWz9ignr3FdfZg0UjhZ.jpg?quality=95&amp;as=32x17,48x26,72x39,108x58,160x86,240x129,360x193,480x257,540x289,640x343,720x386,1080x579,1280x686,1412x757&amp;from=bu&amp;cs=1412x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДелаем аналогичный запрос в postman как и два предыдущих, здесь на вкладке  Query Params мы напишем ключ Status со значением «sold» и у нас автоматом этот параметр подставится через ? в урле.\n<img src=\"https://sun9-11.vkuserphoto.ru/s/v1/ig2/g7AfxHnbJQOjUzuZLQwpgExaxP7Kvf5c5lTN1PRlPlpT-iOpLDvpm_nBozZZWkkfoFYenVWFB8v1dtYQqLxOlua0.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x59,240x89,360x134,480x178,540x200,640x237,720x267,1080x401,1280x475,1440x534,2156x800&amp;from=bu&amp;cs=2156x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажимаем на Send и нам возвращается код ответа 200 и  список животных со статусом sold. Не забываем сохранить нащ запрос.\n<img src=\"https://sun9-15.vkuserphoto.ru/s/v1/ig2/lEkjlLzP5AzjEkK-9nSgoy7LmgaudDppke3EOElQYCw8qgEHCOBJzArHmL5yocZpxqqSG6f0X0l6NghKbt-g3yLP.jpg?quality=95&amp;as=32x23,48x35,72x53,108x79,160x117,240x176,360x264,480x352,540x396,640x469,720x528,1080x792,1280x938,1440x1055,1565x1147&amp;from=bu&amp;cs=1565x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n</div></details>\nОстальные методы из папки pet я вам рекомендую сделать самостоятельно.\n<img src=\"https://sun9-79.vkuserphoto.ru/s/v1/ig2/imFwpeAucPaHPptpm_n4ymizonhR2pztCQuMAUlBJ44C8AQXX6KPlWoKm23S3l3U0qstJkEnyYk9PqL1zj3gQnTm.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x59,240x88,360x133,480x177,540x199,640x236,720x266,1080x398,1280x472,1440x531,1486x548&amp;from=bu&amp;cs=1486x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n(p.s: для метода DELETE необходимо ознакомиться с разделом авторизации через headers в postman)\n\n<details>\n<summary>Какие данные мы можем передавать в теле запроса</summary><div>\n<img src=\"https://sun9-87.vkuserphoto.ru/s/v1/ig2/Uy4GZmBmwUCXB_R8F38258wrO1YAPOufnIWNbW7cjtKZWgtegKxAAPZ8Q-vugBpLKCF9KkxNRrkY1EbhxwfTB9Lr.jpg?quality=95&amp;as=32x4,48x7,72x10,108x15,160x22,240x33,360x49,480x66,540x74,640x88,720x99,913x125&amp;from=bu&amp;cs=913x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<b>None:</b>\nОтсутствует тело запроса. Используется, когда запрос не содержит данных, например, при GET-запросе.\n<hr>\n<b>Form-data:</b>\nДанные передаются в виде пар ключ-значение, как в HTML-форме. Подходит для простых запросов с небольшим объемом данных. Подходит для более сложных данных, включая несколько файлов, нетекстовые данные (изображения, видео), структурированные данные (объекты, массивы).\n<hr>\n<b>x-www-form-urlencoded:</b>\nАналогично form-data, но данные кодируются в URL-формате. Ограничен простыми текстовыми данными. Нельзя передавать файлы или нестандартные символы.\n<hr>\n<b>Raw:</b>\nТело запроса вводится в сыром виде, без кодирования. Подходит для JSON, XML и других форматов данных.\n<hr>\n<b>Binary:</b>\nИспользуется для передачи двоичных данных, таких как изображения, файлы.\n<hr>\n<b>GraphQL:</b>\nПозволяет создавать запросы к GraphQL API.\n</div></details>\n<hr>\n<details>\n<summary>Авторизация через headers в postman</summary><div>\nДо этого мы с вами спокойно выполняли все запросы и для этого нам не нужны были никакие авторизационные токены. Но так происходи не всегда. Давайте откроем следующий сервис  <a href=\"https://dummyapi.io/docs\" target=\"_blank\">https://dummyapi.io/docs</a>\nСоздадим новую коллекцию и назовем ее Dummy\n<img src=\"https://sun9-55.vkuserphoto.ru/s/v1/ig2/PGNxytPPl7Nd0XeUa2ZM2N3shnNSM-Yk7qW-Rc4r7WDGRfLxvcmJcIVjWslO2JdAraSVV1Vy2tYzCFHNj78Ry4Qz.jpg?quality=95&amp;as=32x19,48x29,72x43,108x65,160x96,240x145,360x217,480x289,540x325,640x386,720x434,1080x651,1266x763&amp;from=bu&amp;cs=1266x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНа главной странице dummy мы видим наш базовый url, к которому мы будем обращаться.\n<img src=\"https://sun9-86.vkuserphoto.ru/s/v1/ig2/cPs7U7064-vxSxUe8OW1GWx__jqdedCdNwOAggPt037wAhmhyZfsePtY6p13f4s0usySPXRCn87l2BIWOy6Pg65C.jpg?quality=95&amp;as=32x24,48x36,72x54,108x81,160x120,240x180,360x269,480x359,540x404,640x479,720x539,978x732&amp;from=bu&amp;cs=978x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПереходим на User Data и давайте попробуем сделать запрос на получение списка всех пользователей\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/buxrKuoGCsuslp513l2acboMzLNMkjRAGL_wR559AEd8w5GaqSCecSXQeQfhFuJv2rr-wq2AT-dY1MG2QQ-fFadU.jpg?quality=95&amp;as=32x22,48x34,72x51,108x76,160x113,240x169,360x253,480x338,540x380,640x450,720x506,1008x709&amp;from=bu&amp;cs=1008x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВ postman итоговый url будет равен base url + /user (https://dummyapi.io/data/v1/user)\n<img src=\"https://sun9-58.vkuserphoto.ru/s/v1/ig2/Oj7w1iWVKaOY-mLrG8jXINkMnrEHYXkP9tvrdeAXAwwSm84o6_7WA2YRBVK8dmZbloMnIRiJEsC2FPY_C12w3CKw.jpg?quality=95&amp;as=32x21,48x32,72x48,108x71,160x106,240x159,360x238,480x317,540x357,640x423,720x476,1077x712&amp;from=bu&amp;cs=1077x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажимаем на send и получаем ошибку с 403 кодом ответа\n<img src=\"https://sun9-65.vkuserphoto.ru/s/v1/ig2/fgyVa0stNmc6mQaNk-D_lYlBKUN0U3ABGjdR143YX7wuIFeG731q85h8iOOt1T6b014BvHbW-1qyBZ6dNX_KTrLQ.jpg?quality=95&amp;as=32x14,48x21,72x32,108x48,160x71,240x106,360x159,480x212,540x239,640x283,720x318,1080x478,1280x566,1440x637,2137x945&amp;from=bu&amp;cs=2137x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЭто значит, чтобы работать с http методами, у нас в headers должен быть прописан наш  уникальный app-id, об этом написано в документации на <a href=\"https://dummyapi.io/docs\" target=\"_blank\">https://dummyapi.io/docs</a>:\n«Headers\nIt is required to set app-id Header for each request.\nIt helps us to determine your personal environment. So only you can access data that were created or update.\nYou can get personal App ID value on your account page.\nYou can have as much App ID as you want and use it in parallel(for different projects, envs etc).\nExample: app-id: 0JyYiOQXQQr5H9OEn21312»\nКогда мы регистрируемся в сервисе  dummy, мы попадаем на страницу https://dummyapi.io/account и отсюда мы и берем наше значение app-id.\n<img src=\"https://sun9-13.vkuserphoto.ru/s/v1/ig2/7xKg03Q_Vuj6Ae4nXjifdSrcXKszRxnrJV3zl1TcL6z-wOfbEkiw-VwOv_Yg5i24L7YhEgoLdEpdtvHy4S4jXAaH.jpg?quality=95&amp;as=32x24,48x35,72x53,108x79,160x118,240x177,360x265,480x353,540x397,640x471,720x530,1066x784&amp;from=bu&amp;cs=1066x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<p style=\"color:red\">\nP.S: с недавнего времени авторизация/регистрация на сервисе недоступна.\nВот несколько рабочих App_id: \n63760c781f1d8505e69a587c\n65c285ba99902e3258b34beb\n</p>\n<hr>\nДалее мы переходим в postman на вкладке Authorization мы выбираем тип API Key\n<img src=\"https://sun9-66.vkuserphoto.ru/s/v1/ig2/vl_yphkcnGodGxEev449o27WxJlifpkZ0Dka7RkPshVER4xmmj3v4G4MlozemJigNM6lvfw8qJOY1AFN4gO-ybfX.jpg?quality=95&amp;as=32x27,48x41,72x61,108x92,160x136,240x204,360x306,480x408,540x459,640x545,720x613,1080x919,1173x998&amp;from=bu&amp;cs=1173x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВ key указываем app-id и в значении вставляем наш токен, строчка Add to Headers, значит что ключ со значением токена добавится в heders, что нам и нужно.\n<img src=\"https://sun9-35.vkuserphoto.ru/s/v1/ig2/7m7otcesfKMC_jprc1oZQ-l9iK7Hr8Ql443g0F5tAZEyUYTZoOvOJylK3cMJj8Oe_JCx1t53r_DE5u7sBgIyw24b.jpg?quality=95&amp;as=32x10,48x15,72x23,108x34,160x50,240x76,360x114,480x151,540x170,640x202,720x227,1080x341,1280x404,1312x414&amp;from=bu&amp;cs=1312x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНе забываем сохранять и отправляем наш запрос.\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/ai3aEFP6uKGm6d_0mV1vhz-uZWiZKvUhfGOvjRVMTh0enV3pyEz5bjNBq_IxLAz9_kSMI_vMGQCfCSIDSqnhnH7d.jpg?quality=95&amp;as=32x18,48x27,72x41,108x61,160x90,240x136,360x204,480x271,540x305,640x362,720x407,1080x611,1280x724,1440x814,1519x859&amp;from=bu&amp;cs=1519x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ мы видим, что теперь нам возвращается список пользователей\n<img src=\"https://sun9-61.vkuserphoto.ru/s/v1/ig2/Zn17X1QAo3btzCP57qTUGjY_ORBL8EwFjxphooRaVN-en11RavhefBRxlhGKNctm5znAnzV5YdhjYvN_MqIsAYqJ.jpg?quality=95&amp;as=32x24,48x36,72x53,108x80,160x119,240x178,360x267,480x356,540x401,640x475,720x534,1080x801,1280x949,1440x1068,1584x1175&amp;from=bu&amp;cs=1584x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ если мы переключимся на вкладку Headers, то увидим, что туда добавился наш app-id\n<img src=\"https://sun9-49.vkuserphoto.ru/s/v1/ig2/ge01ufeiMACmPIYzTIVi-YbJuVgVJ5k6UkTLCS3L193-Ztu7dfrjmchrXtZtO55iQW2qyoP43z932P6zQJDjbt1r.jpg?quality=95&amp;as=32x23,48x35,72x52,108x78,160x116,240x174,360x261,480x348,540x391,640x463,720x521,1080x782,1280x927,1440x1043,1504x1089&amp;from=bu&amp;cs=1504x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<hr>\n<h3>Variable, Global variable, Enviroments в Postman</h3>\nEnvironment (Окружение) - это набор переменных, которые можно использовать в ваших запросах. Мы создаем свой environment в нем мы указываем список переменных и далее этот environment мы можем выбрать для любой коллекции и это значит, что переменные из этого environment будут доступны в рамках коллекции\nУ нас есть глобальные переменные (Global variable)  - эти переменные доступны для все коллекций\nУ нас переменные в рамках коллекции (Variable) - эти переменные доступны только в той коллекции, в которой мы их укажем, в других коллекциях они не доступны.\n\n<details>\n<summary>Variable</summary><div>\nДавайте вначале создадим переменную в рамках коллекции. Для этого перейдем в коллекцию, в которой хотим создать переменную, пусть будет это будет наша коллекция pet store, переходим на вкладку variable и создаем нашу переменную. (переменную нельзя создать только на запрос или только на папку, переменные создается на всю коллекцию). Не забываем сохранить, иначе переменная не будет доступна.\n<img src=\"https://sun9-20.vkuserphoto.ru/s/v1/ig2/yI4Dq1anU7UweN7yx9SaRCS7Cmfg43PQs63JdGuv_qnCJRfPfvej9tUF4bFUC2CJ9cZkC8VWLJiwRzMSZrfbcw7C.jpg?quality=95&amp;as=32x12,48x18,72x28,108x42,160x62,240x92,360x138,480x185,540x208,640x246,720x277,1080x415,1280x492,1440x554,1492x574&amp;from=bu&amp;cs=1492x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее идем в строку запроса и заменяем url https://petstore.swagger.io/v2 на нашу переменную, начинаем писать { и постман сам подсказывает что нам доступна переменная  pet_store.  Буква C обозначает, что переменная доступна в рамках коллекции.\n<img src=\"https://sun9-2.vkuserphoto.ru/s/v1/ig2/a0LS25sCeW1RaQC6DtZ51n0S3r5j8w-I7KaduJQtpdORoStSQoUHe3MmOqaHxK_GIVEUIwfbb-EWtndXzVrVon7o.jpg?quality=95&amp;as=32x19,48x29,72x43,108x65,160x96,240x144,360x216,480x288,540x324,640x383,720x431,883x529&amp;from=bu&amp;cs=883x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВыбираем ее, нажимаем на SAVE и отправляем наш запрос. И как вы видим все ок, запрос прошел\n<img src=\"https://sun9-11.vkuserphoto.ru/s/v1/ig2/p0TnmiAfVsB9A_HVfzs_SPW4wb9Vg2dFxfKTGdA4lc7HUaidF5Ndkc1bIkKbKXKtFgOGXvI9USQF54-G09ZEYRXc.jpg?quality=95&amp;as=32x24,48x36,72x54,108x81,160x120,240x180,360x270,480x359,540x404,640x479,720x539,1080x809,1280x959,1440x1078,1521x1139&amp;from=bu&amp;cs=1521x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЗаменяем https://petstore.swagger.io/v2  на {{per_store}} в оставшихся методах, и убеждаемся, что они выполняются\n<img src=\"https://sun9-69.vkuserphoto.ru/s/v1/ig2/aBaD8rTwS8We_SF-Da_gxBNBpRQMhdGcNEU8rKFzqSqroPEJa-YtytJ3cMGdOBsb3QEeotnu245OhyS_CrQL780b.jpg?quality=95&amp;as=32x15,48x23,72x35,108x52,160x77,240x116,360x173,480x231,540x260,640x308,720x347,1080x520,1280x616,1440x693,1901x915&amp;from=bu&amp;cs=1901x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<img src=\"https://sun9-2.vkuserphoto.ru/s/v1/ig2/OwEbMg1HmgqRqVSOUJIgEocsR9xVHYl9Bfs51E7ZDbHnCbdgC5n2RhcYsFa-Qiyt6GbUDbEeNzK0v0jLsFSEBr_7.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x133,360x200,480x267,540x300,640x356,720x400,1080x601,1280x712,1440x801,1924x1070&amp;from=bu&amp;cs=1924x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТаким образом, если у нас изменится урл https://petstore.swagger.io/v2 , то мы просто изменим значение в одном месте в одном месте\n<img src=\"https://sun9-63.vkuserphoto.ru/s/v1/ig2/shQeIRG5xs2cteeso-0AhZlpj6LhOuRWbOBDL_naiZ8ERy_ccqBtrDxU-M9eTffiwAgYsdu3lKht0q6v5sSWQfp4.jpg?quality=95&amp;as=32x9,48x14,72x21,108x32,160x47,240x70,360x106,480x141,540x158,640x188,720x211,1080x317,1280x376,1440x423,1479x434&amp;from=bu&amp;cs=1479x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nТочно также переменные можно использовать в Headers, Body или Pre-request Script.\n</div></details>\n<details>\n<summary>Global variable</summary><div>\nТеперь давайте перейдем в Environments &gt; Globals и создадим переменную dummy_url со значением https://dummyapi.io/data/v1 (Не забываем сохранить)\n<img src=\"https://sun9-55.vkuserphoto.ru/s/v1/ig2/sN0Dp5gFU3VIbntXiSO94YUbv_LdwLJ949WLwIGV8qHBaVUQbKUlDkjO6Q0FL71KuyCJKpm5PzWhW4ARAno2ceyb.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x202,540x227,640x269,720x302,1080x454,1280x538,1440x605,1764x741&amp;from=bu&amp;cs=1764x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПосле этого идем в коллекцию Dummy и заменяем в запросе https://dummyapi.io/data/v1 на {{dummy_url}} и как мы видим postman нам подсказывает что у нас есть глобальная переменна dummy_url которая нам доступна, но при этом мы не видим  pet_store, переменную pet_store мы в этой коллекции использовать не можем, так как она создана и доступна только в коллекции Pet Store\n<img src=\"https://sun9-55.vkuserphoto.ru/s/v1/ig2/nyfTnL5wTLGk3WNti7spMuMbeaouz4ub6787JgIjbI4h86VaV3OJ_9iAXQkFZsHY5g5Dqr_GMPCKyCEJPgmaGlgQ.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x75,240x113,360x169,480x225,540x253,640x300,720x338,1080x507,1280x601,1385x650&amp;from=bu&amp;cs=1385x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВыполняем запрос и убеждаемся что все работает\n<img src=\"https://sun9-51.vkuserphoto.ru/s/v1/ig2/yVSKElOp74YCnO6_StNwRfp2WOdJos2xKUtSwzHoNWJrwNLARWvOAXnqk1lcF2BvTyvi62X7Rcly3k6oGXHSmhG0.jpg?quality=95&amp;as=32x23,48x34,72x51,108x77,160x114,240x171,360x257,480x343,540x385,640x457,720x514,1080x771,1280x914,1440x1028,1503x1073&amp;from=bu&amp;cs=1503x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details>\n<summary>Environment </summary><div>\nТеперь давайте создадим собственный Environment и назовем его pet store\n<img src=\"https://sun9-77.vkuserphoto.ru/s/v1/ig2/4dXr8XMfET_lwr-gxcGrvecSGWXGCADLHZNTjb_ilGWBD02-NeCANvYMtZKVkP7tgEgWAy7nnZRIaNseWO6ZRkno.jpg?quality=95&amp;as=32x43,48x64,72x96,108x145,160x214,240x321,360x482,480x643,540x723,620x830&amp;from=bu&amp;cs=620x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ давайте создадим в этом environment переменную store_url со значением https://petstore.swagger.io/v2 и не забываем сохранить, нажмем на \"Save\"\n<img src=\"https://sun9-66.vkuserphoto.ru/s/v1/ig2/8i7UrJlO8oJ6xxwo_RjIr0kjxRih5ZPr31Nxv8XODYxhm-9V_NZB_9-pa6IFthAn8jKlUe_8VNBXlLuExc0ETEDU.jpg?quality=95&amp;as=32x7,48x11,72x17,108x25,160x37,240x55,360x83,480x110,540x124,640x147,720x165,1080x248,1280x294,1440x331,1942x446&amp;from=bu&amp;cs=1942x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь вернемся к нашей коллекции Pet store и попробуем в первом запросе {{per_store}} заменить {{store_url}}\n<img src=\"https://sun9-69.vkuserphoto.ru/s/v1/ig2/empHr0NYrNDRevf4RL7IE-qqCDdWMoUu8ZhUk4J7pVE_7alPuLYujBAzffdw5OXtcNO-gDLL0mMtn2NJaYJgf8Zf.jpg?quality=95&amp;as=32x15,48x23,72x35,108x52,160x77,240x116,360x174,480x232,540x262,640x310,720x349,1080x523,1280x620,1437x696&amp;from=bu&amp;cs=1437x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ как мы видим  postman нам подсказывает, что он не видит переменную {{store_url}}\n<img src=\"https://sun9-31.vkuserphoto.ru/s/v1/ig2/bvx3J0vvNXfmZIUMBQJtfj0B70ryUsSJVjSNRkpoTnt068VjnAfioLVVM1Px-1FGaNzbYzGPLANb3k72fm6h_Rqs.jpg?quality=95&amp;as=32x17,48x26,72x39,108x59,160x87,240x131,360x197,480x262,540x295,640x350,720x394,1080x590,1253x685&amp;from=bu&amp;cs=1253x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nА чтобы он ее увидел, выберем environment для этой коллекции с нужной нам переменной store_url\n<img src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/OC_jT67K9yXe7PwrONS1Cb4PBWEAUOLNCiAiHyAybszrGceYc0DxJusyLXuS4GMR1q8QlxbZW8RnS_Z5g8mXp16K.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x101,240x151,360x226,480x302,540x339,640x402,720x452,1080x678,1280x804,1440x905,1579x992&amp;from=bu&amp;cs=1579x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПосле этого переменная store_url становится доступна\n<img src=\"https://sun9-28.vkuserphoto.ru/s/v1/ig2/SOQsJFpP-fGPtMQAL1ejPFAEVhoyBAxlzP9ur8E24b7RPqV3_DPezGUf1DvSk-BJUr_vf1tEHAQZHQ2_vgmakVMl.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x269,540x303,640x359,720x404,1080x606,1280x718,1440x808,1566x879&amp;from=bu&amp;cs=1566x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nВыполняем наш запрос и убеждаемся, что он проходит\n<img src=\"https://sun9-51.vkuserphoto.ru/s/v1/ig2/cEa__rX88y2jpubAIAOFuV7uvq-ne9ZB82Js_Z0SJBysNv6x1KBQidxFW47ovxOsg7TZBFQk1y231A43QtH4xVCI.jpg?quality=95&amp;as=32x22,48x32,72x49,108x73,160x108,240x162,360x243,480x324,540x365,640x432,720x486,1080x729,1280x865,1440x973,1516x1024&amp;from=bu&amp;cs=1516x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТакже, при нажатии на значок глазика мы можем посмотреть какие глобальные переменные  есть, какие environmetns у нас есть и какие переменные в рамках этих environmetns доступны и также можем их отредактировать\n<img src=\"https://sun9-61.vkuserphoto.ru/s/v1/ig2/gdnkh39zFK_WA49Ar7gpGwfWR0__Hu_Cc4PsbBvWTgT99TOJ2OjTL959XZ7asv6pLD8q5NfmKnvrdgh-u9zCviRD.jpg?quality=95&amp;as=32x30,48x45,72x68,108x102,160x152,240x227,360x341,480x455,540x511,640x606,720x682,1080x1023,1174x1112&amp;from=bu&amp;cs=1174x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<hr>\n<h3>Pre-request Script и Tests (Post-response)</h3>\n<b>Pre-request scripts:</b>\nПредназначены для выполнения JavaScript-кода перед отправкой запроса. В пререквест скриптах мы можем например генерировать динамичные значения для параметров, заголовков, боди запроса\n<b>Tests (Post-response):</b>\nПредназначены для проверки ответа сервера после отправки запроса. Мы можем проверять код ответа сервера, содержимое ответа и т.д. А так же автоматизировать проверки.\n\n<details>\n<summary>Логика работы Pre-request и Tests (Post-response)</summary><div>\nPre-request scripts и Tests (Post-response) у нас могут быть в рамках коллекции\n<img src=\"https://sun9-41.vkuserphoto.ru/s/v1/ig2/Bh-cdphd2myseFeACeQBAqHVdeD-4tNQurR5U43SFO0MweTf8vqQbEoOwltzHjHCjPc6ECzeos-zJM4xuto1qrI5.jpg?quality=95&amp;as=32x13,48x20,72x29,108x44,160x65,240x98,360x146,480x195,540x220,640x260,720x293,1080x439,1280x521,1389x565&amp;from=bu&amp;cs=1389x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nВ рамках папки\n<img src=\"https://sun9-73.vkuserphoto.ru/s/v1/ig2/aENkgeK-rMWuyvijkI9qbLwT2FKdKzQ7ylJNIReC-IivmsX_O2Wk7NXy8nCcNDFLKZibSQH2LO6zvxGUJuF9Bztr.jpg?quality=95&amp;as=32x17,48x25,72x37,108x56,160x83,240x124,360x186,480x249,540x280,640x332,720x373,1056x547&amp;from=bu&amp;cs=1056x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nИ в рамках отдельного запроса\n<img src=\"https://sun9-29.vkuserphoto.ru/s/v1/ig2/5Z8ha7ZQ7F2IqjmxlrC2DbyaleP9w_0mdR4wBCbQtTm7DGcOBURXasfQhrXudKXCIvkZ-T71BwNHCIoP8Ivbu9xh.jpg?quality=95&amp;as=32x13,48x19,72x28,108x42,160x63,240x94,360x141,480x188,540x212,640x251,720x282,1080x423,1280x502,1311x514&amp;from=bu&amp;cs=1311x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\n<p style=\"color:red\">В более новых версиях Postman функция Test переименована в Post-response. И он находится в scripts &gt; Post-response</p>\n<img src=\"https://sun9-3.vkuserphoto.ru/s/v1/ig2/dlRuLUhPcIny_Yn-UuoNDTxhqFaaYtGxhMFziXYOrklRAP8LqLkiTytrGIsYqCW5qEPBwS4VDyV072m94tFl2kse.jpg?quality=95&amp;as=32x21,48x32,72x47,108x71,160x105,240x158,360x237,480x316,540x356,640x422,720x475,1080x712,1280x844,1353x892&amp;from=bu&amp;cs=1353x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь давайте сделаем следующее. Выберем коллекцию Pet Store и в ней на вкладке Pre-request script напишем console.log(\"Pre-request script collection\"). Этот код выводит надпись \"Pre-request script collection\" в консоль\n<img src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/Q4r_YRlt4_feYz5NB41rqX8MMpdTY9UGD_HorEdk0ibmlGS2vdQDkfEVKPTnPDTuldmJ5xwexr9T-kqSU5hdS0wW.jpg?quality=95&amp;as=32x11,48x16,72x24,108x36,160x53,240x80,360x120,480x160,540x180,640x214,720x240,1080x360,1280x427,1440x481,1570x524&amp;from=bu&amp;cs=1570x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь тоже самое сделаем для вкладки Tests и напишем console.log(\"Tests collection\")  и не забываем сохранить. \n<img src=\"https://sun9-42.vkuserphoto.ru/s/v1/ig2/lLNnjKVXaWkMeCj1wJ8cfwTSL5Z31L4_T4k4Sx7xNL6RatwRwCmBtTta6puHh-Yo3RgdBAepG7sxTKWJBIWnntlx.jpg?quality=95&amp;as=32x11,48x16,72x24,108x36,160x53,240x80,360x120,480x159,540x179,640x213,720x239,1080x359,1280x425,1440x478,1520x505&amp;from=bu&amp;cs=1520x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее то же самое проделываем для папки, только пишем\nconsole.log(\"Pre-request script folder\") и  console.log(\"Tests folder\")\n<img src=\"https://sun9-44.vkuserphoto.ru/s/v1/ig2/RQAQ2bjG1ug126vcfL7PefB0FVJ2KFzDDgivI4elkxJfH04QW7zwHXuwRj-nUrbxnrtRNJADmDkja6Ro3dmg44jQ.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x202,540x227,640x269,720x303,1080x454,1177x495&amp;from=bu&amp;cs=1177x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<img src=\"https://sun9-44.vkuserphoto.ru/s/v1/ig2/RQAQ2bjG1ug126vcfL7PefB0FVJ2KFzDDgivI4elkxJfH04QW7zwHXuwRj-nUrbxnrtRNJADmDkja6Ro3dmg44jQ.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x202,540x227,640x269,720x303,1080x454,1177x495&amp;from=bu&amp;cs=1177x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ аналогично делаем для первого запроса, console.log(\"Pre-request script request\") и console.log(\"Tests request\")\n<img src=\"https://sun9-9.vkuserphoto.ru/s/v1/ig2/4pVcS5MoOOt0lVqm6SNlR3RiHL7skGkPY9NkEFC7rSyMhWtxcKdTbtBXwHOgnGtFfePz_lyivIA5FisFC-jBmja1.jpg?quality=95&amp;as=32x12,48x18,72x28,108x41,160x61,240x92,360x138,480x184,540x207,640x245,720x275,1080x413,1153x441&amp;from=bu&amp;cs=1153x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<img src=\"https://sun9-64.vkuserphoto.ru/s/v1/ig2/UEtGSduv0HlFUlDUddqTfw9IZ2rDSJSeZw5iXLc1lgDceBEWyotFL5q_eU05NgRhaLHhvwlBLVcrxGSI92IamXHj.jpg?quality=95&amp;as=32x12,48x18,72x27,108x41,160x60,240x90,360x135,480x180,540x203,640x240,720x270,1080x405,1280x480,1356x509&amp;from=bu&amp;cs=1356x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЗапускаем нашу коллекцию\n<img src=\"https://sun9-58.vkuserphoto.ru/s/v1/ig2/YJ76r89pp8ASfiNoEnwlhPzJWbHqHgNSYkD1iJt54ixd400sRw70s4vt-3g1B8JsaJ1zy6m7QcmkHthDivsQMyMs.jpg?quality=95&amp;as=32x32,48x47,72x71,108x107,160x158,240x237,360x355,480x474,540x533,640x631,676x667&amp;from=bu&amp;cs=676x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПусть будет одна итерация\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/u3YE54X84kLY9RFRtCqbzGgSbmGEcSgHLP9qQAMsmIj3ydGj1RcBKPR1d5LbLp-DYZ0-Mk6tFE4dByy75-OoByQ5.jpg?quality=95&amp;as=32x21,48x31,72x47,108x70,160x104,240x156,360x234,480x312,540x350,640x415,720x467,1080x701,1280x831,1305x847&amp;from=bu&amp;cs=1305x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nРаскрываем консоль\n<img src=\"https://sun9-54.vkuserphoto.ru/s/v1/ig2/5-HCRUayMJU-pBUTTe7Tc1K_WOhuL2QGp-3HQiK_9AMFr57vOXAp2WEUHskK1bPiVG3NL8o8IfBGCXgU-E5m1Bl_.jpg?quality=95&amp;as=32x26,48x38,72x58,108x86,160x128,240x192,360x288,480x384,540x431,640x511,720x575,1080x863,1280x1023,1393x1113&amp;from=bu&amp;cs=1393x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ видим следующую картину\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/BuiyZODMUu1KrZ1a7YpfufrUT2GERGhsZ2f0A_oIFHegwm72ELKXidp--0sZwc12J0xf7kqoOBZYfjev9O-j6znQ.jpg?quality=95&amp;as=32x17,48x25,72x38,108x57,160x85,240x127,360x191,480x255,501x266&amp;from=bu&amp;cs=501x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nЭто значит, что у нас вначале запустился Pre-request script для коллекции, потом запустился Pre-request script для папки, потом запустился Pre-request script для запроса. Все эти Pre-request scripts были до отправки запроса. Потом отправился запрос методом POST, пришел ответ и запустился test в рамках коллекции, потом запустился тест в рамках папки и потом запустился тест в рамках отравленного запроса и полученного ответа.\n<hr>\nИ это подтверждает следующая схема ниже\n<img src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/Rtgp6IxLJ87Y0MiSrLnOvvbM4B6pG9ZtSBjaUis7nUSeZ8C4BOd9rznh62z9pA_dJeQnM7I_o-P8_bRYpAoE-tkC.jpg?quality=95&amp;as=32x11,48x17,72x25,108x38,160x56,240x84,360x126,480x167,540x188,640x223,720x251,1080x377,1280x447,1307x456&amp;from=bu&amp;cs=1307x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details>\n<summary>Pre-request</summary><div>\nДля изучения возможностей  Pre-request Script-ов мы воспользуемся  <a href=\"https://postman-echo.com/\" target=\"_blank\">https://postman-echo.com/</a>, это сайт, на котором мы можем тренироваться писать наши http запросы и передавать на этот сайт различные данные.\n<hr>\nСоздадим коллекцию postman-echo\n<img src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/i5VlooRRi6MDD5u2QpsVidTty8ckuBtblV6ybn1R5jzIyXs-kqddcM3yc9lLA29A_HcgOg1w5RjFyixg9yQ6Y4Sa.jpg?quality=95&amp;as=32x18,48x26,72x40,108x60,160x88,240x132,360x199,480x265,540x298,640x353,720x397,1080x596,1147x633&amp;from=bu&amp;cs=1147x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДобавим два запроса. Первый запрос мы делаем с типом post на адрес https://postman-echo.com/post с query параметром name равным Oleg\n<img src=\"https://sun9-69.vkuserphoto.ru/s/v1/ig2/DlVp4jpF_MtcguVDxEnV1LpvvkXTzrbVzq7B-0huV0NJv2K6ulgIZjxzFfUiOjwRMRZf3jKP5oYIYdCvdtddYtPw.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x76,240x113,360x170,480x227,540x255,640x302,720x340,1080x510,1280x605,1350x638&amp;from=bu&amp;cs=1350x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНа вкладке Tests у нас будет следующая строчка pm.collectionVariables.set(\"param\", JSON.parse(responseBody).args.name)\n<img src=\"https://sun9-27.vkuserphoto.ru/s/v1/ig2/jEDhhoxUpJeUl9aY1dvxO3oxQa4G6WSb_z1cx9fnX6B3-bQUyzT6NcdEuz9ZEcZZrC3lBFq0i266dhvKeNdjQXYT.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x101,360x151,480x202,540x227,640x269,720x302,1080x453,1280x537,1410x592&amp;from=bu&amp;cs=1410x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажимаем на send и получаем ответ\n<img src=\"https://sun9-35.vkuserphoto.ru/s/v1/ig2/Q_iy8kS0297KRtQTYTiybxKCEHM4RcXbj2jBzRg24uEdCa92ShkZ-rh74w6FmC2jSyePRfA0x4aPweKTSyrhENHK.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720,1440x810,1914x1076&amp;from=bu&amp;cs=1914x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nСтрока pm.collectionVariables.set(\"param\", JSON.parse(responseBody).args.name) на Postman означает:\n<b>- pm.collectionVariables.set:</b> Эта команда используется для сохранения значения в переменной коллекции. Переменные коллекции доступны во всех запросах в рамках коллекции.\n<b>- \"param\":</b> Это имя переменной, в которую мы сохраняем значение.\n<b>- JSON.parse(responseBody):</b> Эта функция преобразует ответ сервера (responseBody) из JSON-формата в объект JavaScript.\n<b>- .args.name:</b> Это ключ в объекте JavaScript, из которого мы извлекаем значение.\n<hr>\nДалее переключаемся на коллекцию postman-echo и на вкладке Variables param заполнилось значением Oleg\n<img src=\"https://sun9-65.vkuserphoto.ru/s/v1/ig2/GASqIMO-tcA1gk7fRZkyb3KM-kl1X4qh1bH75l-bjZLw637uXKi6Xy_YcF0UKxk21v3MQtSrzEG_8MeGra3wWhjL.jpg?quality=95&amp;as=32x11,48x16,72x25,108x37,160x55,240x82,360x123,480x164,540x184,640x218,720x245,1080x368,1280x436,1440x491,1526x520&amp;from=bu&amp;cs=1526x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее создаем следующий запрос с типом GET где мы на https://postman-echo.com/get передаем query параметр param со значением {{param}}\n<img src=\"https://sun9-85.vkuserphoto.ru/s/v1/ig2/cjjkv381oO7f_bGDMuE58Wuzi0mmKOli0b6nco0r2aYqnETxSBUGWi-Ft8I_ER_HYLJkF-BAWoVWo6cbYAau71QB.jpg?quality=95&amp;as=32x11,48x16,72x24,108x37,160x54,240x81,360x122,480x163,540x183,640x217,720x244,1080x366,1280x434,1440x489,1553x527&amp;from=bu&amp;cs=1553x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНа вкладке Pre-request Script пишем следующее:\nvar firstName = pm.collectionVariables.get(\"param\");\npm.collectionVariables.set(\"param\", firstName+\"Malyshev\");\n<img src=\"https://sun9-47.vkuserphoto.ru/s/v1/ig2/m057VVe6BXwLchRAX0DRdNxDCb3lvSn71EaOBwhoNY0iarMhKlglMB5wxBrQwELmyyW3po_uIi7C1kjyUja9I4RJ.jpg?quality=95&amp;as=32x24,48x35,72x53,108x80,160x118,240x177,360x265,480x354,540x398,640x471,720x530,888x654&amp;from=bu&amp;cs=888x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЧто означают эти строчки:\n<b>1. var firstName = pm.collectionVariables.get(\"param\");:</b>\n<i>pm.collectionVariables.get(\"param\"):</i> Эта команда получает значение из переменной коллекции с именем \"param\".\n<i>var firstName:</i> Это переменная, в которую мы сохраняем полученное значение.\n<b>2. pm.collectionVariables.set(\"param\", firstName+\"Malyshev\");:</b>\n<i>pm.collectionVariables.set: </i>Эта команда сохраняет значение в переменной коллекции.\n<i>\"param\": </i> Это имя переменной, в которую мы сохраняем значение.\n<i>firstName+\"Malyshev\":</i> Это новое значение, которое мы сохраняем.\n- <i>firstName:</i> Это переменная, которая содержит имя пользователя.\n- <i>\"Malyshev\":</i> Это добавленная строка.\n<hr>\nИными словами, эта строка кода:\nПолучает имя пользователя из переменной коллекции с именем \"param\".\nДобавляет к имени пользователя строку \"Malyshev\".\nСохраняет новое значение в переменной коллекции с именем \"param\".\n<hr>\nДалее на вкладке Tests давайте запишем эту строчку console.log(pm.collectionVariables.get(\"param\"))\n<img src=\"https://sun9-56.vkuserphoto.ru/s/v1/ig2/SyiNAE4Z_tBwGQDC05_Z11gELxmTkw4zWxEKPDy-Imq4WQ2VkH9ntAUid0iL-3okPxScCNwWwD3yB86TwL3wA6yt.jpg?quality=95&amp;as=32x24,48x35,72x53,108x80,160x118,240x177,360x266,480x355,540x399,640x473,720x532,1080x798,1280x946,1440x1064,1468x1085&amp;from=bu&amp;cs=1468x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЧто означает эта строчка:\n<b>console.log:</b> Эта команда выводит сообщение в консоль Postman.\n<b>pm.collectionVariables.get(\"param\"):</b> Эта команда получает значение из переменной коллекции с именем \"param\".\nИными словами, эта строка кода:\nВыводит значение переменной коллекции с именем \"param\" в консоль Postman.\n<hr>\nНажимаем на send и получаем следующую строчку\n<img src=\"https://sun9-36.vkuserphoto.ru/s/v1/ig2/B6Ja8NFVdXKNdfDLpnKz8xKGTt0WN-oTkc4ZPbco1XSP_bs4VpWvVxMrd73hULsIQE09PlU8XpHhbMyKw8yuHtLS.jpg?quality=95&amp;as=32x16,48x23,72x35,108x52,160x78,240x116,360x175,480x233,540x262,640x311,720x349,1080x524,1280x621,1440x699,2141x1039&amp;from=bu&amp;cs=2141x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПолучается еще раз, коротко, что мы сделали\n- <b>var firstName = pm.collectionVariables.get(\"param\"); </b> - выдернули значение из param, которое мы заполнили после первого запроса и присвоили значение из param в firstName\n- <b>pm.collectionVariables.set(\"param\", firstName+\"Malyshev\");</b> - Далее мы присвоили в param новое значение переменной  firstName+\"Malyshev\"\n- <b>далее выполняется запрос</b> https://postman-echo.com/get?param={{param}} где мы в param присваиваем значение из param (а сейчас в нем новое значение Oleg Malyshev\n- <b>После запроса</b> у нас в теле возвращается в в аргументах param: \"Oleg Malyshev\" и после выполнения теста у нас выводится значение из переменной param в консоль\n<img src=\"https://sun9-36.vkuserphoto.ru/s/v1/ig2/B6Ja8NFVdXKNdfDLpnKz8xKGTt0WN-oTkc4ZPbco1XSP_bs4VpWvVxMrd73hULsIQE09PlU8XpHhbMyKw8yuHtLS.jpg?quality=95&amp;as=32x16,48x23,72x35,108x52,160x78,240x116,360x175,480x233,540x262,640x311,720x349,1080x524,1280x621,1440x699,2141x1039&amp;from=bu&amp;cs=2141x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>\n<details>\n<summary>Tests  (Post-response) - первый автотест</summary><div>\n<p style=\"color:red\">В более новых версиях Postman функция Test переименована в Post-response. И он находится в scripts &gt; Post-response</p>\n<img src=\"https://sun9-3.vkuserphoto.ru/s/v1/ig2/dlRuLUhPcIny_Yn-UuoNDTxhqFaaYtGxhMFziXYOrklRAP8LqLkiTytrGIsYqCW5qEPBwS4VDyV072m94tFl2kse.jpg?quality=95&amp;as=32x21,48x32,72x47,108x71,160x105,240x158,360x237,480x316,540x356,640x422,720x475,1080x712,1280x844,1353x892&amp;from=bu&amp;cs=1353x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь давайте приступим к автотестам. И прежде чем к ним приступить, я хотел бы сделать, чтобы в первом запросе post-ом, мы бы создавали каждый раз новое животное, после выполнение запроса присваивали бы значение этого id этого животного в переменную pet_id и все последующие запросы проводились бы с этим pet_id. Таким образом каждые раз, когда мы будем запускать нашу коллекцию с автотестами, все запросы будут производиться с новым id.\n<hr>\nДавайте это сделаем, для этого в первом нашем запросе, в котором мы создаем животное заменяем  id животного 444555, на {{$randomInt}}. Этой строчкой генерируется случайное число.\n<img src=\"https://sun9-13.vkuserphoto.ru/s/v1/ig2/enryRpaJywLavNlKkwbXjgqts_2VotprCemWWnTe_5qQgd4A5CNM888lQZ6OPNOPId9Q0_xbFolyQvf4ZGWEKBuv.jpg?quality=95&amp;as=32x14,48x21,72x32,108x47,160x70,240x105,360x158,480x210,540x237,640x280,720x316,1080x473,1280x561,1440x631,1659x727&amp;from=bu&amp;cs=1659x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее на вкладке Tests первой строчкой мы запишем следующее: pm.collectionVariables.set(\"pet_id\", pm.response.json().id)\n<img src=\"https://sun9-59.vkuserphoto.ru/s/v1/ig2/XT4fO1zFfdrDRaGe1X5Rt0X51IBn0LpbQOUgfYVahA6iJmfccWdBdB-rTABfoV9NJr_h5pyi3DTX3o6StMDFhhoO.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x59,240x89,360x133,480x177,540x200,640x236,720x266,1080x399,1280x473,1440x532,1586x586&amp;from=bu&amp;cs=1586x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЭта строка кода устанавливает значение переменной коллекции pet_id равным значению id из JSON-ответа. Если переменной pet_id не существует, то она создаться. Давайте это проверим, зайдем в переменные нашей коллекции и убедимся, что там единственная переменная, это per_store\n<img src=\"https://sun9-69.vkuserphoto.ru/s/v1/ig2/zQBrJWVSQdEnQ3saYfbrjuHNUk8UCqcUKKm7KuOnUVOThKB5WpPoLzvASQy48Ej6fsK3GkKSxGPBLCW2W-KnFZg3.jpg?quality=95&amp;as=32x14,48x22,72x33,108x49,160x72,240x109,360x163,480x217,540x245,640x290,720x326,1080x489,1280x580,1440x652,1620x734&amp;from=bu&amp;cs=1620x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь запишем, отправим наш запрос и видим что у нас сгенерировался  id 575 и вернулся в теле ответа\n<img src=\"https://sun9-44.vkuserphoto.ru/s/v1/ig2/cmVgyi11q24KibdB1hfFmHnM_84-z6e6KJ8SWihoVXlHAzEeozFg4h7rpDHaJpPmRMLx07BTU2d-c3zvCnPYPCtW.jpg?quality=95&amp;as=32x23,48x34,72x52,108x77,160x115,240x172,360x258,480x344,540x387,640x459,720x516,1080x775,1280x918,1440x1033,1701x1220&amp;from=bu&amp;cs=1701x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь возвращаемся в переменные нашей коллекции и видим, что у нас создалась переменная pet_id и в нее записалось значение 575\n<img src=\"https://sun9-75.vkuserphoto.ru/s/v1/ig2/GAQUOVUBk5ckI7cajv_qZk1aTUQDr7cQAIMlY5GvxPKLnTxydfFIyxMi-f9zS-WWPV2d0hoBKjIwGM1Gl_Y8AGTl.jpg?quality=95&amp;as=32x18,48x27,72x41,108x62,160x91,240x137,360x205,480x274,540x308,640x365,720x411,1080x616,1280x730,1440x821,1622x925&amp;from=bu&amp;cs=1622x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВозвращаемся на вкладку Tests и посмотрим, что мы можем сделать. И здесь, не зная программирования мы можем воспользоваться готовыми снипетами и давайте кликнем на первый из них это проверка статус кода ответа.\n<img src=\"https://sun9-41.vkuserphoto.ru/s/v1/ig2/9tU4Yw9V_KuqDEmhavm_np8gL8LT-rlT6Ah9FWN5P5GBPPPfWE6i0J_FD83r5q7Dm3RiQ3BWXjlz_ZYslARKQSRG.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x76,240x114,360x171,480x229,540x257,640x305,720x343,1080x514,1280x609,1440x686,1945x926&amp;from=bu&amp;cs=1945x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nУ нас добавилась следующая строчка\n<img src=\"https://sun9-47.vkuserphoto.ru/s/v1/ig2/oxoqjD8Fqv02lK6p0AKAl4XnMW2ub2XiRFaTliff56ircHPWc8Lk9tkRsg-mEoYS1Bq6SAVN1MSbxQp4gvoG6GcL.jpg?quality=95&amp;as=32x20,48x30,72x45,108x67,160x100,240x149,360x224,480x299,540x336,640x398,720x448,1080x672,1280x797,1440x896,1496x931&amp;from=bu&amp;cs=1496x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЭтот код выше проверяет, что сервер вернул код ответа 200. Если код ответа не 200, тест будет завершен неудачей.\n<b>pm.test</b> - это функция Postman, которая используется для запуска тестового сценария.\n<b>\"Status code is 200\"</b> - это текстовое описание, которое будет отображаться в Postman для данного теста.\n<b>function () {</b> - это начало функции, которая содержит код для проверки.\n<b>pm.response</b> - это объект, который содержит информацию о полученном от сервера ответе.\n<b>to.have</b> - это метод, который используется для проверки различных аспектов ответа.\n<b>status(200)</b> - это метод, который проверяет код ответа. В данном случае он проверяет, что код ответа равен 200, что означает \"OK\".\n<hr>\nИ я вас поздравляю, мы с вами написали наш первый автотест, которой будет при каждой отправке запроса проверять, что нам вернулся код 200 и если код будет не 200, то тест будет падать.\n</div></details>\n<details>\n<summary>Tests (Post-response) - более сложный автотест</summary><div>\n<p style=\"color:red\">В более новых версиях Postman функция Test переименована в Post-response. И он находится в scripts &gt; Post-response</p>\n<img src=\"https://sun9-3.vkuserphoto.ru/s/v1/ig2/dlRuLUhPcIny_Yn-UuoNDTxhqFaaYtGxhMFziXYOrklRAP8LqLkiTytrGIsYqCW5qEPBwS4VDyV072m94tFl2kse.jpg?quality=95&amp;as=32x21,48x32,72x47,108x71,160x105,240x158,360x237,480x316,540x356,640x422,720x475,1080x712,1280x844,1353x892&amp;from=bu&amp;cs=1353x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь вернемся к нашим сниппетам и кликнем на следующий сниппет\n<img src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/XBJDb4_eQS6exQ72IAwy2TQcuHD_hmx1DE0NtptIt2p7O3Uh0gurhK_MdyCcoXabfnUpHp69OBgEHwO56AafY94l.jpg?quality=95&amp;as=32x19,48x28,72x42,108x63,160x94,240x141,360x211,480x281,540x316,640x375,720x422,1080x633,1280x750,1440x843,1470x861&amp;from=bu&amp;cs=1470x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВ тестах отобразится следующий код\n<img src=\"https://sun9-20.vkuserphoto.ru/s/v1/ig2/T-ge_36Q3_4DC2EKRPi9fdDrfkqVZyXU6jeyEzOOBs7MtM_c5Q6hNn3NoFa17eI541lJh75uIoJ2JYxkgN1v5pLd.jpg?quality=95&amp;as=32x18,48x27,72x41,108x61,160x91,240x136,360x205,480x273,540x307,640x364,720x409,1080x614,1114x633&amp;from=bu&amp;cs=1114x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nУ нас в ответе от сервера всегда должен быть заголовок Content-Type. И этот код выше проверяет, присутствует ли заголовок \"Content-Type\" в ответе сервера. Если заголовок отсутствует, тест провалится.\n<hr>\nЗначение заголовка \"Content-Type\":\n1) Указывает браузеру или другому клиенту, как правильно обработать информацию, полученную от сервера.\n2) Распространённые типы: \"text/html\" для веб-страниц, \"application/json\" для данных в формате JSON, \"image/jpeg\" для изображений JPEG и т.д.\n<b>-pm.test</b> - как и в предыдущем примере, эта функция запускает тестовый сценарий.\n<b>-\"Content-Type is present\"</b> - название теста, которое будет отображаться в Postman.\n<b>- function () {</b> - начало функции, содержащей код проверки.\n<b>- pm.response</b> - объект с информацией о полученном от сервера ответе.\n<b>- to.have.header</b> - метод, проверяющий наличие определенных заголовков в ответе.\n<b>- \"Content-Type\"</b> - искомый заголовок.\n<hr>\nВернемся к нашим сниппетам и кликнем на следующий сниппет.\n<img src=\"https://sun9-22.vkuserphoto.ru/s/v1/ig2/OaRay8kLltZ0Uzd0CzjDYsMXM-Ism_D9URyS-826IupWffjzX5dlkZyW1leMmtyk0C9QOMep-dAMQY-RGs5DZfia.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x80,240x120,360x180,480x240,540x269,640x319,720x359,1080x539,1280x639,1440x719,1481x739&amp;from=bu&amp;cs=1481x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ в появившемся коде давайте заменим 200 на 2000 мс\n<img src=\"https://sun9-54.vkuserphoto.ru/s/v1/ig2/_xqF9V2uoc5rdVzKUQgAl3LichFPSFaRQop8SWbpCPFC6wvlJkTdd5Lu-hHx0nCX3sjynUN_hdg0MgayVMcyPled.jpg?quality=95&amp;as=32x20,48x31,72x46,108x69,160x102,240x153,360x230,480x306,540x344,640x408,720x459,1080x689,1113x710&amp;from=bu&amp;cs=1113x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nИ как вы уже догадались, этот тест проверяет следующее, ответил ли сервер на запрос менее чем за 2 секунды (2000 мс). Если ответ занимает больше 2 секунд, тест будет завершен неудачно.\n<hr>\nДавайте теперь попробуем, что-то сложнее и проверим, что тот id, который мы получаем в теле ответа равен переменной pet_id.\nСнова идем в наши сниппеты, выбираем Response body: JSON value check\n<img src=\"https://sun9-44.vkuserphoto.ru/s/v1/ig2/3u3N6_lg16MZ6A85HZnRdbuToKpyv2RQrBH4sOkF7eyijciyh4o47meJuYJDmYVaSUAe2DnBy21xRUALNbMkJc7r.jpg?quality=95&amp;as=32x17,48x26,72x39,108x58,160x86,240x129,360x193,480x258,540x290,640x344,720x387,1080x580,1280x687,1440x773,1469x789&amp;from=bu&amp;cs=1469x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ давайте напишем следующий тест\n<img src=\"https://sun9-57.vkuserphoto.ru/s/v1/ig2/1y3PZKIk3mQX2DT1v3HEi8WMKP_fD70hVgnv3gFui9ZRTr-QwBUFKk_QA4XW--3S2ezTv94Fr9Mb4GADe__W20Qi.jpg?quality=95&amp;as=32x16,48x23,72x35,108x53,160x78,240x117,360x176,480x234,540x264,640x313,720x352,1042x509&amp;from=bu&amp;cs=1042x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nЭтот тест проверят, что id, который возвращается нам в ответе, равен id, который находится в pet_id.  Давайте нажмем на Send и выполним наш запрос и как мы видим запрос выполнен успешно и все 4 теста прошли\n<img src=\"https://sun9-38.vkuserphoto.ru/s/v1/ig2/HQk1gh0iQlhMjfHVTgfj2ioy7u21xpiHKFgHMFIjOHxY9KKpydZOf6hNvM9M7kuTw9dgmAeWYVSXFunwe_h8g6NF.jpg?quality=95&amp;as=32x24,48x35,72x53,108x80,160x118,240x177,360x266,480x355,540x399,640x473,720x532,1080x798,1280x945,1440x1064,1492x1102&amp;from=bu&amp;cs=1492x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПереключимся на вкладку Tests Result и видим более детально наши тесты и также видим, что они все прошли:\n<img src=\"https://sun9-67.vkuserphoto.ru/s/v1/ig2/nxX5neqdV0vniibK0zB-YXNnzzradgRTOolGGn3Bsey1zyWOU5R_C2c5-chdZXhPqWyc25H5SmyyFef3KLTytNpT.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x100,240x150,360x226,480x301,540x338,640x401,720x451,1080x677,1280x802,1423x892&amp;from=bu&amp;cs=1423x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте вернемся в body и посмотрим какие параметры мы еще передавали, а это id категории 4444, имя животного Jack и название категории dogs\n<img src=\"https://sun9-65.vkuserphoto.ru/s/v1/ig2/ndadGS4V35PHyhICKyWbb0nwtOQr3b_zm3VIknG_x8s1l0aRoU2cFde6IGYx4TJL1lQf1EBsYvbS9xkBebe4z2Pz.jpg?quality=95&amp;as=32x23,48x35,72x52,108x79,160x117,240x175,360x262,480x350,540x394,640x466,720x525,922x672&amp;from=bu&amp;cs=922x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ эти параметры нам должны вернуться в ответе в виде json и давайте это проверим и напишем три теста, которые будут проверять, что нам вернулась id категории 4444, название категории dogs и имя животного Jack. Для этого давайте кликнем три раза на тот же снимет, который мы выбирали в прошлый раз Response body: JSON value check. И наши итоговые тесты будут следующими:\n<img src=\"https://sun9-38.vkuserphoto.ru/s/v1/ig2/3Y2sSq9BYSbRZHOBV3Obg55OkLghMwlSDJnqMCGJAgGPYiPhprSRyWU9JaUzaCYGFIVwVicDsW1iXpzWbnu9Q6Vt.jpg?quality=95&amp;as=32x27,48x40,72x60,108x90,160x133,240x199,360x299,480x398,540x448,640x531,720x597,1038x861&amp;from=bu&amp;cs=1038x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте снова нажмем на send и отправим наш запрос и как мы видим все 7 тестов из 7 прошли успешно\n<img src=\"https://sun9-67.vkuserphoto.ru/s/v1/ig2/BlVDaoJYcVa4Eypluf22KE9edyBo0dFHdSnJElMOXAw7bLu54EvIz2AW6ztQTwBaZv1ibq01LpRnDEAad2HpI2PU.jpg?quality=95&amp;as=32x19,48x29,72x44,108x66,160x97,240x146,360x219,480x292,540x329,640x389,720x438,945x575&amp;from=bu&amp;cs=945x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь в запросе в body давайте мы поменяем имя животного, мы будем передавать имя не Jack, а Barsik и снова отправим наш запрос\n<img src=\"https://sun9-80.vkuserphoto.ru/s/v1/ig2/IMG17d5cneNYcrHSk5BC8vlF98sPjzi9fgIMEKxZEsX08Ug-vV_fPpA7lp-NZ9Fs7bqAh8SsKZZgaCzhrHn6Yn0N.jpg?quality=95&amp;as=32x14,48x21,72x31,108x47,160x70,240x105,360x157,480x209,540x235,640x279,720x314,1080x470,1280x557,1403x611&amp;from=bu&amp;cs=1403x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ как мы видим у нас один тест упал, в тесте как раз и пишется, что нам пришедший Barsik не равен Jack\n<img src=\"https://sun9-3.vkuserphoto.ru/s/v1/ig2/lTB8DDbFbz83xidJv7ZwzzO85BOfuI7P4Hj8wmtAVBvPdKLYR5LTUTkI41ECGyka0FGBzTDiuaIqWs3uzhFQqrrb.jpg?quality=95&amp;as=32x17,48x25,72x37,108x56,160x83,240x124,360x186,480x248,540x279,640x331,720x372,1080x558,1121x579&amp;from=bu&amp;cs=1121x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте попробуем покрыть тестами следующий метод, который добавляет фотографию и метаданные для нашего животного. И как мы видим в запросе мы прописываем id животного, у которого мы хотим сделать. Это path параметр. Но помните, что мы с вами хотим работать во всех запросах с id животным, который создавали в первом методе.\n<img src=\"https://sun9-82.vkuserphoto.ru/s/v1/ig2/o6Cb0F9_B9mq1c7VZe5p9YnaniU90rrNVJ5JJxJoM2BDbwGF-gpZsZBeW3MduWCavXLTVWUMpzX_Q4aqnzHm3JC5.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x100,360x150,480x200,540x225,640x267,720x301,1080x451,1207x504&amp;from=bu&amp;cs=1207x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВместо 444555 мы напишем :petId и смотрите что происходит, автоматом появляется path параметр с ключом petId\n<img src=\"https://sun9-24.vkuserphoto.ru/s/v1/ig2/7UEGTSGAJXtLKoT6CrBQHmbIyj_sw-i8IxFGIvVaas3dS7dSpkbMwRByWmhTunJp7hsV8AqLwNDGnVqV8kZqEYw2.jpg?quality=95&amp;as=32x13,48x20,72x30,108x44,160x66,240x99,360x148,480x197,540x222,640x263,720x296,1080x444,1273x523&amp;from=bu&amp;cs=1273x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ теперь в значение ключа мы пишем {{pet_id}} , в которой будет наше значение от предыдущего запроса. Выполняем запрос и видим, что нам вернулся 200 код ответа\n<img src=\"https://sun9-41.vkuserphoto.ru/s/v1/ig2/bJ8Xx4A5JIi_ZmnvlQcAnk8dxlAOIpMUgBRJixQW1GeAAasAKSU1x1d2Dr8qYFGKLPM-RBV9715wl_jYjBgqbna8.jpg?quality=95&amp;as=32x21,48x32,72x48,108x72,160x107,240x160,360x240,480x320,540x360,640x427,720x481,1080x721,1280x854,1440x961,1474x984&amp;from=bu&amp;cs=1474x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВ нем содержится название нашего файла и мета информация которую мы передавали в body &gt; formData \n<img src=\"https://sun9-13.vkuserphoto.ru/s/v1/ig2/88C8NuwDV7yNOQ67GObgiHpEulz96vNAp63mvpS3oBBmh4FVYUf6Xeh_fLDk7qFabyMk8_jgFC1rZQlFIdkzFszC.jpg?quality=95&amp;as=32x25,48x37,72x56,108x83,160x123,240x185,360x278,480x370,540x417,640x494,720x556,1016x784&amp;from=bu&amp;cs=1016x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПервые три теста, аналогичные, какие были для прошлого запроса, мы проверяем что запрос успешный, а это значит код ответа 200, что запрос выполняется не больше 2 секунд и что возвращается заголовок Content-Type. Следующие два теста:\n- Первый тест проверяет, что в ответе в значении message содержится текст avatar, это значение, которое мы передавали в additionalMetadata\n- Второй тест проверяет, что в ответе в значении message содержится текст logo.jpeg, это тот файл, который мы передавали в file.\n<hr>\nОтправляем наш запрос и как мы видим все 5 тестов прошли\n<img src=\"https://sun9-56.vkuserphoto.ru/s/v1/ig2/9GI986LSR1ddtnDV5K8GJm7AnedkhKANkWYCdP2uRBrTg0-I3awrXfp1s6EGEhFvXzV5q0bHyRLftAYuVJgqSVXL.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x80,240x121,360x181,480x242,540x272,640x322,720x362,952x479&amp;from=bu&amp;cs=952x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТеперь запустим всю коллекцию\n<img src=\"https://sun9-42.vkuserphoto.ru/s/v1/ig2/AlkEVjUXwkrF2WjwNLnHeTs_Uwjcse2tF-2LPx6nA2cxL7ng7bybaMk2qItwullqlhvMY4JsnrxdimarsNI5kK43.jpg?quality=95&amp;as=32x24,48x36,72x54,108x81,160x119,240x179,360x269,480x358,540x403,640x478,720x538,967x722&amp;from=bu&amp;cs=967x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажмем на View Results\n<img src=\"https://sun9-74.vkuserphoto.ru/s/v1/ig2/zbUTe_a8E_A_5vvwsbv0WusaAK0MEjSDvedR50oEUYzLqMVZVXojolY88WV4ivIolX5siT6lob-FknPwv8Tuu7Mr.jpg?quality=95&amp;as=32x14,48x20,72x30,108x46,160x68,240x101,360x152,480x203,540x228,640x270,720x304,1080x456,1280x540,1440x608,1485x627&amp;from=bu&amp;cs=1485x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВидим, что все тесты прошли\n<img src=\"https://sun9-68.vkuserphoto.ru/s/v1/ig2/LsPlrmRvEFLbFIFG40SRyHujLhtpZQX46ee1ItjIJpGVFQGgUJHVU_Mq1Rc37M9hg_mXO2nvOyDWbZFSZ28wnvJg.jpg?quality=95&amp;as=32x22,48x34,72x50,108x76,160x112,240x168,360x252,480x337,540x379,640x449,720x505,1080x757,1280x898,1440x1010,1483x1040&amp;from=bu&amp;cs=1483x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНа все последующие методы я предлагаю вам написать тесты самостоятельно\n</div></details>\n<hr>\n<h3>Templates и Public APIs</h3>\n<b>Postman Templates:</b>\nэто готовые заготовки коллекций/запросов/workflow, которые Postman предоставляет как стартовые примеры.\nОни нужны, чтобы:\n- быстро создать новую коллекцию без ручной настройки;\n- посмотреть типовые структуры API-тестов;\n- использовать повторяемые паттерны (auth flow, CRUD flow и т.д.).\nПо сути - \"шаблоны\", чтобы не плодить велосипед.\n<b>Public APIs:</b>\nэто каталог открытых API, опубликованных компаниями и разработчиками прямо в Postman. Они доступны всем пользователям.\nДля QA это полезно потому что:\n- можно тренировать тестирование API на реальных сервисах (NASA, Slack, Spotify, PayPal и т.д.);\n- можно импортировать эти API в свою workspace и сразу иметь готовые коллекции запросов;\n- можно смотреть, как должны выглядеть хорошо оформленные API-коллекции.\n<hr>\n<b>Templates</b> - это шаблоны действий (как тестировать, как строить коллекции).\n<b>Public APIs</b> - это реальные API сторонних сервисов, которые можно дергать.\n\n<details>\n<summary>Шаблоны и публичные API в postman</summary><div>\nДля того, чтобы добавить к себе коллекции с публичных api или даже целые  workspace-ы, нам необходимо кликнуть сюда\n<img src=\"https://sun9-41.vkuserphoto.ru/s/v1/ig2/uS38yiBjKTRwv37veMbQwYfqgCbyt9qmT2LHi38VUeuTgEU83ZIbK1pM-ZKNUBZYPWuuRCoXFfO7XOSEH46Ti8CB.jpg?quality=95&amp;as=32x15,48x23,72x35,108x52,160x77,240x115,360x173,480x231,540x260,640x308,720x347,1080x520,1280x616,1440x693,1469x707&amp;from=bu&amp;cs=1469x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДавайте кликнем например на zoom api\n<img src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/A5EZQUFRHPyEWSTl66rvxN2h7xUzU-9_6-9hyaPqBryjea0pasoVRV4LvKYkI9GMTor41eJNGJ0MlUA2c2yJpUvp.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x101,240x151,360x227,480x302,540x340,640x403,720x454,1080x681,1280x807,1440x907,1652x1041&amp;from=bu&amp;cs=1652x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ нам перекинуло на workspace zoom и мы можем посмотреть как у них что устроено\n<img src=\"https://sun9-5.vkuserphoto.ru/s/v1/ig2/FBcMOmNNci67o3mtYDFaCfCDWa-f-1ADQ1clCQl1FzbQ_K_bwDH1GZH3QEHGNEjlTZ8qH0wRvcAY_y0lupmgvSsk.jpg?quality=95&amp;as=32x15,48x22,72x33,108x50,160x74,240x111,360x166,480x222,540x249,640x296,720x333,1080x499,1280x591,1440x665,1920x887&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nТакже, когда мы перейдем на вкладку Pre-request Script, справа появляется документация по Pre-request Script, мы можем ее изучить\n<img src=\"https://sun9-24.vkuserphoto.ru/s/v1/ig2/FuQZ1jjuHdEvigaWRO9nMiblIjpLioBLPaJHxjGTegsisR3u7urLdk7aWHqhZ4PNLL1-fZvE3sxBlztlOqRM9PwT.jpg?quality=95&amp;as=32x15,48x22,72x33,108x49,160x73,240x110,360x165,480x220,540x247,640x293,720x330,1080x494,1280x586,1440x659,1518x695&amp;from=bu&amp;cs=1518x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее если мы перейдем на вкладку Tests, мы увидим документацию по Tests, давайте на нее нажмем\n<img src=\"https://sun9-17.vkuserphoto.ru/s/v1/ig2/f3ESk16kF2CVNNwFoLulpGRgK6dhFo2Rv5LbUZoiVoOpazzn1qkw33tCxfeETc5sv9tQwAGd9bMoxmbA3lE8jsFQ.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x59,240x89,360x133,480x177,540x199,640x236,720x266,1080x398,1280x472,1440x531,1510x557&amp;from=bu&amp;cs=1510x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ здесь прокрутим вниз до ссылки templates, нажмем на нее.\n<img src=\"https://sun9-18.vkuserphoto.ru/s/v1/ig2/VFO1Eev3NqW5EIsReYzY_Ssgu_bl6Z4IvqK8KTuct4P-eVrT7VorBtvO-06s0RwuuloTQJqZEOF3-TI-dh5dMP_L.jpg?quality=95&amp;as=32x18,48x26,72x40,108x59,160x88,240x132,360x198,480x263,540x296,640x351,720x395,1080x593,1280x702,1440x790,1547x849&amp;from=bu&amp;cs=1547x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nПопадаем на страничку, на которой мы можем выбрать коллекции для регрессионного, нагрузочного, интеграционного и т.д тестирования, и на основе этих коллекций писать свои тесты.\n<img src=\"https://sun9-34.vkuserphoto.ru/s/v1/ig2/iMZYDlSWOJF848sjn3H8teBV558fOaGuPDPT8aL0CA4GwLN1DSPCuqHk5Dn-TG5lheWx1fTpveGbhosxaCWAF_po.jpg?quality=95&amp;as=32x16,48x25,72x37,108x55,160x82,240x123,360x184,480x246,540x277,640x328,720x369,1080x553,1165x597&amp;from=bu&amp;cs=1165x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nНажмем например на Regression testing\n<img src=\"https://sun9-52.vkuserphoto.ru/s/v1/ig2/TDABB0Y_VnRkcEh1B-rTMi1tRDCJtPwb1aFPOdEiqJo7ZyK8RSL13rRek7OhHV6TUKQfioDcdjC0aVvWoMiMkA4J.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x100,240x151,360x226,480x301,540x339,640x402,720x452,981x616&amp;from=bu&amp;cs=981x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nДалее на Use Template\n<img src=\"https://sun9-7.vkuserphoto.ru/s/v1/ig2/NNV29vle86p68bt7Rp27S9c0IWTmTVvCFCWx8wrMLS5QbjTTvG4BkYo4TcP2vYHOQ7ywVSO8KukEJWoh2XnuK-m_.jpg?quality=95&amp;as=32x17,48x26,72x38,108x58,160x85,240x128,360x192,480x256,540x288,640x342,720x385,1080x577,1110x593&amp;from=bu&amp;cs=1110x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nВыбираем workspace, куда мы хотим добавить коллекцию\n<img src=\"https://sun9-56.vkuserphoto.ru/s/v1/ig2/OL9KWhApChF-9s_C78pThUDtpOf3Xzs7LrZf8C3NvHYubEFirw5_VJyhGQ6sMF9gNcildRYJZscPfXhrBM2YIaKn.jpg?quality=95&amp;as=32x12,48x19,72x28,108x42,160x62,240x93,360x140,480x187,540x210,640x249,720x280,754x293&amp;from=bu&amp;cs=754x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n<hr>\nИ видим, что у нас добавилась коллекция для регрессионного тестирования в наше рабочее пространство\n<img src=\"https://sun9-79.vkuserphoto.ru/s/v1/ig2/h-LlKbR84GKV9iecDZz-MyO3ZoDSRUPZ_Ewdm_pEeips_2AAGy2kMqsMkQcuV148q1jD3LTqJnlYH4ywZZ-xMWrD.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x134,360x201,480x268,540x302,640x358,720x403,1080x604,1280x716,1440x805,1920x1074&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div></details>","path":"-"}},{"title":"DevTools","data":{"code":"-","description":"DevTools (Инструменты разработчика) -  это встроенный набор мощных инструментов в современных браузерах (Chrome, Edge и др.), который позволяет разработчикам, верстальщикам и тестировщикам инспектировать, отлаживать и оптимизировать веб-страницы, редактировать HTML/CSS, анализировать JavaScript, мониторить сетевые запросы, тестировать адаптивность (responsive design) и производительность сайта прямо в браузере, облегчая разработку и поиск ошибок. \n\n<b>Основные функции DevTools:</b>\n\n<img src=\"https://sun9-28.vkuserphoto.ru/s/v1/ig2/7hGv5GTlmGQzIqyJ1mQaZ0CC_L9UK-LU6Jss270BjGdv7LatVAfgkKvAy03UEJgVHD9E14_DKqytWS5yjsNNemKz.jpg?quality=95&amp;as=32x12,48x18,72x26,108x39,160x58,240x88,360x131,480x175,540x197,640x233,720x263,1080x394,1280x467,1291x471&amp;from=bu&amp;cs=1291x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>1. Инспекция элементов:</b> Просмотр и изменение HTML-структуры и CSS-стилей в реальном времени.\n<b>2. Консоль:</b> Выполнение JavaScript, отладка, просмотр ошибок и логов.\n<b>3. Сеть (Network):</b> Мониторинг всех запросов и ответов между браузером и сервером, поиск медленных ресурсов.\n<b>4. Производительность (Performance):</b> Анализ загрузки страницы, выявление узких мест и оптимизация.\n<b>5. Эмуляция устройств (Device Mode):</b> Тестирование адаптивности сайта на различных разрешениях и устройствах.\n<b>5. Хранилище (Storage):</b> Проверка данных в cookies, Local Storage, Session Storage. \n\nP.S: не вижу смысла полностью описывать функционал DevTools когда можно посмотреть какой нибудь любой ролик на YouTube и понять его работу. \nНапример:\n\n<iframe class=\"mx-auto d-block\" style=\"border-radius: 15px; width: 90%; height: 50vh; max-width: 90%; max-height: 70%;\" src=\"https://www.youtube.com/embed/pOCwI_EUHjA?si=rtc7DyEN_PgOl_2y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"></iframe>","path":"-"}},{"title":"SQL","data":{"code":"-","description":"<img src=\"https://sun9-15.vkuserphoto.ru/s/v1/ig2/PJOJGoSUfSVvzhucUxBjEgvJ4eTM4Yh8eVPY23JoYRh1SF79cZngXFpe47Sfc8FgxuCTwPWwYzs4RKPYPAvt23t1.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x80,240x121,360x181,480x241,540x272,640x322,720x362,1080x543,1272x640&amp;from=bu&amp;cs=1272x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>SQL (Structured Query Language)</b> - это декларативный язык программирования, используемый для создания, управления, модификации и извлечения данных в реляционных базах данных. Он позволяет выполнять запросы, обновлять записи, создавать таблицы и управлять доступом к данным, что делает его критически важным инструментом для аналитиков, разработчиков и администраторов БД. \n\n<b>Основные аспекты SQL:</b>\n<b>- Функции:</b> Работа с таблицами (строки и столбцы), выборка данных, вставка, обновление и удаление.\n<b>- Реляционные базы данных:</b> SQL используется в системах вроде MySQL, PostgreSQL, SQL Server, Oracle.\n<b>- Простота:</b> Язык удобочитаем и часто напоминает английские фразы.\n<b>- Использование:</b> Применяется в IT, аналитике, маркетинге для обработки больших объемов данных и в некоторых видах тестирования.\n\n<hr>\n<h5>Таблицы (Table)</h5>\n<b>Таблица (table)</b> - это самая распространенная и простая форма хранения данных в РБД. Вот пример таблицы с пользователями (users):\n\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/5zCJL6i7BEQlF15PwN2_20Pj9JRLmabXK5lJerpoMc24lqWRlzuChiXTRlBsUn9oFhAfXHRKvvotvW9VJIZYlhcb.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x81,240x121,360x181,480x242,540x272,640x323,720x363,1080x544,1280x645,1387x699&amp;from=bu&amp;cs=1387x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Каждая таблица состоит из:</b> полей (field), записей/строк (record/row), колонок (column), значений и ключей (KEY)\n\n<b>Поле (field)</b> -  это колонка таблицы, предназначенная для хранения определенной информации о каждой записи в таблице. Полями в таблице users являются userId, userName, age, city и status. \n\n<b>Запись или строка (record/row)</b> - это любое единичное вхождение (entry), существующее в таблице. В таблице users 4 записи. Проще говоря, запись - это горизонтальное вхождение в таблице.\n\n<b>Колонка (column)</b> - это вертикальное вхождение в таблице, содержащее всю информацию, связанную с определенным полем. В таблице users одной из колонок является city, которая содержит названия городов, в которых проживают пользователи.\n\n<b>Значение</b> - элемент таблицы, который находится на пересечении столбцов и строк. В нашей таблице Строка 2 Поле 2 имеет значение \"Vika\"\n\n<b>Ключ (Key)</b> - это самый важный столбец в таблице, за счет этих значений и происходит взаимодействие в реляционной базе данных, он связывает таблицы между собой. В таблице ключом является поле userId.\n\n<details>\n<summary>Ключи бывают нескольких видов</summary>\n<div>\n<b>Первичный ключ (PRIMARY KEY)</b> -  идентификатор, такой как индекс или артикул.\n<b>Потенциальный ключ (candidate key)</b> - другое уникальное значение, которое может служить идентификатором.\n<b>Внешний ключ (FOREIGN KEY)</b> - столбец-ссылка, используется для объединения двух таблиц, каждое значение внешнего ключа обязательно соответствует первичному ключу в другой таблице.\n</div>\n</details>\n\n<hr>\n<h5>Структура и синтаксис запроса</h5>\n<img src=\"https://sun9-68.vkuserphoto.ru/s/v1/ig2/JYF5iApXcwnNCz37fm8vbvqgeexnEtHudu3dY5j4YRRfWNkR2qDKx1yqdLCgVuY3mrii4D-hnm2mv8o8uwMCkizs.jpg?quality=95&amp;as=32x18,48x26,72x39,108x59,160x88,240x132,360x197,480x263,540x296,640x351,720x395,1080x592,1240x680&amp;from=bu&amp;cs=1240x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Структура SQL-запроса</b> - это фиксированный логический каркас, по которому база данных понимает, откуда брать данные, как их отфильтровать, как сгруппировать, как отсортировать и что именно вернуть в результате. Несмотря на то что в запросе можно опускать отдельные части, их смысловой порядок всегда один и тот же. Смысл всей структуры - поэтапно сузить и преобразовать набор данных: сначала определить источник, потом отфильтровать строки, затем при необходимости агрегировать, после этого сформировать выходные колонки, отсортировать результат и ограничить его размер.\n\n<details>\n<summary>Синтаксис</summary>\n<div>\n<b>Ключевые правила синтаксиса и смысла:</b>\nИмена таблиц и столбцов (идентификаторы) пишутся без одинарных кавычек.\nОдинарные кавычки используются только для строковых значений.\nЭто принципиально: без этого SQL не различает \"что брать\" и \"с чем сравнивать\".\n\n<b>Ключевые слова SQL (SELECT, FROM, WHERE и т.д.) регистронезависимы:</b>\nusers и USERS - одно и то же.\nSELECT и select - одно и то же.\nно по соглашению пишутся в верхнем регистре для читаемости.\n\n<b>Порядок частей запроса фиксирован:</b>\nНельзя написать WHERE до FROM или LIMIT до ORDER BY.\nДаже если логически ты понимаешь, что хочешь сделать, синтаксис обязан быть в правильном порядке.\n\n<b>- В SELECT</b> перечисляются только колонки или выражения, которые ты хочешь видеть в результате.\nЭто не влияет на то, какие строки попадут в результат - за это отвечает WHERE.\n\n<b>- В FROM</b> указывается ровно тот источник данных, из которого берутся строки. Если FROM нет, запрос либо синтаксически неверен, либо превращается в запрос без таблицы (редкий и отдельный случай).\n\n<b>- В WHERE</b> всегда стоит логическое выражение, которое для каждой строки вычисляется в true или false. Если условие ложно - строка отбрасывается.\nWHERE не умеет работать с агрегатными функциями и результатами группировки.\n\n</div>\n</details>\n\n<details>\n<summary>Структура</summary>\n<div>\nЛюбой SQL-запрос состоит из \"команд\" или операторов. \n<b>Пример:</b> SELECT first_name, email FROM employees WHERE department_id = 1;\n<b>- SELECT:</b> что выбрать * все столбцы или определённые, через запятую \"first_name, email\"\n<b>- FROM:</b> откуда выбрать, название таблицы \"employees\"\n<b>- WHERE:</b> фильтр, условие выборки записей. \"department_id = 1;\"\n<b>Порядок выполнения:</b> Хотя мы пишем SELECT вначале, база данных выполняет операторы в другом, логическом порядке: 1 FROM &gt; 2 WHERE &gt; 3 GROUP BY &gt; 4 HAVING &gt; 5 SELECT &gt; 6 ORDER BY &gt; 7 LIMIT\n</div>\n</details>\n\n<hr>\n<h5>Типы данных</h5>\n<img src=\"https://sun9-20.vkuserphoto.ru/s/v1/ig2/GS_9HBCrZEjh7kkQyDMMJTkWV0kTIYPJNDluzh5w2PyYyYIg6Di7a9Ub_IRqCxihOUEIYbb_VSUs9QE6MpIxxbuA.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x76,240x114,360x171,480x229,540x257,640x305,720x343,1080x514,1280x610,1440x686,1575x750&amp;from=bu&amp;cs=1575x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Типы данных в SQL</b> - это способ жёстко задать, какие значения может хранить колонка и как база данных обязана с ними работать. Тип определяет допустимый диапазон значений, формат хранения, правила сравнения и сортировки, а также набор разрешённых операций. \nКаждый столбец в таблице имеет строго определенный тип данных. Это обеспечивает целостность и предсказуемость хранения информации.\n\n<details>\n<summary>Базовый список типов данных:</summary>\n<div>\n<img src=\"https://sun9-55.vkuserphoto.ru/s/v1/ig2/0rqjJKRwJ4ixUBBggILOxwiMtVhoCJcfr2h0q80HB83wmMKe0Cy4t8n9AmXgx3J6XdSEC-rscMMFu52r02KShpO4.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720,1440x810,1920x1080&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>INTEGER (INT):</b> Целые числа (1, 100, -50).\n<b>VARCHAR(n):</b> Текстовая строка переменной длины до n символов ('Иван'). Экономит место.\n<b>CHAR(n):</b> Текстовая строка фиксированной длины n символов ('M', 'F'). Быстрее для полей с одинаковой длиной.\n<b>TEXT:</b> Для хранения длинных текстов (описания товаров, статьи).\n<b>DECIMAL(p, s) / NUMERIC:</b> Числа с фиксированной точностью (199.99). Идеальны для денег, чтобы избежать ошибок округления.\n<b>FLOAT / REAL:</b> Числа с плавающей точкой. Используются для научных расчетов.\n<b>DATE:</b> Дата ('2025-10-03').\n<b>TIMESTAMP / DATETIME:</b> Дата и время ('2025-10-03 17:00:00'). TIMESTAMP часто хранит время в UTC.\n<b>BOOLEAN:</b> Логические значения (true или false).\n<b>NULL:</b> Специальное значение, означающее \"нет данных\" или \"неприменимо\". Не путать с пустой строкой '' или нулем 0.\n</div>\n</details>\n\n<hr>\n<h5>Создание и управление (DDL &amp; DML)</h5>\n<img src=\"https://sun9-5.vkuserphoto.ru/s/v1/ig2/x9DqTKtILKbmNFk5tmUmmEgmUp00aQbqcdgAqadsUUrfvfEOvU3WGs6VFErXuCSZRz2Xl36EBhlNVpReWCE0mRIS.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720,1440x810,1920x1080&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>DDL (Data Definition Language, язык определения данных)</b> - отвечает за создание и изменение схемы базы: таблиц, колонок, индексов, ограничений, представлений. Это команды, которые меняют саму структуру хранилища. \n\n<b>DML (Data Manipulation Language, язык манипуляции данными)</b> - отвечает за работу с содержимым таблиц. Это вставка новых строк, изменение существующих и удаление данных. DML-команды не меняют схему, они работают внутри уже заданной структуры. Именно DML участвует в бизнес-логике приложения: регистрация пользователя, обновление профиля, удаление записи.\n\n<details>\n<summary>Работа с базами данных (DDL)</summary>\n<div>\n<b>- SHOW DATABASES:</b> Показать все БД. \n<b>QA-кейс:</b> Убедиться, что вы подключились к правильному серверу и видите нужную тестовую базу данных: \n<code class=\"language-sql\">SHOW DATABASES;</code>\n<hr>\n<b>- CREATE/DROP DATABASE:</b> Служит для создания и удаления таблиц.\n<b>QA-кейс:</b> Создание полностью изолированной базы данных для прогона набора автотестов с последующим её удалением:\n<pre><code class=\"language-sql\">\n-- Создаем новую БД \nCREATE DATABASE test_automation_db;\n-- Удаляем БД после тестов \nDROP DATABASE test_automation_db;\n</code></pre>\n<hr>\n<b>- USE:</b> Выбрать БД для работы. \n<b>QA-кейс:</b> Перед выполнением любых запросов к таблицам, нужно \"активировать\" базу данных, с которой вы будете работать: \n<pre><code class=\"language-sql\">\nUSE main_project_db;\n</code></pre>\n</div>\n</details>\n\n<details>\n<summary>Работа с таблицами (DML)</summary>\n<div>\n<b>- CREATE TABLE:</b> - позволяет Создать таблицу\n<b>QA-кейс:</b> Создание временной таблицы для хранения промежуточных результатов сложного теста:\n<pre><code class=\"language-sql\">\nCREATE TABLE users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(50) NOT NULL,\n    email VARCHAR(100) UNIQUE,\n    birthdate DATE\n);\n</code></pre>\n<hr>\n<b>- INSERT INTO:</b> Добавить данные в таблицу\n<b>QA-кейс:</b> Создать нового тестового пользователя перед проверкой логина:\n<pre><code class=\"language-sql\">\nINSERT INTO employees (first_name, last_name, email, department_id, salary)\nVALUES ('Тест', 'Тестов', 'test@example.com', 2, 55000.00);\n</code></pre>\n<hr>\n<b>- UPDATE:</b> Изменить данные\n<b>QA-кейс:</b> Изменить статус заказа на \"Доставлен\" для проверки отображения в личном кабинете: \n<pre><code class=\"language-sql\">\nUPDATE employees SET email = 'new_email@example.com' WHERE id = 2;\n</code></pre>\n<hr>\n<b>- DELETE:</b> Удалить данные\n<b>QA-кейс:</b> \"Почистить\" базу данных, удалив тестового пользователя, созданного во время теста:\n<pre><code class=\"language-sql\">\nDELETE FROM employees WHERE email = 'test@example.com';\n</code></pre>\n<hr>\n<b>- ALTER TABLE:</b> Изменить структуру таблицы\n<b>QA-кейс:</b> Проверить миграцию базы данных: после того как разработчики добавили новое поле, убедиться, что оно действительно появилось в таблице:\n<pre><code class=\"language-sql\">\n-- Добавление нового столбца \nALTER TABLE employees ADD COLUMN phone_number VARCHAR(20);\n-- Изменение типа столбца \nALTER TABLE employees MODIFY COLUMN phone_number INT;\n-- Удаление столбца \nALTER TABLE employees DROP COLUMN birthdate;\n</code>\n</pre>\n</div>\n</details>\n\n<hr>\n<h5>Выборка данных (SELECT)</h5>\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/Nru6a93V-qgEpJ8SXxQ7ikB_3O2_vqr6-jrH2Y80_unkvz2ril3CFn3hQO3fYVfJ-B2faO6M1wu7FisJGCa3AA56.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x134,360x200,480x267,540x300,640x356,720x401,825x459&amp;from=bu&amp;cs=825x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Выборка данных в SQL через SELECT</b> - это основной механизм получения информации из базы. Запрос SELECT формирует результирующий набор данных, указывая, какие столбцы вернуть, из каких таблиц брать строки и по каким условиям их отфильтровать.\n\n<b>SELECT</b> - самая частая команда в работе тестировщика. Она позволяет \"доставать\" нужные данные для проверки. \n\n<details>\n<summary>Работа с SELECT</summary>\n<div>\n\nДля всех примеров будем использовать эту таблицу: `employees`. \n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>2</td><td>Анна</td><td>Сидорова</td><td>2</td><td>65000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr><tr><td>4</td><td>Елена</td><td>Смирнова</td><td>3</td><td>80000.00</td></tr><tr><td>5</td><td>Дмитрий</td><td>Кузнецов</td><td>2</td><td>60000.00</td></tr></tbody></table>\n\nНиже приведены все базовые примеры для работы с SELECT:\n\n<hr>\n<b>SELECT *: Выбрать все столбцы</b>\n<div>\n<b>QA-кейс:</b> Посмотреть всю информацию о сотрудниках, чтобы убедиться, что тестовые данные на месте.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>2</td><td>Анна</td><td>Сидорова</td><td>2</td><td>65000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr><tr><td>4</td><td>Елена</td><td>Смирнова</td><td>3</td><td>80000.00</td></tr><tr><td>5</td><td>Дмитрий</td><td>Кузнецов</td><td>2</td><td>60000.00</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>SELECT DISTINCT: Уникальные значения</b>\n<div>\n<b>QA-кейс:</b> Получить список всех уникальных ID отделов, в которых есть сотрудники, для проверки фильтра в UI.\n<pre><code class=\"language-sql\">\nSELECT DISTINCT department_id FROM employees;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>department_id</th></tr></thead><tbody><tr><td>1</td></tr><tr><td>2</td></tr><tr><td>3</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>LIMIT: Ограничить количество записей</b>\n<div>\n<b>QA-кейс:</b> Проверить пагинацию. Запросить первые 3 записи для первой страницы списка сотрудников.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees LIMIT 3;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>2</td><td>Анна</td><td>Сидорова</td><td>2</td><td>65000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>AS: Переименовать столбец</b>\n<div>\n<b>QA-кейс:</b> Подготовить данные для отчета, где названия столбцов должны быть на русском языке.\n<pre><code class=\"language-sql\">\nSELECT first_name AS \"Имя\", last_name AS \"Фамилия\" FROM employees;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>Имя</th><th>Фамилия</th></tr></thead><tbody><tr><td>Иван</td><td>Петров</td></tr><tr><td>Анна</td><td>Сидорова</td></tr><tr><td>Сергей</td><td>Иванов</td></tr><tr><td>Елена</td><td>Смирнова</td></tr><tr><td>Дмитрий</td><td>Кузнецов</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>WHERE: Фильтрация по условию</b>\n<div>\n<b>QA-кейс:</b> Найти всех сотрудников из отдела с ID=1.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees WHERE department_id = 1;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>WHERE ... AND / OR: Комбинирование условий</b>\n<div>\n<b>QA-кейс (AND): </b>Найти сотрудников из отдела 1, которые зарабатывают больше 71000.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees WHERE department_id = 1 AND salary &gt; 71000;\n</code>\n</pre>\n\nРезультат (AND):\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr></tbody></table>\n<hr>\n\n<b>QA-кейс (OR):</b> Найти всех сотрудников из отдела 1 или отдела 3.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees WHERE department_id = 1 OR department_id = 3;\n</code>\n</pre>\nРезультат (OR):\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr><tr><td>4</td><td>Елена</td><td>Смирнова</td><td>3</td><td>80000.00</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>LIKE: Фильтр по шаблону</b>\n<div>\n<b>QA-кейс:</b> Найти всех сотрудников, чья фамилия заканчивается на \"ов\".\n<pre><code class=\"language-sql\">\n-- % означает любое количество символов \nSELECT * FROM employees WHERE last_name LIKE '%ов';\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr></tbody></table>\n\n<hr>\n<b>QA-кейс:</b> Найти всех, чье имя состоит из 4 букв и начинается на \"Ива\".\n<pre><code class=\"language-sql\">\n-- _ означает ровно один любой символ \nSELECT * FROM employees WHERE first_name LIKE 'Ива_';\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr></tbody></table>\n</div>\n\n\n<hr>\n<b>BETWEEN / IN / NOT: Диапазоны, списки и отрицание</b>\n<div>\nBETWEEN: Найти сотрудников с зарплатой от 65000 до 75000 включительно.\n\n<pre><code class=\"language-sql\">\nSELECT * FROM employees WHERE salary BETWEEN 65000.00 AND 75000.00;\n</code>\n</pre>\n\nIN: Найти сотрудников из отделов 2 и 3.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees WHERE department_id IN (2, 3);\n</code>\n</pre>\n\nNOT: Найти всех сотрудников НЕ из отдела 1.\n<pre><code class=\"language-sql\">\nSELECT * FROM employees WHERE NOT department_id = 1;\n</code>\n</pre>\n</div>\n\n\n<hr>\n<b>ORDER BY: Сортировка результатов</b>\n<div>\n<b>QA-кейс:</b> Проверить правильность сортировки по зарплате в UI. Сначала по убыванию (DESC), потом по возрастанию (ASC).\n\n<pre><code class=\"language-sql\">\n-- Сортировка по убыванию \nSELECT * FROM employees ORDER BY salary DESC;\n</code>\n</pre>\nРезультат (DESC):\n<table><thead><tr><th>id</th><th>first_name</th><th>last_name</th><th>department_id</th><th>salary</th></tr></thead><tbody><tr><td>4</td><td>Елена</td><td>Смирнова</td><td>3</td><td>80000.00</td></tr><tr><td>3</td><td>Сергей</td><td>Иванов</td><td>1</td><td>72000.00</td></tr><tr><td>1</td><td>Иван</td><td>Петров</td><td>1</td><td>70000.00</td></tr><tr><td>2</td><td>Анна</td><td>Сидорова</td><td>2</td><td>65000.00</td></tr><tr><td>5</td><td>Дмитрий</td><td>Кузнецов</td><td>2</td><td>60000.00</td></tr></tbody></table>\n</div>\n\n\n</div>\n</details>\n\n<hr>\n<h5>Агрегация и Группировка</h5>\n<img src=\"https://sun9-77.vkuserphoto.ru/s/v1/ig2/BXUNeHGwJLSaLhkb9uyhqwN1dwM-MYzx126S7n327Qw2eVMn5OFRcDyhX8F1NdPRHA5hxv1R1Zz0MoLsu9mnP-D1.jpg?quality=95&amp;as=32x12,48x17,72x26,108x39,160x58,240x87,360x130,480x174,540x195,640x232,720x261,837x303&amp;from=bu&amp;cs=837x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Агрегация и группировка в SQL</b> - это механизм преобразования множества строк в обобщённые значения. Агрегация отвечает за вычисление сводных показателей, таких как количество, сумма, среднее, минимум или максимум. Группировка задаёт, по какому признаку строки объединяются перед применением этих вычислений. Вместе они позволяют переходить от «сырых» данных к аналитическим результатам.\nАгрегатные функции выполняют вычисления на наборе значений и возвращают одно-единственное значение. Они почти всегда используются с GROUP BY.\n\n<details>\n<summary>Работа с агрегацией и группировкой</summary>\n<div>\n<b>COUNT:</b> Подсчет количества\n<b>QA-кейс:</b> После создания 5 пользователей через API, проверить, что в таблице `employees` действительно стало на 5 записей больше.\n<pre><code class=\"lang-sql\">\nSELECT COUNT(*) AS total_employees FROM employees;\n</code>\n</pre>\n\nРезультат:\n<table><thead><tr><th>total_employees</th></tr></thead><tbody><tr><td>5</td></tr></tbody></table>\n\n<hr>\n<b>MIN / MAX / AVG / SUM:</b> Минимум, максимум, среднее, сумма\n<b>QA-кейс:</b> Проверить статистический виджет на дашборде, который должен показывать минимальную, максимальную и среднюю зарплату по компании.\n\n<pre><code class=\"lang-sql\">\nSELECT MIN(salary) AS min_salary,\n    MAX(salary) AS max_salary,\n    AVG(salary) AS avg_salary,\n    SUM(salary) AS total_salary_fund\nFROM employees;\n</code>\n</pre>\n\nРезультат:\n<table><thead><tr><th>min_salary</th><th>max_salary</th><th>avg_salary</th><th>total_salary_fund</th></tr></thead><tbody><tr><td>60000.00</td><td>80000.00</td><td>69400.00</td><td>347000.00</td></tr></tbody></table>\n\n<hr>\n<b>GROUP BY и HAVING:</b> Группировка и фильтрация групп\n<b>QA-кейс:</b> Найти отделы, в которых работает более одного сотрудника, чтобы проверить логику начисления бонусов руководителям этих отделов.\n\n<pre><code class=\"lang-sql\">\nSELECT department_id,\n    COUNT(id) AS employee_count\nFROM employees GROUP BY department_id HAVING COUNT(id) &gt; 1;\n</code>\n</pre>\n\nРезультат:\n<table><thead><tr><th>department_id</th><th>employee_count</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>2</td><td>2</td></tr></tbody></table>\n\n<b>Ключевое отличие: WHERE vs HAVING</b>\nWHERE фильтрует строки до того, как они будут сгруппированы.\nHAVING фильтрует группы после того, как они были созданы с помощью GROUP BY.\n</div>\n</details>\n\n<hr>\n<h5>Объединение результатов UNION / JOIN </h5>\n<img src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/UUOEI2_oKXYGSQ7cChsvHJOdX47PT7W05CUEQP59gPqi2ALdhDcypeqDWCi6VJOLWS4jQwCmvfG6q3qzVxJIQLx4.jpg?quality=95&amp;as=32x25,48x37,72x56,108x84,160x125,240x187,360x280,375x292&amp;from=bu&amp;cs=375x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Объединение результатов в SQL</b> - это два принципиально разных механизма, которые новички постоянно путают: объединение строк из разных запросов и объединение таблиц по связям. Это не одно и то же, и логика у них разная.\n\n<b>Первый механизм:</b> объединение результатов нескольких SELECT в один результирующий набор. Для этого используются операторы UNION, UNION ALL, INTERSECT и EXCEPT. Их смысл в том, что ты берёшь два или больше запроса и \"склеиваешь\" их результаты по строкам. \n\n<b>Второй механизм:</b> объединение таблиц по связям между ними. Это делается через JOIN. Здесь ты не склеиваешь результаты, а расширяешь строки за счёт данных из другой таблицы. В результате одна строка может превратиться в несколько, если связь один-ко-многим. \n\n<details>\n<summary>Работа с UNION</summary>\n<div>\nОператоры UNION и UNION ALL объединяют результаты двух или более SELECT запросов в один набор данных.\n\n<b>Правила применения UNION:</b>\n- Каждый SELECT запрос в UNION должен иметь одинаковое количество столбцов.\n- Столбцы также должны иметь совместимые типы данных (например, нельзя объединять число со строкой).\n- Столбцы в каждом SELECT запросе должны быть в одинаковом порядке.\n- Названия столбцов в итоговом результате берутся из первого SELECT запроса.\n\n<b>UNION:</b> Объединение с удалением дубликатов\n<b>QA-кейс:</b> Получить единый список email'ов из таблицы сотрудников и таблицы клиентов для общей рассылки, избегая повторной отправки одному и тому же адресату.\n\n<pre><code class=\"lang-sql\">\nSELECT email FROM employees UNION SELECT email FROM customers;\n</code>\n</pre>\n\n<b>UNION ALL:</b> Объединение всех записей\n<b>QA-кейс:</b> Собрать полный лог всех действий (входы и выходы) из двух разных таблиц для анализа активности пользователя, сохраняя хронологию и все события.\n<pre><code class=\"lang-sql\">\nSELECT user_id,\n    action,\n    timestamp FROM login_logs UNION ALL SELECT user_id,\n    action,\n    timestamp FROM action_logs;\n</code>\n</pre>\n\n</div>\n</details>\n\n<details>\n<summary>Работа с JOIN'ами</summary>\n<div>\n\n<img src=\"https://sun9-6.vkuserphoto.ru/s/v1/ig2/ZNputcgb2V9_7wULOAoG-qOu7pYMDBNsOS1FqO-yzvYXEo4mMyWo8FAkT99EO9XjU2h1uaOqZUcJiTKeEW8n9BuN.jpg?quality=95&amp;as=32x23,48x35,72x52,108x79,160x116,240x175,360x262,440x320&amp;from=bu&amp;cs=440x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\nJOIN'ы позволяют объединять строки из двух или более таблиц по связанным столбцам (ключам). Это одна из самых мощных концепций в SQL.\n\n<b>INNTER JOIN:</b> Возвращает только те записи, для которых есть совпадение в обеих таблицах.\n\n<b>LEFT JOIN:</b> Возвращает ВСЕ записи из левой таблицы (users) и совпавшие из правой.\n\n<b>RIGHT JOIN:</b> Возвращает ВСЕ записи из правой таблицы (orders) и совпавшие из левой.\n\nТаблицы для примеров:\n\nТаблица: `users`\n<table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>Иван</td></tr><tr><td>2</td><td>Анна</td></tr><tr><td>3</td><td>Петр</td></tr></tbody></table>\n\nТаблица: `orders`\n<table><thead><tr><th>order_id</th><th>user_id</th><th>item</th></tr></thead><tbody><tr><td>101</td><td>1</td><td>Книга</td></tr><tr><td>102</td><td>2</td><td>Телефон</td></tr><tr><td>103</td><td>1</td><td>Мышь</td></tr><tr><td>104</td><td>4</td><td>Лампа</td></tr></tbody></table>\n\n<hr>\n<b>INNER JOIN:</b> Только совпадения\nВозвращает только те строки, для которых есть совпадение в обеих таблицах. Пользователи без заказов (Петр) и заказы без пользователей (заказ 104) не попадут в результат.\n<pre><code class=\"lang-sql\">\nSELECT u.name, o.item FROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>name</th><th>item</th></tr></thead><tbody><tr><td>Иван</td><td>Книга</td></tr><tr><td>Анна</td><td>Телефон</td></tr><tr><td>Иван</td><td>Мышь</td></tr></tbody></table>\n\n<hr>\n<b>LEFT JOIN:</b> Все из левой таблицы\nВозвращает все строки из левой таблицы (users) и совпавшие строки из правой (orders). Если для пользователя нет заказа (как для Петра), в столбцах из правой таблицы будет NULL.\n<pre><code class=\"lang-sql\">\nSELECT u.name, o.item FROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n</code>\n</pre>\nРезультат:\n<table><thead><tr><th>name</th><th>item</th></tr></thead><tbody><tr><td>Иван</td><td>Книга</td></tr><tr><td>Иван</td><td>Мышь</td></tr><tr><td>Анна</td><td>Телефон</td></tr><tr><td>Петр</td><td>NULL</td></tr></tbody></table>\n\n<hr>\n<b>RIGHT JOIN:</b> Все из правой таблицы\nВозвращает все строки из правой таблицы (orders) и совпавшие строки из левой (users). Если для заказа нет пользователя (как для заказа 104), в столбцах из левой таблицы будет NULL.\n\n<pre><code class=\"lang-sql\">\nSELECT u.name, o.item FROM users u\nRIGHT JOIN orders o ON u.id = o.user_id;\n</code>\n</pre>\n\nРезультат:\n<table><thead><tr><th>name</th><th>item</th></tr></thead><tbody><tr><td>Иван</td><td>Книга</td></tr><tr><td>Анна</td><td>Телефон</td></tr><tr><td>Иван</td><td>Мышь</td></tr><tr><td>NULL</td><td>Лампа</td></tr></tbody></table>\n</div>\n</details>\n\n<hr>\n<h5>Транзакции</h5>\n<b>Транзакция</b> -  это последовательность операций, которая выполняется как единое целое по принципу \"всё или ничего\". Либо все операции успешны и сохраняются (COMMIT), либо все отменяются (ROLLBACK). Это гарантирует целостность данных.\n\n<pre><code class=\"lang-sql\">\nSTART TRANSACTION;\n-- Снимаем 100$ со счета \nA UPDATE Accounts SET balance = balance - 100 WHERE id = 'A';\n-- Добавляем 100$ на счет \nB UPDATE Accounts SET balance = balance + 100 WHERE id = 'B';\n-- Если обе операции успешны, сохраняем изменения \nCOMMIT;\n</code>\n</pre>\n\n<details>\n<summary>Зачем тестировщику дампы?</summary>\n<div>\n<b>Дамп (dump)</b> - это файл, содержащий структуру и данные базы данных в виде набора SQL-команд. QA-инженер использует дампы для:\n\n<b>- Воспроизведения багов:</b> Если на продакшене произошел баг, связанный с данными, разработчики могут прислать \"обезличенный\" дамп (без персональных данных), чтобы QA мог локально развернуть копию БД и точно воспроизвести проблему.\n<b>- Настройки тестового окружения:</b> Вместо ручного создания сотен тестовых записей, можно один раз развернуть готовый дамп с преднастроенными данными, что экономит массу времени.\n<b>- Тестирования миграций:</b> Чтобы проверить, что скрипт обновления структуры БД (миграция) работает корректно, QA может взять дамп старой версии, \"накатить\" на него миграцию и проверить, что все данные на месте и структура обновилась правильно.\n<b>- Анализа данных от клиента:</b> Иногда клиенты присылают дампы своих данных для анализа сложных проблем. QA может развернуть их на тестовом стенде и исследовать, не затрагивая \"боевую\" систему клиента.\n</div>\n</details>","path":"-"}},{"title":"Git / GitHub / GitLab","data":{"code":"-","description":"<span style=\"color:red\">(как установить git на компьютер и т.п. тонкости есть в общем доступе как на официальной странице, так и на ютубе, дальнейшее описание будет с учётом того что git установлен и настроен на ПК)</span>\n\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/NGe3HE2v4fyQAMISrku_os-gK1EuEzdB7H7rH79oyBWo6043PvgMD4hZQqfW_tMA76S_1hhyOXkL5WB8V2hdOFGN.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720,1440x810,1920x1080&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nПредставьте большой проект. Есть папка с кодом, её копируют как попало: project_final, project_final2, project_final_fix, project_final_fix_really. Разработчик что-то поменял, выкатил сборку, и вдруг в ней появился баг. Вопросы начинаются сразу: что именно изменилось, кто это сделал, когда и зачем - никто не знает. Чтобы разобраться, приходится сравнивать файлы вручную, вспоминать \"на глаз\", или просто чинить вслепую, надеясь не сломать ещё что-то.\n\nТестировщик в такой ситуации тоже в тупике. Он видит баг, но не может сказать, это новый дефект или старый, связанный с конкретным изменением. Нет понимания, что именно нужно ретестить, а что не трогали. Любое исправление - риск, потому что нет истории и точки возврата.\n\nПоэтому для удобства придумали систему контроля версий. Вместо хаоса из копий есть чёткая история изменений: видно, какой код поменяли, в каком коммите, и что именно попало в текущую версию. Если баг появился - можно посмотреть, между какими изменениями он возник, и проверить только нужную часть системы.\n\n<hr>\n<h5>GIT</h5>\n<b>Git</b> -  это инструмент (консольная утилита), который запоминает изменения в проекте. Не просто \"сохраняет файл\", а хранит историю: что изменилось, когда и зачем. Когда происходит работа с проектом, меняется код или тесты, Git позволяет зафиксировать текущее состояние и в любой момент вернуться назад.\n\n<b>Каждое сохранение в Git</b> - это осознанный снимок проекта с комментарием. Если что-то сломалось, можно посмотреть, в каком изменении это произошло, или откатиться на рабочую версию. Поэтому Git нужен не только разработчикам: тестировщику он помогает понимать, какие изменения пришли в сборку, где мог появиться баг и что именно поменялось между версиями.\n\nВажно не путать Git и GitHub. Git - это программа на компьютере, все изменения хранятся локально. GitHub - это сервис, куда можно выложить репозиторий, чтобы работать в команде или хранить код удалённо.\n\n<b>Если совсем коротко:</b> Git - это контроль истории проекта (контроль версий) и страховка от потери изменений. Без него работа происходит вслепую, с ним - есть понимание что происходит с продуктом и почему.\n\n<details>\n<summary>Как работает</summary>\n<div>\nС помощью Git-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.\n\n<b>Репозиторий</b> - это хранилище вашего кода и где хранится история его изменений. Git работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.\n\n<b>Commit -</b>Каждая точка сохранения вашего проекта носит название коммит . \n<b>hash (уникальный id) - </b> есть каждого commit-a, плюс комментарий (туда обычно пишется что было изменено кратко в ветке). Из таких commit-ов собирается ветка. \n<b>Ветка</b> - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.\n\nЕсли посмотреть на картинку, то становиться чуть проще с пониманием. Каждый кружок, это commit. Стрелочки показывают направление, из какого commit сделан следующий. Например C3 сделан из С2 и т. д. Все эти commit находятся в ветке под названием main. Это основная ветка, чаще всего ее называют master . Прямоугольник main* показывает в каком commit мы сейчас находимся, проще говоря указатель.\n\n<img src=\"https://sun9-43.vkuserphoto.ru/s/v1/ig2/j9ZwRhuK30vyTJ9M3YVP1oJokLKD293x_fIqk2rWde598f0qAxyjJeDT74Oh5QC4-JwU62tyyu1sB6XS3WlvcetE.jpg?quality=95&amp;as=32x37,48x55,72x82,108x124,160x183,240x275,360x412,480x549,540x618,640x732,720x824,750x858&amp;from=bu&amp;cs=750x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nВ итоге получается очень простой граф, состоящий из одной ветки (main) и четырех commit. Все это может превратиться в более сложный граф, состоящий из нескольких веток, которые сливаются в одну.\n\n<img src=\"https://sun9-67.vkuserphoto.ru/s/v1/ig2/OheSDB6j-gCbdnsJk3muViNpW7s6QnyHjhbgmEGyaiPkKf6np3YsWoaiNDn1GqlppOzIvGPVWa0EV42tmO7Xnplf.jpg?quality=95&amp;as=32x29,48x44,72x66,108x100,160x147,240x221,360x332,480x442,540x498,640x590,720x664,844x778&amp;from=bu&amp;cs=844x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n</div>\n</details>\n\n<details>\n<summary>Создание репозитория и первый commit</summary>\n<div>\nСоздадим наш первый репозиторий. Для этого пройдите в папку вашего проекта.\n\n<pre><code class=\"lang-bash\">\n#Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject\n#Для Windows например С://MyProject\ncd &lt;путь_к_вашему_проекту&gt;\n\n#Инициализация/создание репозитория\ngit init\n</code>\n</pre>\n\nТеперь Git отслеживает изменения файлов вашего проекта. Но, так как вы только создали репозиторий в нем нет вашего кода. (Допустим вы добавили код, файлы, папки), после этого необходимо создать commit.\n\n<pre><code class=\"lang-bash\">\n#Добавим все файлы проекта в нам будующий commit\ngit add .\n#Или так\ngit add --all\n\n#Если хотим добавить конкретный файл то можно так\ngit add &lt;имя_файла&gt; \n\n#Теперь создаем commit. Обязательно указываем комментарий.\n#И не забываем про кавычки\ngit commit -m \"&lt;комментарий&gt;\"\n</code>\n</pre>\nОтлично. Вы создали свой первый репозиторий и заполнили его первым commit.\n</div>\n</details>\n\n<details>\n<summary>Ветки (branch)</summary>\n<div>\n<img src=\"https://sun9-68.vkuserphoto.ru/s/v1/ig2/3r2o7waVMjPfSDThpdYVbd9s15B0mZOfWJLvvrvSYjC5UkL7vVO1ecj_xK-zF4rgkOpLKknB8_tW3YTxmrhljOqH.jpg?quality=95&amp;as=32x11,48x16,72x25,108x37,160x55,240x82,360x123,480x164,540x185,640x219,720x246,1080x369,1280x438,1440x492,1693x579&amp;from=bu&amp;cs=1693x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Ветки (branch)</b>- это параллельные версии проекта. Есть основная ветка, где лежит стабильный код, и есть ветки с изменениями. Обычно основную ветку называют main / master а все остальные зависят от компании и разработки.\nРазработчики могут что-то делать в своей ветке, пока основная версия остаётся рабочей. \n<b>QA здесь важно понимать одно:</b> что сейчас тестируется - стабильная версия или изменения, которые ещё не в релизе.\nЭто объясняет, почему один и тот же баг может быть \"уже исправлен\", но всё ещё воспроизводиться в другой ветке.\n\n\n<pre><code class=\"lang-bash\">\n#Посмотреть, в какой ветке ты сейчас:\ngit branch\n\n#Создать новую ветку:\ngit branch feature-login\n\n#Переключиться:\ngit checkout feature-login\n\n#(или современно)\ngit switch feature-login\n</code>\n</pre>\n\n<b>QA-смысл:</b> ты понимаешь, какую версию проекта ты тестируешь.\n</div>\n</details>\n\n<details>\n<summary>История изменений и сравнение версий</summary>\n<div>\n<img src=\"https://sun9-32.vkuserphoto.ru/s/v1/ig2/l52YgZSdBTtpiTaJSyTkefStJPTJwJFIXJf-emGgngZBIEEGlfk5HZmLOdSMBcdZabakNXmafaf0YLoiDFLXNAfd.jpg?quality=95&amp;as=32x14,48x21,72x32,108x48,160x70,240x106,360x158,480x211,540x238,640x282,720x317,1080x475,1280x563,1440x633,1548x681&amp;from=bu&amp;cs=1548x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nПроходит время, коммитов становится много. Git хранит их как цепочку состояний проекта. Можно посмотреть историю и увидеть: когда появилось изменение, кто его сделал и что именно было изменено.\n<b>Для QA:</b> это ключевая штука если баг появился сегодня, то проверяется между какими изменениями он возник, и уже не тестируется всё подряд. Происходит сразу следование к конкретной зоне риска.\n\n<pre><code class=\"lang-bash\">\n#Был изменён какой то файл в проекте (локально) то можно посмотреть какие файлы были затронуты:\ngit status\n\n#Фиксация новых изменений: Ты решил, что изменения готовы.\ngit add .\ngit commit -m \"Update validation logic\"\n#Теперь у проекта есть новая точка состояния.\n\n#История изменений\n#Посмотреть всю историю:\ngit log\n#Коротко и по делу:\ngit log --oneline\n#QA-польза: тут видно, какие изменения попали в сборку, и можно связать баг с конкретным коммитом.\n</code>\n</pre>\n\n<hr>\n<b>Сравнение версий (очень важно для QA)</b>\n<b>Сравнение версий</b> -  это способ понять, что именно изменилось в продукте между двумя состояниями. Не на уровне ощущений (\"вроде что-то меняли\"), а на уровне фактов: какие файлы, какие строки, какая логика.\n\nДля QA это критично, потому что тестирование всегда начинается с изменений. Баг не появляется \"просто так\" - он появляется из-за конкретного изменения. Если ты не знаешь, что поменялось, тебе приходится тестировать всё подряд, тратить время и всё равно что-то упускать.\n\n<pre><code class=\"lang-bash\">\n#Посмотреть, что именно изменилось:\n#Для QA это прямой ответ на вопрос: что поменялось &gt; что проверять.\ngit diff\n\n#Например, баг появился между двумя коммитами:\ngit diff commit1 commit2\n\n#Или проще - посмотреть, что изменилось с прошлого коммита:\ngit diff HEAD~1\n\n#Это один из самых полезных инструментов для регресса.\n</code>\n</pre>\n</div>\n</details>\n\n<hr>\n<h5>GitHub / GitLab </h5>\n<img src=\"https://sun9-79.vkuserphoto.ru/s/v1/ig2/hf6FLWpF86neesnKn509NQLT-AwdY1D7mp34FF5s43A0Cw02taszt2KpQRE-xmGKQma4ervGONKaTsJ1DTQ5lsW3.jpg?quality=95&amp;as=32x19,48x29,72x43,108x65,160x96,240x144,360x216,480x287,540x323,640x383,720x431,1080x647,1094x655&amp;from=bu&amp;cs=1094x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nGitHub и GitLab - это сервисы, где хранятся Git-репозитории и организуется командная работа вокруг кода.\n\n<b>GitHub</b> - самый распространённый публичный сервис. Его основная идея - совместная разработка и открытый код. Здесь удобно смотреть историю изменений, pull request’ы, обсуждения, баги (Issues).\n<b>Для QA GitHub:</b> это место, где можно увидеть, какие изменения сделали разработчики, какие задачи закрывались и что именно попало в релиз.\n\n<b>GitLab</b> - более \"инженерный\" и корпоративный вариант. Помимо хранения репозиториев, он изначально заточен под CI/CD, тестовые пайплайны, окружения, деплой. Часто используется внутри компаний. \n<b>Для QA GitLab:</b> важен тем, что в одном месте можно видеть код, тесты, автопрогоны, результаты пайплайнов и статус сборок.\n\nПеред всеми работами с этими сервисами необходимо на них зарегистрироваться, дальнейшая работа с ними будет подразумевать что регистрация пройдена.\n\n<details>\n<summary>Настройка git для GitHub/GitLab</summary>\n<div>\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/zCiOqC-sjscDgVwd4wPPD499pmb9-bJVPUTbmbgvAyrgTBq3ZGNZreFjDA-IJr20MWRskzCJKnHmxUKRBLihdBxe.jpg?quality=95&amp;as=32x8,48x13,72x19,108x29,160x42,240x64,360x95,480x127,540x143,640x170,720x191,1080x286,1280x339,1440x382,2560x679&amp;from=bu&amp;cs=2560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nНеобходимо настроить Гит. Нам нужно сообщить ему своё имя и почтовый адрес – так коллеги будут знать, кто и какие изменения внёс в проект. Открываем терминал, вводим две команды:\n<pre><code class=\"lang-bash\">\ngit config --global user.name \"ваше_имя\"\ngit config --global user.email \"ваш_email\"\n</code>\n</pre>\n\nВыставляем ветку по умолчанию на main (Гитхаб переименовал master на main ещё несколько лет назад):\n<pre><code class=\"lang-bash\">\ngit config --global init.defaultBranch main\n</code>\n</pre>\n\nПроверяем, корректно ли мы всё настроили:\n<pre><code class=\"lang-bash\">\ngit config --list --global\n</code>\n</pre>\nЕсли что-то не так – введите нужные команды повторно и правильно.\n\n<hr>\n<b>Создание SSH-ключа</b>\nSSH-ключ – это длинная комбинация символов для идентификации компьютера. Он нужен, чтобы вы не вводили свой логин и пароль каждый раз, когда пушите изменения на ГитХаб/ГитЛаб, а также во избежание ошибки \"Please use a personal access token\".\n\nКоманды для создания SSH выполняются в git bash (консоль git, не cmd окна) или PowerShell.\n\nПроверьте, не установлен ли этот ключ у вас:\n<pre><code class=\"lang-bash\">\nls ~/.ssh/id_ed25519.pub\n</code>\n</pre>\n\nЕсли нет (\"No such file or directory\"), то:\n1. Создайте его, введя эту команду: \n<pre><code class=\"lang-bash\">\nssh-keygen -t ed25519\n</code>\n</pre>\n2. Когда система спросит, куда сохранить ключ, просто нажмите Enter.\n3. Далее она предложит создать пароль – можете ввести его или пропустить нажатием Enter.\n\nКогда вы создали ключ (или он уже был создан на вашем компьютере), свяжите его со своим GH-аккаунтом:\n1. Зайдите в раздел SSH and GPG keys в настройках Гитхаба/ГитЛаба.\n2. Нажмите на зелёную кнопку \"New SSH key\" (или аналогичную на ГитЛаб) в верхнем правом углу.\n3. Придумайте и введите говорящее название для вашего ключа. Например, qa-ssh.\n4. Оставьте окно открытым – оно скоро пригодится. Пока не нажимайте \"Add SSH key\"!\n\nОтобразите ключ на экране:\n<pre><code class=\"lang-bash\">\ncat ~/.ssh/id_ed25519.pub\n</code>\n</pre>\n\nОн должен начинаться с “ssh-ed25519” и заканчиваться на email, который вы ввели ещё при настройке Гита.\n\nПродолжаем:\n1. Выделите и скопируйте весь свой ключ.\n2. Вернитесь к окну Гитхаба/ГитЛаба, которое вы не закрыли (п.4 из предыдущего списка).\n3. Вставьте скопированный ключ в поле \"Key\".\n4. Тип ключа (Key type) оставьте на \"Authentication Key\".\n5. Нажмите \"Add SSH key\".\nТеперь вы с SSH-ключом.\n</div>\n</details>\n\n<details>\n<summary>Работа с GitHub/GitLab</summary>\n<div>\n<img src=\"https://sun9-30.vkuserphoto.ru/s/v1/ig2/1DuqlR80YibbL4mDczvr2t3qI18PRRcJzhpqyR0-gM7f76pI5sS219YOC5wPji-WJ6dgLPQjRV4KEcRd5N5YDnC3.jpg?quality=95&amp;as=32x18,48x27,72x40,108x61,160x90,240x135,360x202,480x270,540x304,640x360,720x405,1080x607,1280x720&amp;from=bu&amp;cs=1280x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nПосле настройки удалённых репозиториев теперь в первую очередь необходимо загружать из репозиториев и выгружать из локальных репозиториев. \n\n<pre><code class=\"lang-bash\">\n#Скопировать удалённый репозиторий на свой локальный компьютер (Скачать проект себе)\ngit clone &lt; url репозитория &gt; &lt;локальный путь&gt;\n\n#Забрать последние изменения перед тестированием (с учётом ветки branch и последних commit)\ngit pull\n\n#Почти аналогичный вариант\ngit fetch\n#Отличие от pull: В отличие от git pull, git fetch не пытается автоматически объединить (merge) изменения в код. \n\n#Выгрузить изменения обратно в облако (с учётом добавления git add . &gt; git commit )\ngit push\n</code>\n</pre>\n</div>\n</details>\n\n<hr>\n<h5>Пример</h5>\n\n<details>\n<summary>1. Разработчики: создали проект (репозиторий)</summary>\n<div>\nКоманда начинает новый продукт. Им нужна единая “точка правды”: код + история изменений.\n\nКоманды (локально):\n<pre><code class=\"lang-bash\">\n#Создать папку petstore\nmkdir petstore\n#Перейти в папку\ncd petstore\n#инициализировать репозиторий\ngit init\n#Создать файл readme.md с комментарием Petstore\necho \"# Petstore\" &gt; README.md\n#Добавить файл Readme.md в репозиторий\ngit add README.md\n#Создать первый коммит с комментарием Init project with README\ngit commit -m \"Init project with README\"\n</code>\n</pre>\n\nКоманды (связать с GitHub/GitLab):\nНа сайте создают репозиторий, затем:\n<pre><code class=\"lang-bash\">\n#Соединить локальный репозиторий с удалённым\ngit remote add origin git@github.com:org/petstore.git\n#Переименовать основную ветку в main (изначально в git она master)\ngit branch -M main\n#Выгрузить первые файлы локального репозитория в ветку main и свяжи их\ngit push -u origin main\n</code>\n</pre>\n</div>\n</details>\n\n<details>\n<summary>2. Разработчики: Создали ветки (branch) под фичи и релизы</summary>\n<div>\nЧтобы не ломать main, разработчики делают изменения в отдельных ветках. \n<b>QA важно:</b> что тестируется? - ветка определяет версию.\n\nКоманды (разработчик создаёт ветку фичи):\n<pre><code class=\"lang-bash\">\ngit switch -c feature/add-pet-form\n</code>\n</pre>\n\nСделал изменения (условно добавил файлы), затем:\n<pre><code class=\"lang-bash\">\ngit add .\ngit commit -m \"Add pet form UI\"\ngit push -u origin feature/add-pet-form\n</code>\n</pre>\n\nТеперь на сервере есть ветка feature/add-pet-form, которую QA может проверить независимо от main.\n</div>\n</details>\n\n<details>\n<summary>3. Разработчики: Создали коммит с изменениями</summary>\n<div>\nКоммит - это “снимок проекта” с объяснением. Для QA коммиты - это способ понять, что именно поменялось.\n\nКоманды (разработчик):\n<pre><code class=\"lang-bash\">\ngit add src/petForm.js\ngit commit -m \"Validate pet age and name\"\ngit push\n</code>\n</pre>\n\nИзменение попало в ветку фичи. Обычно дальше создают MR/PR (Merge Request / Pull Request - запрос на вливание изменений) в main или release/*.\n</div>\n</details>\n\n<details>\n<summary>4. QA: Как QA получает это, выбирает ветку, тестирует</summary>\n<div>\nQA получает ссылку на задачу + ветку + иногда стенд (env - окружение) или инструкцию как поднять локально. Задача QA -  тестировать конкретную версию, а не \"всё подряд\".\n\nЕсли QA первый раз забирает проект:\n<pre><code class=\"lang-bash\">\ngit clone git@github.com:org/petstore.git\ncd petstore\n</code>\n</pre>\n<hr>\nЗабрать последние изменения и увидеть ветки:\n<pre><code class=\"lang-bash\">\ngit fetch --all\ngit branch -a\n</code>\n</pre>\n<hr>\nПереключиться на ветку, которую надо тестировать:\n<pre><code class=\"lang-bash\">\ngit switch feature/add-pet-form\n</code>\n</pre>\n<hr>\nПеред тестом полезно понять, что поменялось:\n<pre><code class=\"lang-bash\">\ngit log --oneline -5\ngit diff main..feature/add-pet-form\n</code>\n</pre>\n\ngit fetch подтянул все ветки/коммиты.\n\ngit switch ... -  ты теперь тестируешь именно эту версию.\n\ngit diff main..ветка - показывает изменения относительно main: это твой \"прицел\" для регресса.\n<hr>\nДальше QA запускает продукт/тесты (зависит от проекта), условно:\n<pre><code class=\"lang-bash\">\nnpm ci\nnpm test\nnpm run start\n</code>\n</pre>\n(это не Git, просто пример типичного запуска)\n</div>\n</details>\n\n<details>\n<summary>4. QA: \"Как обратно QA пушит\" - тут важный момент</summary>\n<div>\nQA обычно не пушит в ветки разработчиков продуктовый код. QA пушит то, что относится к QA-работе:\n- автотесты (automation tests -  автоматизированные тесты)\n- фиксы тестов\n- тестовые данные\n- документацию (чек-листы/кейсы)\n- конфиги CI/CD (пайплайны)\n\nЕсть 2 типичных варианта.\n\n<b>Вариант А:</b> QA добавил автотесты и отправил в свою ветку.\nНапример, Postman коллекцию/тесты или UI-автотесты. Это код, его хранят в репозитории.\n<pre><code class=\"lang-bash\">\ngit switch -c qa/add-postman-tests\n# добавляешь файлы: postman_collection.json, README и т.п.\ngit add .\ngit commit -m \"Add Postman API smoke tests (дымовые тесты)\"\ngit push -u origin qa/add-postman-tests\n</code>\n</pre>\nДальше создаёшь MR/PR в main (обычно через веб-интерфейс GitHub/GitLab).\n<hr>\n<b>Вариант Б:</b> QA ничего не пушит, а заводит Issue/bug\nЕсли QA не менял репозиторий, а нашёл дефект - он создаёт Issue/bug в трекере (GitHub Issues / GitLab Issues / Jira), прикладывает логи/шаги/видео. Git тут нужен, чтобы:\n- указать ветку и коммит(ы), где баг воспроизводится\n- дать ссылку на MR/PR\n- сузить область изменений\n</div>\n</details>","path":"-"}},{"title":"CI / CD / Pipeline / Jenkins","data":{"code":"-","description":"<img src=\"https://sun9-49.vkuserphoto.ru/s/v1/ig2/vN2dJzuiB5Jfs2wNm9WwZTsHkCvtbBXHqtgw-vVRxWBeQIJSK6SwuWECaBu_2yqX60L8jbjkpTNU3yaYRmgSASkG.jpg?quality=95&amp;as=32x15,48x23,72x34,108x51,160x76,240x113,360x170,480x227,540x255,612x289&amp;from=bu&amp;cs=612x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nПредставь стандартный процесс разработки без автоматизации. Разработчики написали код и запушили его в репозиторий - настал этап тестирования. QA скачивает проект, запускает тесты вручную и проверяет, что ничего не сломалось. После этого он даёт зелёный свет. Разработчики собирают билд и выкатывают его на сервер.\n\nПри этом все надеются, что никто ничего не забыл, что все шаги были выполнены в правильном порядке и точно так же, как в предыдущий раз. И здесь появляется ключевая проблема - человеческий фактор. Люди ошибаются, забывают шаги, выполняют одни и те же действия каждый раз по-разному, особенно когда проект становится большим и сложным. Кроме того, постоянное повторение однотипных ручных операций сильно замедляет процесс разработки.\n\n<hr>\n<h5>CI - Continuous Integration (непрерывная интеграция)</h5>\n\n<b>CI (Continuous Integration)</b> - это методология разработки и набор практик, при которых изменения в код вносятся небольшими порциями и регулярно интегрируются в общий репозиторий с помощью частых коммитов. Поскольку современные приложения разрабатываются с использованием множества технологий, платформ и инструментов, возникает необходимость в механизме, который позволяет автоматически проверять, что новые изменения корректно интегрируются с уже существующим кодом и не ломают систему.\n\n<b>С технической точки зрения цель CI</b> - обеспечить единый, последовательный и автоматизированный процесс сборки и тестирования приложения при каждом изменении кода. При налаженной непрерывной интеграции разработчики чаще делают небольшие коммиты, а проблемы обнаруживаются на ранних этапах. Это снижает количество ошибок, упрощает их поиск и в итоге повышает качество программного обеспечения и прозрачность взаимодействия внутри команды.\n\n\n<details>\n<summary>Как это работает</summary>\n<div>\nНа практике непрерывная интеграция реализуется через автоматические сценарии, которые запускаются при каждом изменении кода в репозитории. Эти сценарии выполняют одни и те же шаги каждый раз в одинаковом порядке: получают актуальную версию проекта, собирают его и запускают заранее определённые проверки. Благодаря этому устраняется человеческий фактор и гарантируется, что каждое изменение проходит базовую техническую валидацию.\n\nЕсли смотреть на непрерывную интеграцию не как на абстрактную методологию, а как на реальный рабочий механизм, то CI можно представить как автоматического проверяющего, который реагирует на каждое изменение в репозитории. Как только разработчик делает коммит и отправляет его в удалённый репозиторий, CI-система получает сигнал о том, что код изменился, и сразу начинает проверку.\n<hr>\nПервым шагом CI всегда получает актуальную версию кода из репозитория и подготавливает среду для проверки. Это означает установку зависимостей и настройку окружения в заранее определённой конфигурации. Для QA этот момент особенно важен, потому что тесты запускаются не в “чьей-то” локальной среде, а в стандартизированных условиях, одинаковых для всех изменений.\n<hr>\nПосле подготовки окружения CI выполняет техническую проверку проекта. Если код не собирается или содержит критические ошибки, процесс останавливается сразу, не доходя до этапа тестирования. Это позволяет отсекать заведомо некорректные изменения ещё до того, как они попадут в общую кодовую базу или на этап ручного тестирования.\n<hr>\nЕсли сборка проходит успешно, CI переходит к автоматическим проверкам. В этот момент запускаются тесты, которые должны подтвердить, что внесённые изменения не нарушили базовую работоспособность системы. Результаты этих проверок фиксируются системой и становятся доступными всей команде. Для QA это означает, что информация о качестве изменения появляется сразу и привязана к конкретному коммиту.\n<hr>\nВ случае ошибки CI останавливает дальнейшее продвижение изменения и сигнализирует о проблеме. Это делает процесс обратной связи максимально быстрым: разработчик видит проблему практически сразу после коммита, а QA получает чёткую точку, с которой началось нарушение, без необходимости воспроизводить цепочку событий вручную.\n<hr>\n<b>Для QA:</b> CI прежде всего означает смещение точки обнаружения ошибок как можно ближе к моменту их появления. Вместо ручного запуска одних и тех же проверок тесты начинают выполняться автоматически сразу после коммита, и если что-то ломается, становится сразу понятно, какое именно изменение привело к проблеме. Это резко упрощает анализ дефектов и снижает стоимость их исправления.\n</div>\n</details>\n\n<details>\n<summary>Какие тесты выполняются в CI</summary>\n<div>\nCI -  это не место для \"всех тестов\".\nCI - это место для быстрых, детерминированных и диагностируемых проверок, которые должны выполняться при каждом изменении кода.\n\n<b>1. Unit-тесты (модульные тесты):</b> В CI выполняются в первую очередь . Это самый базовый и самый важный слой. Они проверяют отдельные функции, методы и модули в изоляции, выполняются очень быстро и дают максимально точную точку отказа. Если unit-тест падает, почти всегда понятно, где именно ошибка и кто её внёс. Для CI это идеальный кандидат: быстрый, дешёвый, стабильный.\n<hr>\n<b>2. Integration testing (интеграционные тесты):</b> в узком смысле - проверки взаимодействия между компонентами внутри приложения или с ближайшими зависимостями. Например, корректно ли сервис работает с базой данных, очередью или внутренним API. В CI такие тесты допустимы, если они по-прежнему достаточно быстрые и воспроизводимые. Как только интеграционный тест начинает зависеть от нестабильного окружения или внешних сервисов, он перестаёт быть хорошим кандидатом для CI.\n<hr>\n<b>3.  API-тесты:</b> Часто в CI также запускаются. Они проверяют контракт и базовую работоспособность сервисов через публичные интерфейсы. Для QA это особенно ценно, потому что API-тесты стоят дешевле UI, быстрее выполняются и ловят большой класс регрессий. В CI им место до тех пор, пока они не начинают занимать слишком много времени или флапать из-за окружения.\n<hr>\n<b>4. Отдельно стоит упомянуть статические проверки</b>. Формально это не тесты, но в контексте CI они выполняют ту же роль фильтра качества. Проверки стиля кода, линтеры, статический анализ - всё это идеально ложится в CI, потому что они быстрые, однозначные и не требуют запуска приложения. Для QA важно понимать, что падение таких проверок - это не баг продукта, а технический стоппер, и относиться к нему нужно иначе.\n<hr>\n<b>5. Smoke Test (смоук тесты):</b> Иногда в CI включают смоук-тесты, но здесь нужно быть осторожным. Смоук в CI должен быть минимальным: буквально проверка того, что приложение стартует и отвечает на базовые запросы. Как только смоук разрастается и превращается в мини-регрессию, он начинает вредить CI, замедляя обратную связь и повышая нестабильность.\n<hr>\nА вот UI-тесты, end-to-end сценарии и тяжёлый регресс - это как раз то, что не является естественной частью CI. Причина не в том, что они плохие, а в том, что они медленные, хрупкие и плохо диагностируемые. Если UI-тест падает в CI, QA часто тратит больше времени на выяснение, флап это или баг, чем на реальное улучшение качества. Поэтому такие проверки либо выносятся за рамки CI, либо запускаются реже и в другом контексте.\n<hr>\n<b>Если всё это собрать в одну мысль, то получится простое правило:\nв CI выполняются те тесты, которые можно запускать часто, которые быстро дают результат и по которым можно сразу принять решение - пропускать изменение дальше или нет.</b>\n</div>\n</details>\n\n<hr>\n<h5>CD - Continuous Delivery (непрерывная доставка)</h5>\n\n<b>CD - Continuous Delivery (непрерывная доставка) -</b> это дополнительное расширение непрерывной интеграции, которое автоматически развертывает новые изменения кода после этапа сборки в производственной среде клиента. Цель автоматизации очевидна - снизить нагрузку с разработчиков и свести к минимуму человеческий ошибки, при этом поддерживая согласованный процесс выпуска ПО.\n\nЕсли CI отвечает на вопрос \"корректно ли изменение с технической точки зрения\", то CD отвечает на следующий логичный вопрос -  \"что делать с этим изменением дальше\". После того как код автоматически проверен и признан пригодным, его нужно доставить в окружение, где с ним смогут работать люди или другие системы. Именно эту часть процесса и покрывает CD.\n\n<b>С точки зрения механики CD</b> - можно представить как автоматизированное продолжение CI. Когда проверки завершились успешно, система не останавливается на отчёте о тестах, а выполняет дальнейшие действия: подготавливает артефакт приложения, настраивает окружение и размещает новую версию в нужном месте, после чего выкатка на прод происходит вручную. Главное отличие от CI в том, что здесь речь идёт уже не о проверке кода, а о его доставке и запуске.\n\n<b>Continuous Deployment</b> - непрерывное развёртывание. Это более продвинутый путь, на шаг дольше, чем непрерывная поставка. При таком подходе каждое изменение, которое мы коммитим в основную ветку репозитория, автоматически проходит все этапы CI и CD и затем попадает на продакшн.\n\n<details>\n<summary>Как это работает</summary>\n<div>\nДля QA CD важен тем, что он устраняет ещё один источник человеческого фактора. Без автоматизации выкладка часто выполняется вручную: кто-то собирает билд, кто-то копирует файлы, кто-то забывает применить конфигурацию или делает это не в том окружении. В результате QA может тестировать не ту версию, которая была проверена в CI, или тестировать её в условиях, отличных от предыдущих запусков. CD решает эту проблему, гарантируя, что в тестовое или промежуточное окружение попадает именно тот результат, который прошёл автоматические проверки.\n\nС технической точки зрения CD обеспечивает воспроизводимость доставки. Каждая новая версия разворачивается по одному и тому же сценарию, с одинаковыми шагами и настройками. Для QA это означает, что различия между окружениями и релизами становятся минимальными и предсказуемыми, а найденные дефекты проще воспроизводить и анализировать.\n\n<b>Важно понимать:</b> CD не обязательно означает автоматическую выкладку в продакшен. Во многих командах доставка останавливается на тестовом или staging-окружении и требует ручного подтверждения для следующего шага. Однако даже в этом случае основная ценность CD сохраняется: процесс доставки формализован, прозрачен и не зависит от конкретного человека.\n\nТаким образом, для QA CD - это не про скорость выкладки, а про доверие к среде тестирования. Когда доставка автоматизирована, QA может быть уверен, что тестирует именно ту версию продукта, которая прошла все предыдущие проверки, а не случайный набор изменений, собранный вручную.\n</div>\n</details>\n\n<details>\n<summary>Какие тесты выполняются в CD</summary>\n<div>\n<b>Сразу зафиксируем базу:</b> CD - это не про \"проверить код\", а про \"проверить работающую систему в реальном окружении\". Отсюда и ответ, какие тесты там уместны.\n\nВ CD выполняются те тесты, которые имеют смысл только после развёртывания приложения. То есть такие проверки, которые невозможно или бессмысленно запускать на уровне исходного кода или сборки.\n<hr>\n<b>1. Smoke-тесты:</b> В первую очередь. Их задача предельно прагматичная: убедиться, что система вообще запустилась и доступна. Приложение стартует, основные сервисы отвечают, база данных доступна, критические эндпоинты не падают с ошибкой. Для QA это момент истины: CI мог быть полностью зелёным, но если приложение не поднялось - дальше тестировать просто нечего.\n<hr>\n<b>2. API:</b> Следующий слой - API-тесты на развернутой среде. В CI API-тесты часто работают в изолированной или упрощённой конфигурации, а в CD они проверяют систему так, как она реально будет использоваться: с настоящими конфигурациями, сетевыми настройками, очередями, базой данных. Для QA это ключевой момент проверки интеграции компонентов в живом окружении.\n<hr>\n<b>3. Интеграционные тесты:</b> В CD также часто выполняются интеграционные тесты широкого смысла - проверки взаимодействия между сервисами, которые невозможно полноценно проверить без реального развёртывания. Это может быть взаимодействие между несколькими микросервисами, проверка асинхронных процессов, очередей сообщений, фоновых задач. Такие тесты слишком тяжёлые и зависимые от окружения для CI, но в CD они уместны и логичны.\n<hr>\n<b>4. E2E:</b> Отдельно стоит end-to-end (E2E) сценарии, но с важной оговоркой. В CD их запускают не как полный регресс, а как ограниченный набор критических пользовательских сценариев. Например: пользователь может авторизоваться, выполнить ключевое действие и получить ожидаемый результат. Для QA это не проверка \"всё ли работает\", а проверка \"работает ли самое важное\".\n<hr>\n<b>5. UI-тесты:</b> Иногда в CD добавляют UI-тесты, но здесь QA должен быть особенно строгим. UI-тесты в CD допустимы только в том случае, если они стабильны, воспроизводимы и действительно проверяют бизнес-критичные потоки. Массовый UI-регресс в CD - это почти всегда ошибка проектирования процесса, а не признак зрелости.\n<hr>\n<b>6. Нефункциональные тесты:</b> Также в CD могут выполняться нефункциональные проверки начального уровня. Например, базовые проверки производительности, корректности конфигураций, доступности сервисов, иногда - проверки безопасности или прав доступа. Это не глубокое нагрузочное или security-тестирование, а скорее сигнал: \"в этой версии что-то принципиально не так\".\n<hr>\n<b>Если всё это свести к одной мысли, получится простое правило:</b> в CD выполняются тесты, которые подтверждают, что развернутая версия системы пригодна для использования в конкретном окружении.\n\nCD -  это не место для полного регресса. Если CD превращается в \"ещё один CI, но медленнее\" - процесс сломан.\nЗадача CD - ответить на вопрос: \"Эту версию можно отдавать дальше - людям, бизнесу, продакшену?\"\n</div>\n</details>\n\n<hr>\n<h5>Pipeline (конвейер)</h5>\n\n<b>Pipeline</b> - описывает, каким путём проходит код от момента коммита до развернутого приложения и какие действия выполняются на каждом этапе этого пути. Если CI отвечает за автоматическую проверку изменений, а CD - за доставку и запуск проверенной версии в нужном окружении, то pipeline является механизмом, который связывает эти два процесса в единое целое.\n\nС практической точки зрения pipeline -  это формализованное описание процесса работы с кодом. Он фиксирует порядок действий, условия их выполнения и точки остановки. Благодаря этому CI и CD перестают быть разрозненными шагами и превращаются в управляемый, предсказуемый поток, в котором каждое изменение проходит одни и те же стадии и оценивается по одинаковым правилам.\n\n<details>\n<summary>Как это работает</summary>\n<div>\nПредставь pipeline как автоматическую линию контроля, которая запускается каждый раз, когда код меняется.\nНикто не думает, что запускать и в каком порядке - это уже решено заранее.\n\nРазработчик делает коммит и отправляет его в репозиторий. В этот момент система автоматизации получает событие: код изменился. Это и есть старт pipeline. Дальше процесс идёт сам, без участия людей.\n\nPipeline сначала забирает код именно в том состоянии, в котором он был закоммичен. Это важно: QA потом всегда может сказать, какую версию проверяли, а не \"примерно ту, что была вчера\". Затем подготавливается среда выполнения - чистая, стандартизированная, без локальных настроек конкретного человека. Уже здесь отсекается масса проблем вида \"у меня работает\".\n\nПосле этого pipeline начинает последовательно выполнять шаги, которые были в нём описаны. Каждый шаг - это отдельная проверка или действие. Если шаг проходит успешно, pipeline идёт дальше. Если шаг падает - pipeline останавливается. Никаких \"ну давай попробуем дальше\" Это принципиальный момент: pipeline - это фильтр, а не отчёт.\n\nНа ранних этапах pipeline проверяет техническую состоятельность изменений. Код должен собраться, зависимости - установиться, базовые проверки - пройти. Если этого не происходит, изменение просто не имеет смысла двигать дальше. QA в этот момент уже получает сигнал: проблема не в бизнес-логике, а в самом изменении или окружении.\n\nКогда ранние проверки пройдены, pipeline может перейти к запуску тестов. Здесь QA видит главное преимущество pipeline: результаты тестов всегда привязаны к конкретному шагу и конкретному изменению. Не \"где-то упало\", а где именно и после чего. Это резко упрощает анализ дефектов.\n\nЕсли все проверки в рамках CI завершились успешно, pipeline переходит к действиям CD. Он берёт уже проверенный результат и автоматически разворачивает его в нужном окружении. Это может быть тестовый стенд или staging. Важно, что выкладывается ровно та версия, которая прошла проверки, а не что-то собранное отдельно.\n\nПосле развёртывания pipeline снова запускает проверки, но уже другого типа. Теперь система проверяется не как набор файлов, а как работающий продукт. Если здесь что-то ломается, pipeline снова останавливается. Это означает, что версия не готова двигаться дальше - не потому что \"кто-то так решил\", а потому что проверка не прошла.\n\nВесь этот процесс фиксируется автоматически. У каждого шага есть статус, логи и чёткий результат. Для QA pipeline становится источником истины: по нему можно восстановить, что происходило с версией от коммита до развертывания и на каком этапе возникла проблема.\n\nКлючевой момент: pipeline не ускоряет разработку сам по себе. Он убирает неопределённость. Вместо догадок появляется точный ответ, где и почему версия остановилась. И именно это делает pipeline центральным связующим звеном между CI и CD.\n</div>\n</details>\n\n<details>\n<summary>Роли в CI/CD Pipeline</summary>\n<div>\nЕсли смотреть на CI/CD pipeline как на механизм, то роли в нём определяются не должностями, а ответственностью за решения и последствия. Pipeline сам по себе ничего не решает - он лишь исполняет правила, которые задали люди.\n<hr>\n<b>1. Разработчик:</b> Его ответственность заканчивается не на написании кода, а на том, чтобы изменение было корректно интегрировано. Разработчик отвечает за то, чтобы коммиты были небольшими, осмысленными и проходили автоматические проверки. Если CI падает на сборке или unit-тестах, это почти всегда зона ответственности разработчика, а не QA. В pipeline разработчик — источник изменений и первый, кто должен реагировать на технические падения.\n<hr>\n<b>2. QA:</b> И здесь важно не ошибиться. QA в CI/CD pipeline не оператор и не кнопкодав. Его роль - определить, что именно считается достаточной проверкой на каждом этапе и как интерпретировать результат. QA отвечает за то, какие тесты уместны в CI, какие - в CD, какие проверки являются стоп-фактором, а какие - информационными. Если pipeline зелёный, но версия нестабильна - это не вина pipeline, это пробел в тестовой стратегии, и это зона ответственности QA.\n<hr>\n<b>3. DevOps:</b> по сути это владелец инфраструктуры pipeline. Этот человек или команда отвечает за то, чтобы pipeline был исполняемым: окружения поднимались, ресурсы были доступны, конфигурации не ломались. DevOps не определяет, что тестировать, но обеспечивает, где и как это выполняется. Если pipeline падает из-за отсутствия ресурсов, сломанных агентов или сетевых проблем - это его зона.\n<hr>\n<b>4. Тимлид:</b> Отдельно стоит роль владельца процесса - часто это тимлид или технический лидер. Он отвечает за архитектуру pipeline в целом: где проходят границы CI и CD, какие этапы являются блокирующими, а какие - нет, как быстро команда получает обратную связь. Эта роль критична, потому что именно здесь принимаются решения, влияющие на скорость разработки и качество одновременно.\n</div>\n</details>\n\n<details>\n<summary>Инструменты для работы с CI/CD Pipeline</summary>\n<div>\nЕсли смотреть на CI/CD pipeline как на работающий механизм, то инструменты в нём делятся не по названиям, а по функциям, которые они выполняют. QA работает не со всеми инструментами напрямую, но должен понимать, кто за что отвечает и где смотреть проблему.\n<hr>\n<b>1. Система CI/CD:</b> В центре всего стоит CI/CD система, которая исполняет pipeline. Это может быть Jenkins, GitLab CI, GitHub Actions, TeamCity и аналоги. Для QA это основной интерфейс наблюдения за процессом. Именно здесь видно, какой шаг выполнился, какой упал, какие тесты запускались и какие логи были получены. QA не обязан уметь настраивать такую систему, но обязан уметь читать результаты её работы и понимать, что именно произошло на каждом этапе.\n<hr>\n<b>2. Система контроля версий:</b> Дальше идут инструменты контроля версий, прежде всего Git и платформы вокруг него. Репозиторий - это источник истины для pipeline. Именно отсюда он берёт код, и именно к конкретному коммиту привязываются все результаты проверок. Для QA это означает, что любой результат в CI/CD всегда можно связать с конкретным изменением и конкретным человеком, а не с абстрактной \"версией\".\n<hr>\n<b>3. Сборщики:</b> Следующий важный слой - инструменты сборки и упаковки. Это могут быть Maven, Gradle, npm, yarn, а также Docker. Pipeline использует их, чтобы собрать приложение в воспроизводимом виде. QA здесь важно понимать, что сбой на этом этапе - это не баг логики продукта, а проблема сборки, зависимостей или окружения. Очень частая ошибка - заводить дефект на приложение, когда на самом деле не собрался артефакт.\n<hr>\n<b>4. Инструменты тестирования:</b> После сборки и на этапе тестированием активно используются инструменты тестирования. Это фреймворки для unit, API, UI и других типов тестов. Pipeline просто запускает их, а QA отвечает за интерпретацию результата. Если тест упал - это не всегда дефект продукта. Это может быть нестабильный тест, ошибка данных или проблема окружения, и именно QA должен это различить.\n<hr>\n<b>5. Деплой:</b> Для этапов доставки и запуска используются инструменты деплоя и управления окружениями. Это могут быть скрипты, Docker, Kubernetes, конфигурационные менеджеры. QA обычно не управляет этими инструментами напрямую, но должен понимать, что они делают: где именно развернулась версия, какие параметры использовались и почему поведение системы может отличаться от локального или CI-окружения.\n<hr>\n<b>6. Метрики:</b> Отдельно стоит слой наблюдаемости - логи, метрики, отчёты. Pipeline без логов бесполезен. QA постоянно работает с логами шагов, результатами тестов, артефактами сборки. Это позволяет не просто увидеть \"красный статус\", а понять причину и корректно сформулировать проблему для разработчиков или DevOps.\n<hr>\n<b>7. Инструменты управления процессом:</b> И наконец, есть инструменты управления процессом, такие как баг-трекеры и системы задач. Они не являются частью pipeline технически, но связаны с ним логически. Результаты CI/CD часто становятся основанием для заведения дефектов, блокировки релиза или возврата задачи в разработку. Для QA важно уметь связать результат pipeline с конкретной задачей или багом, а не держать это в голове.\n</div>\n</details>\n\n<hr>\n<h5>Пример</h5>\n\n<b>Cквозной пример:</b> Git &gt; CI &gt; CD &gt; окружение &gt; проверки &gt; что делает QA. \n<b>Самый типовой стек:</b> GitHub + GitHub Actions (действия GitHub) + Docker + Kubernetes (K8s, Кубернетес).\n<b>Представим проект:</b> web-api (REST API), есть юнит-тесты и API-тесты, деплой в staging.\n- в репозитории есть Dockerfile\n- есть тесты: unit и api\n- есть manifest/helm для K8s\n- есть registry (например, GHCR - GitHub Container Registry)\n\n<hr>\n<details>\n<summary>1. Разработчик делает изменение и открывает PR</summary>\n<div>\nDev создал ветку и сделал коммиты:\n<pre><code class=\"lang-bash\">\ngit checkout -b feature/login-rate-limit\n# правки кода\ngit add .\ngit commit -m \"Add rate limit for login\"\ngit push -u origin feature/login-rate-limit\n</code>\n</pre>\n\nНа GitHub он открывает Pull Request (PR, запрос на слияние) в main.\n\n<b>Что делает QA на этом шаге:</b> смотрит PR по сути (риски, затронутые модули) и понимает, какие проверки должны поймать регресс.\n</div>\n</details>\n\n<details>\n<summary>2. CI стартует автоматически от PR</summary>\n<div>\nСрабатывает GitHub Actions workflow (условно .github/workflows/ci.yml). CI делает одно и то же каждый раз:\n- забирает код PR\n- ставит зависимости\n- запускает статические проверки (линтер)\n- запускает unit-тесты\n- собирает Docker image (часто уже в CI)\n- публикует артефакты/отчёты\n\nПример того, что реально выполняется внутри CI (упрощённо):\n<pre><code class=\"lang-bash\">\nnpm ci\nnpm run lint\nnpm test\ndocker build -t ghcr.io/org/web-api:pr-123 .\n</code>\n</pre>\nЕсли unit-тесты упали - CI красный, PR нельзя мержить.\n\n<b>Что делает QA:</b> открывает CI run &gt; смотрит на каком шаге упало\n<b>если упал тест:</b> это баг продукта или флейк (flaky, нестабильный тест)?\n<b>если упала сборка:</b> это не \"баг приложения\", а проблема зависимостей/конфига/докерфайла\n</div>\n</details>\n\n<details>\n<summary>3. Merge в main &gt; стартует CD (доставка/развёртывание)</summary>\n<div>\nКогда PR принят и замержен:\n<pre><code class=\"lang-bash\">\ngit checkout main\ngit pull\n</code>\n</pre>\n\n<b>Теперь включается CD:</b> уже не \"проверяем код PR\", а \"готовим и выкатываем версию\".\n\nТипичный CD сценарий:\n- собрать “релизный” Docker image\n- запушить в registry\n- развернуть в staging на Kubernetes\n- подождать готовности (readiness)\n- прогнать smoke + API checks на staging\n- если всё ок - отметить релиз как годный (и иногда предложить кнопку \"Deploy to prod\")\n\nКоманды (по смыслу) такие:\n<pre><code class=\"lang-bash\">\ndocker build -t ghcr.io/org/web-api:1.7.0 .\ndocker push ghcr.io/org/web-api:1.7.0\n\n# деплой в Kubernetes:\nkubectl set image deployment/web-api web-api=ghcr.io/org/web-api:1.7.0 -n staging\nkubectl rollout status deployment/web-api -n staging\n</code>\n</pre>\n\n<b>Что делает QA:</b> проверяет, что в staging попала именно нужная версия (по тегу image / по build number) если rollout завис/упал - идёт смотреть причины\n</div>\n</details>\n\n<details>\n<summary>4. Где QA смотрит, если деплой \"сломался\"</summary>\n<div>\nЕсли rollout status не проходит, QA (или вместе с DevOps) смотрит:\n<pre><code class=\"lang-bash\">\nkubectl get pods -n staging\nkubectl describe pod <pod> -n staging\nkubectl logs <pod> -n staging --tail=200\n</pod></pod></code>\n</pre>\n\nТиповые причины, которые QA должен уметь отличать:\n- контейнер не стартует (crashloop) &gt; часто конфиг/переменные/секреты\n- readiness probe не проходит &gt; приложение живое, но не готово обслуживать\n- не подтянулся image &gt; проблемы registry/доступа/тега\n- миграции БД не прошли &gt; версия поднялась частично\n\n<b>Это важный QA-навык:</b> не назвать \"багом приложения\" то, что является проблемой окружения/деплоя.\n\n</div>\n</details>\n\n<details>\n<summary>5. Тесты, которые реально запускают после деплоя (CD checks)</summary>\n<div>\nПосле успешного rollout CD обычно запускает минимум:\n\nSmoke (смоук) на staging: \"сервис жив и отвечает\"\n\n<pre><code class=\"lang-bash\">\ncurl -f https://staging.api.example.com/health\ncurl -f https://staging.api.example.com/version\n</code>\n</pre>\n\nAPI tests против staging:\n<pre><code class=\"lang-bash\">\nnewman run api-collection.json --env-var baseUrl=https://staging.api.example.com\n</code>\n</pre>\n\nИногда - небольшой E2E (сквозной) критический сценарий, но короткий.\n\n<b>Что делает QA:</b>\n<b>- если smoke упал:</b> это блокер (версия не пригодна)\n<b>- если API тесты упали:</b> QA помогает быстро определить - это регресс, изменение контракта, данные окружения или флейк\n<b>- если тесты зелёные:</b> QA получает доверие к тому, что тестирует именно развернутую версию\n</div>\n</details>\n\n<details>\n<summary>6. Дальше два варианта CD</summary>\n<div>\n<b>1. Continuous Delivery (непрерывная доставка):</b> после staging есть шаг “готово к прод” и дальше ручное подтверждение.\n\n<b>2. Continuous Deployment (непрерывный деплой):</b> после зелёных проверок staging автоматически катит в prod.\n\nQA в большинстве команд участвует как \"gate\" (ворота) между staging &gt; prod: не нажать кнопку, а оценить риски по сигналам (падения, флейки, изменения).\n</div>\n</details>\n\n<details>\n<summary>Что было использовано</summary>\n<div>\nЧто в этом примере \"инструменты\" и как QA ими пользуется:\n- Git/GitHub: PR, diff, история, привязка результатов к коммиту\n- GitHub Actions: где видно шаги CI/CD и логи\n- Docker: сборка образа, одинаковый запуск\n- Registry: откуда K8s тянет image\n- Kubernetes: реальный запуск версии, статусы, логи, rollout\n- Postman/Newman или аналоги: API проверки после деплоя\n- Curl/health endpoint: smoke\n\nQA не обязан \"строить\" это всё, но обязан читать симптомы и быстро локализовать: код/тест/окружение/деплой.\n</div>\n</details>\n\n<details>\n<summary>А когда проводятся другие тесты</summary>\n<div>\nЕсли CI и CD -  это обязательный автоматический фильтр, то все остальные тесты проводятся вне этого фильтра, по расписанию, по событию или по решению команды. Они не \"хуже\" и не \"вторичны\", у них просто другая цель.\n\nПосле того как версия прошла CI и была доставлена в окружение через CD, начинается то, что можно назвать осознанным тестированием, а не автоматической проверкой на каждый коммит.\n\n<hr>\n<b>- Полный регресс:</b> обычно проводится после стабилизации версии. Это либо отдельная стадия перед релизом, либо отдельный прогон по расписанию (например, ночью). Причина простая: полный регресс дорогой и долгий. Запускать его на каждое изменение - значит парализовать разработку. QA здесь уже не фильтрует изменения, а отвечает на вопрос: \"Не сломали ли мы систему в целом?\"\n<hr>\n<b>- Расширенные UI-тесты:</b> почти всегда выполняются вне CI и базового CD. Их либо запускают по расписанию, либо перед релизом, либо при значительных изменениях в интерфейсе. UI-тесты проверяют пользовательские сценарии, но они слишком хрупкие и медленные, чтобы быть частью постоянного автоматического конвейера. В pipeline они попадают только в минимальном виде, как smoke или один-два критических сценария.\n<hr>\n<b>-Нагрузочное и стресс-тестирование: </b>проводится перед релизом или по отдельному плану, а не на каждом коммите. Эти тесты отвечают на вопрос: \"Выдержит ли система реальную или пиковую нагрузку?\"\n\nИх бессмысленно запускать в CI/CD, потому что:\n- они требуют выделенных ресурсов,\n- они меняют состояние системы,\n- они дают результат только в сравнении, а не \"pass/fail\".\n<hr>\n<b>- Тестирование безопасности:</b> также выполняется периодически или перед релизом. Базовые security-проверки могут быть встроены в CI (скан зависимостей, простые статические анализаторы), но полноценные проверки, аудит, пентесты - это отдельная активность, а не часть конвейера доставки.\n<hr>\n<b>- Исследовательское (exploratory) тестирование:</b> вообще не привязано к pipeline. Оно проводится тогда, когда версия уже доступна в окружении и QA целенаправленно ищет нестандартные сценарии, слабые места и логические ошибки. Это то, что автоматизация принципиально не заменяет и что всегда остаётся зоной ответственности QA.\n<hr>\n<b>- Регрессы по багам:</b> часто запускаются по событию. Закрыли критичный дефект - QA вручную или автоматизировано проверяет связанные области, но это не обязательно часть CI/CD. Это реакция на риск, а не стандартный шаг процесса.\n<hr>\nЕсли свести всё это к одной простой, но важной модели, получится так:\n- CI и CD отвечают на вопрос: \"Можно ли этому изменению двигаться дальше прямо сейчас?\"\n- Все остальные тесты отвечают на вопрос: \"Насколько система в целом готова к использованию и релизу?\"\n\nЭто разные вопросы, и поэтому они живут в разных местах процесса.\n</div>\n</details>\n\n<hr>\n<h5>Jenkins</h5>\n<img src=\"https://sun9-85.vkuserphoto.ru/s/v1/ig2/qUwaHOi-s23edDJm2wdCikXjPFwAFcSsUhi5-4B5119MV5f403EmGC54dtXyOXpZU_wigwYnARB1NtHm1_teYEkl.jpg?quality=95&amp;as=32x32,48x48,72x72,108x108,160x160,240x240,360x360,400x400&amp;from=bu&amp;cs=400x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Jenkins</b> - open source инструмент автоматизации, используемый для организации процессов CI/CD (непрерывной интеграции и доставки), таких как сборка, тестирование и развертывание программного обеспечения.\n\n<details>\n<summary>Как это работает</summary>\n<div>\n<img src=\"https://sun9-47.vkuserphoto.ru/s/v1/ig2/5K8yp8DnueefVWQROt11bWq2vXyjTz4J79wgl5kj5Mohv6lMONBkGwQKYLXk8y-i2lOP4z9LtN_FcDN3pg38_TQ_.jpg?quality=95&amp;as=32x12,48x17,72x26,108x39,160x58,240x86,360x130,480x173,540x194,640x230,720x259,1080x389,1181x425&amp;from=bu&amp;cs=1181x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nJenkins использует распределённую архитектуру, в которой задачи выполняются на удалённых исполнителях (агентах), управляемых центральным сервером.\n<hr>\n<b>Контроллер</b> - центральный сервер Jenkins, отвечающий за:\n- хранение конфигурации;\n- запуск и планирование задач;\n- взаимодействие с репозиториями;\n- выбор подходящего агента;\n- сбор логов и результатов выполнения.\n<hr>\n<b>Агенты</b> - это узлы, которые непосредственно выполняют задания (сборку, тестирование, деплой).\nОни могут работать на разных операционных системах и запускаться динамически, что позволяет:\n- масштабировать систему;\n- распределять нагрузку;\n- выполнять специфичные сборки под нужную среду.\n<hr>\n<b>Node (нода)</b> - это любой сервер или окружение, зарегистрированное в Jenkins, на котором могут выполняться задачи. Контроллер и агенты являются нодами.\n<hr>\n<b>Job</b> - это единица запускаемой работы, т.е. описание того, ЧТО Jenkins должен выполнить и КОГДА.\n\n<b>Из чего состоит Job:</b>\n<b>1. Триггеры</b> - когда запускать\n- вручную\n- по коммиту (SCM)\n- по расписанию (cron)\n- по результату другого job\n<b>2. Окружение</b> - где и как\n- на каком агенте\n- какие переменные окружения\n- какие credentials (учётки)\n<b>3. Шаги выполнения</b> - что делать\n- shell-скрипты\n- вызов сборки\n- запуск тестов\n- деплой\n<b>4. Результат</b> - что по итогу получаем\n- SUCCESS / FAILURE / UNSTABLE / ABORTED\n- логи\n- артефакты\n\nBuild (билд) - это конкретный запуск Job\nJob - это шаблон, Build - экземпляр\n<hr>\n<b>Jenkinsfile</b> - это файл конфигурации находящийся в репозитории проекта. В нём виде кода описан pipeline (пайплайн) для Jenkins: какие шаги выполнять, в каком порядке и при каких условиях. Jenkinsfile -  это инструкция для Jenkins, как именно выполнять CI/CD для проекта. \n\nВ Jenkinsfile указывают:\n- на каком агенте выполнять pipeline;\n- из каких этапов он состоит;\n- какие команды запускать;\n- что считать успешным или провальным результатом;\n- какие действия выполнить после завершения (уведомления, публикация отчётов).\n<hr>\nПредставим, что в репозитории Git настроен пайплайн в Jenkins. После пуша изменений в репозиторий срабатывает триггер, который уведомляет Jenkins о новом коммите. Контроллер принимает это событие и запускает соответствующий job, создавая новый билд. Билд помещается в очередь, после чего контроллер выбирает подходящий агент, на котором можно выполнить сборку. Агент клонирует репозиторий и начинает выполнение пайплайна, описанного в Jenkinsfile. Пайплайн последовательно проходит этапы сборки, тестирования и, при необходимости, развертывания приложения. В процессе выполнения агент передаёт логи и результаты выполнения контроллеру. По завершении пайплайна Jenkins фиксирует статус билда и, в зависимости от результата, выполняет пост-действия: публикует отчёты, отправляет уведомления команде или блокирует дальнейшее продвижение изменений.\n</div>\n</details>\n\n<details>\n<summary>Пример</summary>\n<div>\nНа примере будет репозиторий в котором не настроен Jenkins и CI/CD как таковой. Чтоб пошагово понять - зачем &gt; куда &gt; как &gt; где.\n<hr>\n<b>0) Стартовая точка: в Git лежит код, Jenkins не настроен</b>\nДопустим, репозиторий на GitHub:\n<pre><code class=\"lang-bash\">\nrepo/\n  backend/...\n  frontend/...\n  docker/\n  README.md\n</code>\n</pre>\nПока нет ни Jenkins job, ни Jenkinsfile.\n<hr>\n<b>1) Поднимаем Jenkins: контроллер и агенты</b>\n\nАрхитектура (минимально практично):\n<b>- Controller (контроллер):</b> Jenkins сервер, хранит конфиги, планирует билды, держит очередь, показывает UI.\n<b>- Agents (агенты):</b> где реально выполняется сборка/тесты/деплой.\n\nПрактический сетап (типичный):\n- Controller в Docker/VM (виртуальная машина) где-то (например, отдельный сервер).\nАгент(ы) Linux:\n- agent-linux-docker - для сборки Docker образов\n- agent-linux-tests - для интеграционных/е2е (end-to-end - \"сквозных\") тестов\n- при желании agent-windows - если нужно под Windows\nJenkins видит агентов как nodes (ноды) и на каждом агенте есть executor (исполнитель) - слот параллельного выполнения.\n<hr>\n<b>2) Jenkinsfile (Pipeline as Code - \"пайплайн как код\")</b>\n<b>2.1. Добавляем Jenkinsfile в репозиторий</b>\n\nПравильный путь - разработчик делает PR (pull request - \"запрос на слияние\") с добавлением Jenkinsfile в корень репы:\n<pre><code class=\"lang-bash\">\nrepo/\n  Jenkinsfile\n  backend/...\n  frontend/...\n</code>\n</pre>\n\n<b>2.2. Пример Jenkinsfile: от unit до QA и дальше</b>\nНиже пример под типичный веб-сервис: unit -&gt; integration -&gt; e2e -&gt; ручной QA gate -&gt; сборка Docker -&gt; публикация -&gt; деплой в staging/prod.\n\n<details>\n<summary>Jenkinsfile</summary>\n<div>\n<pre><code class=\"lang-bash\">\npipeline {\n  agent none\n\n  options {\n    timestamps()\n    disableConcurrentBuilds()\n    ansiColor('xterm')\n  }\n\n  environment {\n    APP_NAME = \"my-service\"\n    DOCKER_IMAGE = \"registry.example.com/my-team/my-service\"\n    // credentialsId заведёшь в Jenkins: токены, пароли, kubeconfig и т.д.\n  }\n\n  stages {\n\n    stage(\"Checkout\") {\n      agent { label \"agent-linux-tests\" }\n      steps {\n        checkout scm\n        sh \"git rev-parse --short HEAD &gt; .gitsha\"\n        stash name: \"src\", includes: \"**/*\"\n      }\n    }\n\n    stage(\"Unit tests\") {\n      agent { label \"agent-linux-tests\" }\n      steps {\n        unstash \"src\"\n        // пример: backend unit (юнит) + frontend unit\n        sh \"cd backend &amp;&amp; ./gradlew test\"          // Java пример\n        sh \"cd frontend &amp;&amp; npm ci &amp;&amp; npm test\"     // JS пример\n      }\n      post {\n        always {\n          // если есть junit.xml - публикуй\n          // junit \"backend/**/build/test-results/test/*.xml\"\n        }\n      }\n    }\n\n    stage(\"Integration tests\") {\n      agent { label \"agent-linux-docker\" }\n      steps {\n        unstash \"src\"\n        // поднимаем зависимости и гоняем интеграционные (integration - \"интеграционные\") тесты\n        sh \"\"\"\n          docker compose -f docker/docker-compose.test.yml up -d --build\n          ./backend/gradlew integrationTest\n          docker compose -f docker/docker-compose.test.yml down -v\n        \"\"\"\n      }\n    }\n\n    stage(\"E2E tests\") {\n      agent { label \"agent-linux-tests\" }\n      when {\n        anyOf {\n          branch \"main\"\n          changeRequest() // PR\n        }\n      }\n      steps {\n        unstash \"src\"\n        // пример: Playwright/Cypress и т.п.\n        sh \"cd frontend &amp;&amp; npm run e2e\"\n      }\n      post {\n        always {\n          // archiveArtifacts artifacts: \"frontend/playwright-report/**\", allowEmptyArchive: true\n        }\n      }\n    }\n\n    stage(\"QA gate (manual)\") {\n      when {\n        branch \"main\"\n      }\n      steps {\n        // Ручной шлюз: QA подтверждает, что ок выпускать дальше.\n        // Это и есть место \"от unit до QA\": автоматом - до e2e, а QA - подтверждение.\n        timeout(time: 2, unit: 'HOURS') {\n          input message: \"QA: подтверждаем выпуск дальше?\", ok: \"Approve\"\n        }\n      }\n    }\n\n    stage(\"Build Docker image\") {\n      agent { label \"agent-linux-docker\" }\n      when {\n        branch \"main\"\n      }\n      steps {\n        unstash \"src\"\n        script {\n          def sha = sh(script: \"cat .gitsha\", returnStdout: true).trim()\n          sh \"\"\"\n            docker build -t ${DOCKER_IMAGE}:${sha} -f docker/Dockerfile .\n            docker tag ${DOCKER_IMAGE}:${sha} ${DOCKER_IMAGE}:latest\n          \"\"\"\n        }\n      }\n    }\n\n    stage(\"Push to registry\") {\n      agent { label \"agent-linux-docker\" }\n      when { branch \"main\" }\n      steps {\n        script {\n          def sha = sh(script: \"cat .gitsha\", returnStdout: true).trim()\n          withCredentials([usernamePassword(credentialsId: \"registry-creds\", usernameVariable: \"REG_USER\", passwordVariable: \"REG_PASS\")]) {\n            sh \"\"\"\n              echo \"$REG_PASS\" | docker login registry.example.com -u \"$REG_USER\" --password-stdin\n              docker push ${DOCKER_IMAGE}:${sha}\n              docker push ${DOCKER_IMAGE}:latest\n            \"\"\"\n          }\n        }\n      }\n    }\n\n    stage(\"Deploy to staging\") {\n      agent { label \"agent-linux-docker\" }\n      when { branch \"main\" }\n      steps {\n        script {\n          def sha = sh(script: \"cat .gitsha\", returnStdout: true).trim()\n          withCredentials([file(credentialsId: \"kubeconfig-staging\", variable: \"KUBECONFIG_FILE\")]) {\n            sh \"\"\"\n              export KUBECONFIG=$KUBECONFIG_FILE\n              kubectl set image deploy/${APP_NAME} ${APP_NAME}=${DOCKER_IMAGE}:${sha} -n staging\n              kubectl rollout status deploy/${APP_NAME} -n staging --timeout=120s\n            \"\"\"\n          }\n        }\n      }\n    }\n\n    stage(\"Smoke on staging\") {\n      agent { label \"agent-linux-tests\" }\n      when { branch \"main\" }\n      steps {\n        // smoke (смоук - \"дымовой\") тест: минимум проверки, что сервис жив\n        sh \"curl -fsS https://staging.example.com/health\"\n      }\n    }\n\n    stage(\"Deploy to prod\") {\n      agent { label \"agent-linux-docker\" }\n      when { branch \"main\" }\n      steps {\n        timeout(time: 1, unit: 'HOURS') {\n          input message: \"Release: выкатываем в prod (продакшен)?\", ok: \"Deploy\"\n        }\n        script {\n          def sha = sh(script: \"cat .gitsha\", returnStdout: true).trim()\n          withCredentials([file(credentialsId: \"kubeconfig-prod\", variable: \"KUBECONFIG_FILE\")]) {\n            sh \"\"\"\n              export KUBECONFIG=$KUBECONFIG_FILE\n              kubectl set image deploy/${APP_NAME} ${APP_NAME}=${DOCKER_IMAGE}:${sha} -n prod\n              kubectl rollout status deploy/${APP_NAME} -n prod --timeout=180s\n            \"\"\"\n          }\n        }\n      }\n    }\n  }\n\n  post {\n    success { echo \"SUCCESS - можно жить\" }\n    failure { echo \"FAILURE - кто-то опять сломал прод ещё до прода\" }\n    always  { echo \"DONE: ${currentBuild.currentResult}\" }\n  }\n}\n</code>\n</pre>\n</div>\n</details>\n\n<b>Что тут важно по пунктам:</b>\n- Репа изначально без Jenkins - добавили Jenkinsfile PR-ом.\n- Jenkins подключился к репе - job читает Jenkinsfile.\n- Контроллер и агенты - выполнение на агентских label-ах.\n- После следующего коммита - webhook/сканирование веток запускает pipeline.\n- Тестирование \"от Unit до QA\": Unit (юнит) - автоматически &gt;Integration (интеграционные) - автоматически &gt; E2E (сквозные) - автоматически &gt; QA - как \"manual gate\" через input (подтверждение)\n\n<b>После проверок:</b> билд &gt; Docker image &gt; registry (реестр образов) &gt; deploy staging &gt; smoke &gt; ручное подтверждение &gt; deploy prod\n<hr>\n<b>4) Что происходит после следующего коммита разработчика (реально, по шагам)</b>\nРазработчик пушит в GitHub.\n1. GitHub шлёт webhook в Jenkins (или Jenkins сам сканирует multibranch по расписанию).\n2. Контроллер создаёт build и ставит в очередь.\n3. Контроллер выбирает агента по label и свободному executor.\n4. Агент чекаутит репу и выполняет pipeline: unit -&gt; integration -&gt; e2e\n5. Если тесты зелёные: ждём QA подтверждение (manual gate)\n6. После QA:\n- собираем образ\n- пушим в registry\n- деплоим в staging\n- smoke\n- ручной релиз в prod\n7. GitHub (обычно) получает статус проверки (checks/status) и на PR видно pass/fail.\n<hr>\n<b>5) На каком этапе \"производятся тестирования от Unit до QA\"</b>\n- Unit - самый ранний этап после checkout/install, быстрый фильтр.\n- Integration - после unit, когда нужны внешние зависимости (БД, брокер).\n- E2E - ближе к концу, дорогие по времени, часто только для main/PR.\nQA - либо:\n- ручной gate \n- либо отдельный этап \"ручное тестирование на staging\" по чек-листу, затем approval.\n\nЕсли как автоматические тесты уровня QA - это обычно e2e + smoke + контрактные (contract - \"контрактные\") + мониторинг, но ручной \"sign-off\" всё равно часто оставляют.\n<hr>\n<b>6) Куда уходит билд после всех проверок</b>\nТиповые \"куда\":\n- Registry (реестр) Docker образов: Nexus/Harbor/GitHub Container Registry\n- Artifact repo (репозиторий артефактов): Nexus/Artifactory (jar, zip)\n- Staging окружение: Kubernetes/VM\n- Prod окружение: Kubernetes/VM\n- уведомления (Slack, email), отчёты (Allure), метрики\n\n<b>В примере Jenkinsfile:</b> билд уходит в Docker registry, потом в staging, потом в prod.\n\np.s: прикреплю видео для примерного представления по Jenkins\n\n<iframe style=\"border-radius: 15px; width: 90%; height: 50vh; max-width: 90%; max-height: 70%;\" src=\"https://www.youtube.com/embed/CtHcrmRplJI?si=2jiMs1hfr3h2AZYe\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\"></iframe>\n</div>\n</details>","path":"-"}},{"title":"Docker / Compose / Kubernetes","data":{"code":"-","description":"<span style=\"color:red\">Подробности об установке и остальных тонкостях можно найти на официальной странице Docker. Дальнейшие объяснения будут подразумевать то что Docker установлен и настроен</span>\n\nПредставьте типичную ситуацию в разработке. Код написан, тесты локально проходят, в CI всё зелёное, но при запуске приложения в другом окружении возникают ошибки. У разработчика приложение стартует, у QA - нет, а на сервере поведение отличается ещё сильнее. Начинается поиск причин: версии библиотек, различия в настройках, переменные окружения, особенности операционной системы.\n\nЧем больше проект и команда, тем сложнее поддерживать одинаковое окружение для всех участников процесса. Даже при наличии CI/CD различия между локальной средой, средой тестирования и сервером приводят к трудно воспроизводимым дефектам и ситуации \"у меня работает\".\n\nВ этот момент становится очевидно, что проблема не в коде и не в тестах, а в отсутствии единого стандарта запуска приложения. Нужно решение, которое позволит запускать приложение в одинаковых условиях независимо от того, где оно выполняется - на машине разработчика, в CI или на сервере. Именно эту задачу и решает Docker.\n\n<hr>\n<h5>Docker</h5>\n\n<img src=\"https://sun9-38.vkuserphoto.ru/s/v1/ig2/ZY5qHZWQekF3tLk9YjXCkC4GoizBW_LqVXkcT7Eo6NmP1geQHSJov_Jf1KuXH3frqTlSAaoTxYSeTMlAz5g8ayOg.jpg?quality=95&amp;as=32x28,48x42,72x63,108x94,160x139,240x209,360x313,480x417,540x469,581x505&amp;from=bu&amp;cs=581x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\n<b>Docker</b> - это инструмент контейнеризации, который позволяет упаковать приложение вместе со всеми его зависимостями и правилами запуска в изолированное окружение. Вместо попыток воспроизвести нужную конфигурацию вручную, команда получает единый артефакт, который запускается одинаково в любом месте.\n\nВажно понимать, что Docker не является виртуальной машиной. Он не создаёт отдельную операционную систему, а изолирует процесс приложения и его зависимости внутри существующей системы. Это делает запуск быстрее, проще и более предсказуемым.\n\nПосле появления Docker окружение перестаёт быть неявной частью процесса. Все правила запуска приложения фиксируются явно: какие зависимости нужны, какие переменные окружения используются, какая команда стартует приложение. Это устраняет большую часть проблем, связанных с различиями сред, и делает поведение приложения воспроизводимым.\n\nВ контексте CI/CD Docker становится связующим элементом между проверкой кода и его развёртыванием. Один и тот же контейнер может быть собран в CI, протестирован и затем использован для доставки приложения в окружения CD, что снижает риск расхождений между тестируемой и запускаемой версией.\n\n<details>\n<summary>Как это работает</summary>\n<div>\n<img src=\"https://sun9-65.vkuserphoto.ru/s/v1/ig2/D6Mcy4XppRmXcna3ugGJHfn4qHTdDlghpN3LugB-LHSWEbpCvIckEIj2ep72qB2uZ0UJu6RJHJKrQGfo_Iq91XPF.jpg?quality=95&amp;as=32x11,48x16,72x24,108x36,160x53,240x80,360x120,480x160,540x180,640x213,720x240,1080x360,1280x427,1440x480,2138x713&amp;from=bu&amp;cs=2138x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nКогда в проекте появляется Docker, процесс запуска приложения перестаёт быть неявным. Вместо набора устных договорённостей вроде \"установи вот это\", \"запусти вот так\" и \"у меня ещё вот такая версия библиотеки\" появляется формализованное описание среды запуска.\n<hr>\n<b>Dockerfile</b> - это текстовый файл с инструкциями, по которым Docker собирает образ.\n\nВ основе всего лежит Dockerfile. Это обычный текстовый файл, в котором последовательно описано, как должно выглядеть окружение приложения. Сначала указывается базовая среда - например, минимальная версия Linux или готовый образ с нужным языком программирования. Затем перечисляются зависимости, копируется код и фиксируется команда запуска. По сути, Dockerfile отвечает на вопрос: что нужно сделать, чтобы приложение гарантированно запустилось.\n\nОн описывает:\n- базовое окружение (на чём будет работать приложение)\n- зависимости\n- копирование кода\n- команду запуска приложения\n\nDockerfile не запускает приложение и не является контейнером. Он - рецепт сборки. Если Dockerfile изменился &gt; образ нужно пересобрать.\n\n<hr>\n<b>Image (образ)</b> -  это результат сборки Dockerfile.\nКогда выполняется сборка, Docker читает Dockerfile сверху вниз и на его основе создаёт image (образ). Образ - это уже не инструкция, а готовый результат: зафиксированное окружение с кодом и зависимостями. Важно, что image неизменяем. Если нужно что-то поменять, он пересобирается заново, а не правится на лету. Это делает поведение предсказуемым и воспроизводимым.\n\nХарактеристики:\n- неизменяемый\n- версионируемый\n- одинаковый для всех окружений\n\nImage содержит:\n- ОС-слой (или базовый runtime)\n- зависимости\n- код приложения\n- конфигурацию запуска\n\nImage не работает сам по себе. Он используется как основа для запуска контейнеров.\n\n<hr>\n<b>Container (контейнер)</b> - это запущенный экземпляр image.\nДальше из image запускается container (контейнер). Контейнер - это уже работающий экземпляр приложения. Он использует ресурсы хост-системы, но при этом изолирован: у него своё файловое пространство, свои переменные окружения, свои процессы.\n\nКонтейнер:\n- выполняет приложение\n- имеет собственную файловую систему и процессы\n- может быть остановлен, удалён и пересоздан\n\nКонтейнер временный. Если контейнер удалён - данные внутри него теряются (если не вынесены наружу).\n\n<hr>\n<b>Как это работает вместе (цепочка):</b> Пишется Dockerfile - описание среды и запуска &gt; Docker по Dockerfile собирает image &gt; Из image запускается container &gt; В контейнере выполняется приложение\n\n<b>QA работает с последствиями:</b>\nDockerfile &gt; источник проблем окружения\nImage &gt; что именно тестируется\nContainer &gt; как приложение реально работает\nЕсли контейнер не стартует -  это не баг логики.\nЕсли image неправильный - все контейнеры будут неправильные.\n\n<hr>\nКогда приложение запускается в контейнере, Docker не \"эмулирует\" систему, как виртуальная машина. Он просто изолирует процесс приложения, давая ему доступ только к тому, что явно разрешено. Благодаря этому контейнер стартует быстро, а окружение ведёт себя одинаково независимо от того, где оно запущено - локально, в CI или на сервере.\n\nЕсли в контейнере что-то идёт не так, Docker предоставляет чёткие точки диагностики. Можно посмотреть, стартовал ли контейнер вообще, завершился ли он с ошибкой, какие логи вывело приложение. Это резко упрощает анализ проблем, потому что исчезает неопределённость вида \"а вдруг это из-за моей машины\".\n</div>\n</details>\n\n<details>\n<summary>Пример dockerfile</summary>\n<div>\nDockerfile (для веб-приложения на Node.js):\n\n<pre><code class=\"lang-bash\">\nFROM node:20-alpine\n\nWORKDIR /app\n\nCOPY package*.json ./\nRUN npm ci --omit=dev\n\nCOPY . .\n\nENV NODE_ENV=production\nEXPOSE 3000\n\nCMD [\"node\", \"server.js\"]\n</code>\n</pre>\n\n<hr>\n<b>FROM node:20-alpine</b> - Базовый образ. Это \"стартовая ОС + runtime\".\n<b>node:20</b> - версия Node.js 20\n<b>alpine</b> - лёгкая Linux-база\n<hr>\n<b>WORKDIR /app</b> - Задаёт рабочую директорию внутри образа. Все дальнейшие пути считаются относительно неё.\n<hr>\n<b>COPY package*.json ./</b> - Копирует package.json и package-lock.json (если есть) внутрь образа.\nПочему так делают: чтобы кеш сборки работал эффективно - зависимости ставятся только если манифест изменился.\n<hr>\n<b>RUN npm ci --omit=dev</b> - Команда выполняется во время сборки image.\n<b>npm ci</b> - ставит зависимости строго по lock-файлу (в идеале)\n<b>--omit=dev</b> - не ставит devDependencies &gt; облегчает прод-образ\n<hr>\n<b>COPY . .</b> - Копирует весь проект внутрь образа.\n<hr>\n<b>ENV NODE_ENV=production</b> - Устанавливает переменную окружения.\n<hr>\n<b>EXPOSE 3000</b> - Документация порта (подсказка), не открывает порт автоматически.\n<hr>\n<b>CMD [\"node\", \"server.js\"]</b> - Команда по умолчанию при запуске контейнера.\n<hr>\n<b>Что QA должен уметь видеть в Dockerfile</b>\n<b>версия runtime (FROM …)</b> -  источник расхождений\n<b>зависимости (npm ci, pip install, mvn package)</b> - частая причина \"падает в CI\"\n<b>переменные окружения (ENV)</b> - меняют поведение приложения\n<b>команда запуска (CMD/ENTRYPOINT)</b> - почему контейнер стартует/не стартует\n<b>копирование файлов (COPY)</b> -  что реально попадает внутрь образа\n</div>\n</details>\n\n<details>\n<summary>Базовые команды Docker</summary>\n<div>\nНиже - базовый набор Docker-команд, ровно на том уровне, который нужен QA: запускать, смотреть, диагностировать, а не администрировать. Коротко, технически, по назначению.\n\n<hr>\n<b>1. Сборка образа (Dockerfile &gt; Image)</b>\n<pre><code class=\"lang-bash\">\ndocker build -t my-app:1.0 .\n\n#Проверить, что образ появился:\ndocker images\n</code>\n</pre>\n\nЧто делает:\n- читает Dockerfile в текущей директории\n- собирает image\n- -t - имя и тег образа\n\n<b>QA-смысл:</b> фиксируется конкретная версия окружения, которая потом тестируется.\n\n<hr>\n<b>2. Запуск контейнера (Image &gt; Container)</b>\n<pre><code class=\"lang-bash\">\n# Запускает контейнер в foreground (видно логи).\ndocker run my-app:1.0\n\n#Чаще используется так\ndocker run -d -p 3000:3000 --name my-app-container my-app:1.0\n</code>\n</pre>\n-d - в фоне\n-p 3000:3000 - проброс порта (порт внутри контейнера / выходящий порт)\n--name - имя контейнера\n\n<b>QA-смысл:</b> если приложение не доступно - либо порт не проброшен, либо приложение не стартовало.\n\n<hr>\n<b>3. Список контейнеров</b>\n<pre><code class=\"lang-bash\">\n# только запущенные\ndocker ps\n\n#все, включая остановленные\ndocker ps -a\n</code>\n</pre>\n\n<b>QA-смысл:</b> часто контейнер уже упал, и его просто нет среди running.\n\n<hr>\n<b>4. Логи контейнера (ключевая команда для QA)</b>\n<pre><code class=\"lang-bash\">\ndocker logs my-app-container\n\n#Последние строки\ndocker logs --tail 100 my-app-container\n\n#Следить в реальном времени\ndocker logs -f my-app-container\n</code>\n</pre>\n<b>QA-смысл:</b> если контейнер не стартует - 90% ответов тут.\n\n<hr>\n<b>5. Войти внутрь контейнера (диагностика)</b>\n<pre><code class=\"lang-bash\">\ndocker exec -it my-app-container sh\n\n#или\ndocker exec -it my-app-container bash\n</code>\n</pre>\n\nПозволяет:\n- посмотреть файлы\n- проверить переменные окружения\n- вручную запустить приложение\n\n<b>QA-смысл:</b> проверка \"а что реально внутри контейнера\".\n\n<hr>\n<b>6. Остановка и удаление контейнеров</b>\n<pre><code class=\"lang-bash\">\n#Остановить\ndocker stop my-app-container\n\n#Удалить\ndocker rm my-app-container\n</code>\n</pre>\n\n<b>QA-смысл:</b> контейнеры одноразовые. Удалить и пересоздать - нормальный сценарий.\n\n<hr>\n<b>7. Удаление образов</b>\n<pre><code class=\"lang-bash\">\ndocker rmi my-app:1.0\n</code>\n</pre>\nЕсли образ не удаляется - значит, есть контейнеры, которые его используют.\n\n<hr>\n<b>8. Очистка мусора (аккуратно)</b>\n<pre><code class=\"lang-bash\">\n#Удалить остановленные контейнеры\ndocker container prune\n\n#Удалить неиспользуемые образы\ndocker image prune\n</code>\n</pre>\n<b>QA-смысл:</b> полезно, если Docker начинает \"вести себя странно\" из-за старых артефактов.\n\n<hr>\n<b>9. Проверка переменных окружения</b>\n<pre><code class=\"lang-bash\">\n#Посмотреть env внутри контейнера\ndocker exec my-app-container env\n</code>\n</pre>\n<b>QA-смысл:</b> частая причина \"работает локально, не работает в Docker\".\n\n<hr>\n<b>10. Быстрая ментальная карта команд</b>\n<pre><code class=\"lang-bash\">\n#собрать image\ndocker build\n\n#посмотреть images\ndocker images \n\n#запустить container\ndocker run \n\n#посмотреть containers\ndocker ps\n\n#понять, почему не работает\ndocker logs \n\n#залезть внутрь\ndocker exec \n\n#перезапуск с нуля\ndocker stop/rm\n</code>\n</pre>\n</div>\n</details>\n\n<hr>\n<h5>Docker compose</h5>\n\n<img src=\"https://sun9-47.vkuserphoto.ru/s/v1/ig2/0Z2Tq_WDBrScX443iuba6XH84DEZjUeJKvFRgR6uKmXxjXl_i1B1hh_4GONusOuV03YK16dZ2Yn5iIDWnHhukdCC.jpg?quality=95&amp;as=32x15,48x22,72x33,108x49,160x73,240x109,360x163,480x218,540x245,640x290,720x327,1080x490,1280x581,1400x635&amp;from=bu&amp;cs=1400x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nНа раннем этапе работы с Docker приложение часто запускается одной командой docker run. Это удобно, пока система состоит из одного сервиса. Однако по мере роста проекта становится очевидно, что приложение почти никогда не работает в изоляции. Оно зависит от базы данных, кэша, очередей сообщений и других сервисов.\n\nПопытка запускать всё это с помощью отдельных команд docker run быстро приводит к усложнению процесса. Нужно помнить порядок запуска контейнеров, вручную создавать сети, пробрасывать порты, задавать переменные окружения и следить за тем, чтобы все контейнеры использовали одинаковые настройки. Любая ошибка или пропущенный параметр приводит к ситуации, когда система либо не стартует, либо ведёт себя не так, как в CI или на сервере.\n\nDocker Compose решает эту проблему, позволяя описать всё окружение в одном файле. Вместо набора разрозненных команд появляется декларативное описание стенда, в котором явно указано, какие сервисы используются, как они связаны между собой и с какими параметрами должны запускаться. Это делает процесс запуска предсказуемым и одинаковым для всех участников команды.\n\n<b>Docker Compose (docker-compose / docker compose)</b> - это запуск набора контейнеров по описанию в файле, плюс сеть/тома/переменные/зависимости. Для QA это обычно \"поднять стенд локально как в CI\".\n\n<details>\n<summary>Как это работает</summary>\n<div>\nВ реальных приложениях почти всегда не один контейнер, а минимум:\n- приложение (web/api)\n- база данных (PostgreSQL/MySQL)\n- кеш (Redis)\n- очереди (RabbitMQ/Kafka)\n- мок-сервисы и т.д.\n\nЕсли делать это через docker run, ты быстро утонешь в:\n- куче команд\n- создании сети\n- правильном порядке запуска\n- переменных окружения\n- пробросах портов\n- томах (volume) для данных\n\n<b>Compose решает это так:</b> один файл описывает \"стенд\", и одной командой ты его поднимаешь.\n\n<hr>\n<b>docker-compose.yml</b>\nDocker Compose ничего не \"угадывает\". Он читает один файл - docker-compose.yml.\nВ этом файле явно описано:\n- какие контейнеры нужны (services)\n- из каких image или Dockerfile\n- какие переменные окружения\n- какие порты, тома, сети\n- зависимости между сервисами\n\nМинимальный пример docker-compose.yml\n<pre><code class=\"lang-bash\">\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DB_HOST=db\n    depends_on:\n      - db\n\n  db:\n    image: postgres:16\n    environment:\n      - POSTGRES_PASSWORD=pass\n    ports:\n      - \"5432:5432\"\n</code>\n</pre>\n\n<hr>\n<b>1. Сервисы</b>\nВесь файл - это YAML. Ключ верхнего уровня services: - секция, где перечислены сервисы (будущие контейнеры).\n<pre><code class=\"lang-bash\">\nservices:\n  api:   # &lt; имя сервиса\n  db:    # &lt; имя сервиса\n</code>\n</pre>\n<b>api и db</b> - это имена сервисов.\nCompose по ним:\n- создаёт контейнеры\n- даёт им DNS-имя в сети (контейнеры смогут обращаться к db по имени)\n- группирует команды (docker compose logs api, docker compose exec api sh)\n\n<hr>\n<b>2. Настройки сервиса</b>\n<b>Настройки сервиса:</b> это всё, что находится внутри блока этого сервиса (с отступом).\nСервис api:\n<pre><code class=\"lang-bash\">\napi:\n  build: .\n  ports:\n    - \"3000:3000\"\n  environment:\n    - DB_HOST=db\n  depends_on:\n    - db\n</code>\n</pre>\n\n<b>build: .</b> - Compose соберёт image из Dockerfile в текущей директории (где лежит compose-файл).\nТехнически: это аналог docker build перед запуском контейнера.\n\n<b>ports: - \"3000:3000\"</b> - Проброс порта: хост:контейнер.\n\n<b>environment: - DB_HOST=db</b> - Передаёт переменную окружения внутрь контейнера api.\nЗначение db - это имя сервиса БД в compose-сети.\nТо есть приложение внутри контейнера api должно подключаться к БД по хосту db.\n\n<b>depends_on: - db</b> Compose запустит контейнер db раньше, чем контейнер api (Он не ждёт, пока PostgreSQL внутри контейнера реально станет готов принимать соединения.)\n\nТо есть:\nна твоём ПК порт 3000 &gt; внутрь контейнера api на порт 3000\nнужно, чтобы открыть API в браузере/Postman с хоста\n<hr>\n<b>3. Как контейнеры видят друг друга</b>\nCompose автоматически создаёт bridge-сеть.\n\n<hr>\n<b>Что тут важно понимать QA:</b>\n- services -  набор контейнеров\n- api собирается из Dockerfile (build: .)\n- db берётся готовым образом (image: postgres:16)\n- depends_on -порядок старта (но не \"готовность\" приложения)\n- у сервисов автоматически общая сеть, и они видят друг друга по имени (db)\n\n</div>\n</details>\n\n<hr>\n<h5>Пример Docker/Compose</h5>\n\n<b>Предисловие:</b> сначала один сервис через docker run, потом тот же кейс перерастает в docker compose. Параллельно - кто что делает: Разработчик, QA, DevOps.\n\n<b>Возьмем простой сервис api:</b> который слушает порт 3000 и ходит в БД. Сначала БД \"встроенная\" или не нужна, потом появляется PostgreSQL.\n\n\n<details>\n<summary>Этап 1 - один сервис, docker run</summary>\n<div>\n<b>1. Разработчик \"упаковывает\" приложение</b>\nОн добавляет Dockerfile в репозиторий (примерно так):\n\n<pre><code class=\"lang-bash\">\nFROM node:20-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nEXPOSE 3000\nCMD [\"node\", \"server.js\"]\n</code>\n</pre>\n\nКлючевая мысль: Разработчик фиксирует \"как собирать и как запускать\" приложение.\n\n<hr>\n<b>2. QA поднимает сервис локально через docker run</b>\nQA получает ветку/коммит и делает:\n\n<pre><code class=\"lang-bash\">\n#Собрать image:\ndocker build -t api:local .\n\n#Запустить container:\ndocker run --rm -p 3000:3000 --name api api:local\n\n#Проверить, что сервис жив:\ncurl -f http://localhost:3000/health\n</code>\n</pre>\n\n<b>Что делает QA в этот момент:</b>\n- подтверждает, что сервис стартует в стандартизированном окружении\n- если не стартует, смотрит docker logs api (или просто вывод в консоли, если без -d)\n- отделяет \"проблема кода\" от \"проблема окружения\"\n\n<hr>\n<b>3. DevOps здесь почти не участвует</b>\nНа этом этапе DevOps может только:\n- дать стандартный шаблон Dockerfile\n- подсказать по переменным окружения и логированию\n- Но реально процесс держится на Разработчике + QA.\n\n</div>\n</details>\n\n<details>\n<summary>Этап 2 - появляется зависимость, docker run начинает \"болеть\"</summary>\n<div>\nЧерез время api начинает зависеть от PostgreSQL. Теперь одной командой docker run уже не обойтись, потому что нужно поднять еще и БД, сеть, переменные.\n\nКак это выглядит через \"голый\" docker run\nDevOps или QA вынуждены делать примерно так:\n<pre><code class=\"lang-bash\">\ndocker network create appnet\n\ndocker run -d --name db --network appnet \\\n  -e POSTGRES_PASSWORD=pass \\\n  -p 5432:5432 postgres:16\n\ndocker run -d --name api --network appnet \\\n  -e DB_HOST=db -e DB_PORT=5432 \\\n  -p 3000:3000 api:local\n</code>\n</pre>\n\nГде тут боль:\n- порядок запуска нужно помнить\n- сеть нужно создавать руками\n- env легко забыть\n- конфигурацию сложно воспроизвести у другого человека\n- depends_on/ожидание готовности БД нужно решать отдельно\n- И вот здесь естественно появляется Docker Compose.\n</div>\n</details>\n\n<details>\n<summary>Этап 3 - тот же стенд через docker compose</summary>\n<div>\n<b>1) DevOps (или Разработчик) добавляет docker-compose.yml</b>\n<pre><code class=\"lang-bash\">\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - DB_HOST=db\n      - DB_PORT=5432\n      - DB_USER=postgres\n      - DB_PASSWORD=pass\n    depends_on:\n      - db\n\n  db:\n    image: postgres:16\n    environment:\n      - POSTGRES_PASSWORD=pass\n    ports:\n      - \"5432:5432\"\n</code>\n</pre>\n\nЧто делает Compose:\n- сам создаст сеть\n- сам поднимет db раньше api (но не будет ждать готовности Postgres, если не настроить healthcheck)\n- подставит env и порты одинаково у всех\n\n<hr>\n<b>2) QA поднимает весь стенд одной командой</b>\n<pre><code class=\"lang-bash\">\ndocker compose up -d --build\n\n#Дальше QA проверяет:\ndocker compose ps\ndocker compose logs -f api\ncurl -f http://localhost:3000/health\n</code>\n</pre>\n\n<b>Что делает QA:</b>\n- быстро поднимает \"как у всех\"\n- воспроизводит баги в одинаковом окружении\n- если api упал на старте, QA сразу понимает типовую причину: \"db контейнер запущен, но Postgres еще не готов\" (это не обязательно баг логики)\n\n<hr>\n<b>3) DevOps берет на себя \"правильность стенда\"</b>\n<b>На этом этапе DevOps обычно отвечает за:</b>\n- структуру docker-compose.yml (сети, тома, переменные)\n- секреты (пароли не в явном виде, а через .env/secrets)\n- healthchecks (чтобы api запускался после готовности db)\n- одинаковую конфигурацию окружений (local/staging)\n\n<b>Разработчик отвечает за:</b>\n- чтобы приложение умело читать env (DB_HOST, DB_PORT и т.д.)\n- чтобы старт был устойчивым (retry при коннекте к БД, миграции, нормальные логи)\n\n<b>QA отвечает за:</b>\n- диагностику падений (код/конфиг/готовность сервисов)\n- качество проверок на поднятом стенде (smoke, API, базовые сценарии)\n- репортинг: \"что упало, где, при каких env, какие логи\"\n</div>\n</details>\n\n<hr>\n<h5>Kubernetes</h5>\n\n<img src=\"https://sun9-26.vkuserphoto.ru/s/v1/ig2/c8ZtKJVFsZSCAjs_VOfMg9X1LDrc5dpr1HK-uFXsaVUuHNht85zILKzjuVTBVT8avacmDqyZ2NGgPf69WfzZ7CDl.jpg?quality=95&amp;as=32x24,48x36,72x54,108x81,160x120,240x180,360x271,480x361,540x406,600x451&amp;from=bu&amp;cs=600x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nКогда приложение разворачивается с помощью Docker или Docker Compose, оно хорошо работает, пока вся система живёт на одном сервере. Контейнеры запускаются, сервисы общаются друг с другом, тесты проходят. Однако по мере роста системы начинают проявляться ограничения такого подхода.\n\nЕсли контейнер падает, его нужно поднимать вручную. Если сервер выходит из строя, приложение становится недоступным целиком. При обновлении версии возникает простой или риск выкладки в неправильном порядке. Масштабирование требует ручного запуска новых контейнеров и ручной балансировки нагрузки. В результате стабильность и управляемость системы начинают зависеть от действий людей, а не от процесса.\n\nВ этот момент становится ясно, что проблема не в контейнерах как таковых, а в отсутствии механизма управления ими на уровне системы. Нужен инструмент, который сможет автоматически поддерживать нужное количество экземпляров приложения, перезапускать их при сбоях, распределять нагрузку и обеспечивать обновление без простоя. Именно здесь возникает необходимость в оркестрации контейнеров.\n\n<b>Kubernetes</b> - это система оркестрации контейнеров, предназначенная для управления запуском, масштабированием и жизненным циклом контейнерных приложений в распределённой среде. Он берёт на себя ответственность за то, чтобы приложение находилось в заданном состоянии независимо от сбоев отдельных контейнеров или серверов.\n\nВместо того чтобы запускать контейнеры вручную, команда описывает желаемое состояние системы: сколько экземпляров приложения должно работать, какую версию образа использовать и как сервисы должны быть доступны друг другу. Kubernetes сам следит за тем, чтобы реальное состояние соответствовало этому описанию, автоматически устраняя отклонения.\n\n<details>\n<summary>Как работает</summary>\n<div>\n<img src=\"https://sun9-79.vkuserphoto.ru/s/v1/ig2/6S0eQbQfw0TFHmtKBLGPhywqe2DSM_pk86Yp5mRBWtv8uPJD94qgI7usO91-xNM3VhDCOuQJDF2Ru4H-V8bpSG9J.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x60,240x90,360x134,480x179,540x202,640x239,720x269,1080x403,1280x478,1440x538,1617x604&amp;from=bu&amp;cs=1617x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\n\nВ Kubernetes есть конфигурационные YAML-файлы, в которых описано, какие Docker image нужно запускать и в каком количестве. Kubernetes сам запускает контейнеры из этих image, следит за их состоянием и автоматически пересоздаёт контейнеры при падении. При обновлении версии image Kubernetes, после применения нового конфигурационного файла, перезапускает контейнеры на новой версии. Связь между сервисами осуществляется через сеть и сервисы Kubernetes, а не напрямую между контейнерами.\n\n<hr>\n<b>1. Что из себя представляет конфигурационный файл Kubernetes</b>\n\n<pre><code class=\"lang-bash\">\n#Пример конфигурационного файла Kubernetes\n#Это Deployment - основной объект, который говорит Kubernetes, что и как запускать.\n\napiVersion: apps/v1\nkind: Deployment\n\nmetadata:\n  name: api\n\nspec:\n  replicas: 2\n\n  selector:\n    matchLabels:\n      app: api\n\n  template:\n    metadata:\n      labels:\n        app: api\n\n    spec:\n      containers:\n        - name: api\n          image: my-registry/api:1.0.0\n          ports:\n            - containerPort: 3000\n          env:\n            - name: DB_HOST\n              value: db\n</code>\n</pre>\n\n<b>apiVersion: apps/v1</b>- версия Kubernetes API для этого объекта\n<b>kind: Deployment</b> -  объект, который управляет запуском приложения\n<b>metadata &gt; name: api</b> - имя объекта. Имя для Deployment, используется Kubernetes для идентификации. \n<b>spec</b> - главное тело описания. Это что именно должно быть запущено. Всё важное находится внутри него.\n<b>replicas: 2</b>- сколько экземпляров приложения нужно. Должен поддерживать 2 копии приложения. Если одна упала - создаётся новая.\n<b>selector: &gt;  matchLabels: &gt; app: api</b> - как Deployment понимает, какими pod он управляет. \"Я управляю всеми pod, у которых есть label app: api\".\n<b>template</b> - шаблон pod. Как должен выглядеть каждый pod. Kubernetes будет копировать этот шаблон.\n<b>labels &gt; app: api</b> - идентификаторы. labels - это метки по ним сервисы и Deployment находят pod. \n<b>spec pod</b> - что внутри pod. Это уже внутренности pod.\n<b>containers</b> - какие контейнеры запускать. список контейнеров внутри pod. \n<b>image</b> - готовый Docker image.\n<b>ports</b> - какие порты слушает контейнер. \n<b>env</b> - переменные окружения. передаёт env внутрь контейнера db - имя сервиса БД в Kubernetes.\n\n<hr>\n<b>2. Где вообще находится Kubernetes и что это такое физически</b>\nKubernetes - это отдельная система, которая работает на серверах.\nФизически:\n- это не библиотека\n- не Docker-плагин\n- не часть CI\n\nKubernetes состоит из:\n- управляющих компонентов (control plane)\n- рабочих серверов (nodes)\n\nОн всегда работает как сервис, обычно:\n- в облаке\n- на выделенных серверах\n- в managed-кластере (GKE, EKS, AKS и т.д.)\n\n<hr>\n<b>3. Как Kubernetes получает новые версии приложения</b>\nKubernetes НЕ собирает приложение. Он:\n- не запускает сборку\n- не запускает тесты\n- не ходит в Git\n- Новые версии попадают в Kubernetes через CI/CD.\n\n<b>Последовательность такая:</b> Разработчик делает commit &gt; CI (например Jenkins) собирает Docker image &gt; Image публикуется в registry (Docker Registry) &gt; CI/CD обновляет конфигурацию Kubernetes  (либо меняется tag image / либо меняется digest) &gt; Kubernetes видит, что описание изменилось &gt; Kubernetes начинает обновление контейнеров\n\n<hr>\n<b>4. Где здесь docker-compose и docker run</b>\nDocker Compose используется ДО Kubernetes, а не внутри него.\nDocker Compose:\n- удобен для локального стенда\n- удобен для QA и разработчиков\n- работает на одном хосте\n\nKubernetes:\n- не запускает docker-compose\n- не читает compose-файлы\n- не \"поднимает compose\"\nCompose и Kubernetes не связаны напрямую.\n\n</div>\n</details>\n\n<hr>\n<h5>Пример Kubernetes</h5>\n\n<b>Предисловие:</b> продолжение того же примера из Docker/Compose\n\n<details>\n<summary>Этап 1 - Один сервис - docker run</summary>\n<div>\n<b>Ситуация:</b> Есть простое API. Работает без БД или с локальной БД. Нужно просто запустить и проверить.\n<hr>\n<b>Что делает разработчик: </b> Пишет код + Dockerfile.\n<hr>\n<b>Что делает QA:</b> Запускает контейнер вручную.\n<pre><code class=\"lang-bash\">\ndocker build -t api:local .\ndocker run -p 3000:3000 api:local\n</code>\n</pre>\n<hr>\n<b>Что происходит:</b>\n- контейнер запустился\n- если упал - всё, сервис недоступен\n- если сервер умер - всё умерло\n- Контроль полностью на человеке.\n</div>\n</details>\n\n<details>\n<summary>Этап 2 -  Несколько сервисов - docker compose</summary>\n<div>\n<b>Ситуация:</b> Появилась БД. Один контейнер уже не вариант.\n<hr>\n<b>Что делает разработчик:</b> Гарантирует, что приложение читает конфиг из env DB_HOST / DB_PORT.\n<hr>\n<b>Что делает QA:</b> \nПоднимает стенд одной командой.\n<pre><code class=\"lang-bash\">\ndocker compose up\n</code>\n</pre>\n<hr>\n<b>Что делает docker compose:</b>\n- читает docker-compose.yml\n- запускает api\n- запускает db\n- создает сеть\n- дает сервисам имена\n<hr>\n<b>Что происходит:</b>\n- сервисы видят друг друга по имени\n- стенд повторяем\n\nНО:\n- если контейнер упал - он может остаться упавшим\n- если сервер умер - всё умерло\n- масштабирования нет\n- Compose = удобство, но не устойчивость.\n</div>\n</details>\n\n<details>\n<summary>Этап 3 - Тот же стенд, но в Kubernetes</summary>\n<div>\n<b>Ситуация:</b> Сервис нужен без простоя, с автоперезапуском, с несколькими копиями на нескольких серверах\n<hr>\n<b>Что делает разработчик:</b> Ничего нового, код тот же, Dockerfile тот же. приложение читает env\n<hr>\n<b>Что делает CI/CD:</b> git commit &gt; docker build api:1.0.0 &gt;docker push registry/api:1.0.0\n<hr>\n<b>Результат:</b> готовый Docker image лежит в registry\n<hr>\n<b>Что делает DevOps:</b> DevOps НЕ пишет docker-compose. Он пишет Kubernetes YAML: \"Запусти вот этот image вот так\"\n\n<pre><code class=\"lang-bash\">\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: api\nspec:\n  replicas: 2\n  template:\n    spec:\n      containers:\n        - name: api\n          image: registry/api:1.0.0\n          env:\n            - name: DB_HOST\n              value: db\n\n#Kubernetes создаст 2 контейнера api из image 1.0.0 \n#Kubernetes передаст в контейнер переменную окружения DB_HOST со значением \"db\" (он же в свою очередь может быть прямым ip например 127.0.0.1)\n#Если в том же namespace есть Service с именем db, тогда все контейнеры, где DB_HOST=db, будут пытаться ходить в один и тот же Service db (а Service уже раздаст трафик на pod базы).\n</code>\n</pre>\n<hr>\n<b>Что делает Kubernetes:</b>\nПосле применения YAML:\n- запускает 2 контейнера api\n- следит, чтобы их всегда было 2\n- если один упал - поднимает новый\n- если сервер умер - запускает на другом\n- не спрашивает человека\n<hr>\n<b>Появилась новая версия</b>\n<b>CI собрал:</b> registry/api:1.0.1\n<b>Меняется YAML:</b> image: registry/api:1.0.1\n\n<b>Kubernetes:</b>\n- видит изменение\n- запускает новые контейнеры\n- останавливает старые\n- сервис не падает\n<hr>\n<b>QA должен понимать:</b>\n- контейнеры в Kubernetes одноразовые\n- версия приложения = tag image\n- падение контейнера != падение сервиса\n- Kubernetes не запускает compose\n- Kubernetes сам чинит падения\n</div>\n</details>","path":"-"}},{"title":"Jira","data":{"code":"-","description":"Пока людей мало, задачи держатся \"в голове\", баги обсуждаются в чатах, а сроки фиксируются устно. Но как только продукт растёт, возникает управленческий хаос: дефекты теряются, непонятно кто за что отвечает, нет прозрачности по статусам, сложно отследить, что именно попало в релиз. Появляется потребность в единой системе, где фиксируется вся работа команды и её состояние.\r\n\r\nСначала эту роль пытались закрывать таблицами, почтой и простыми баг-трекерами. Но при переходе к итерационной разработке (Agile, Scrum, Kanban) стало ясно, что нужен не просто журнал дефектов, а инструмент управления всем жизненным циклом разработки: требованиями, задачами, разработкой, тестированием и релизами. То есть система, которая связывает людей, процессы и артефакты разработки в одной точке.\r\n\r\n<hr>\r\n<h5>Jira</h5>\r\n\r\n<img src=\"https://sun9-56.vkuserphoto.ru/s/v1/ig2/I5pDDHfTk-ExVFTKrzditZDxk-h5p1ZdI-LliQi0FSv5DjedbKVURZptfzZu9wYwH7LxIBbd2iWkiQBAlQTi79ao.jpg?quality=95&amp;as=32x20,48x30,72x45,108x68,160x100,240x150,360x226,480x301,540x338,640x401,720x451,932x584&amp;from=bu&amp;cs=932x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nJira - это система управления задачами и процессом разработки программного обеспечения. По сути, это issue tracking system (система отслеживания задач и дефектов) + project management tool (инструмент управления проектом). Её базовая сущность - issue (единица работы команды). Issue может быть дефектом, задачей разработки, пользовательской историей, улучшением или крупной функциональностью.\r\n\r\nВся работа в Jira строится вокруг жизненного цикла задачи: она создаётся, берётся в работу, проходит разработку, тестирование и закрывается. Для этого используются статусы и переходы между ними, которые отражают реальный процесс внутри команды. Таким образом Jira фиксирует не только саму задачу, но и состояние разработки в каждый момент времени.\r\n\r\n<b>Для QA:</b> Jira - это не просто место, куда \"складывают баги\". Это рабочий инструмент коммуникации с разработкой и менеджментом. Через него регистрируются дефекты, отслеживается их приоритет, контролируется исправление, проверяются фиксы и фиксируется итоговое качество релиза. Без подобной системы тестирование быстро превращается в несвязанный набор проверок без истории, метрик и управляемости.\r\n\r\n<details>\r\n<summary>Как это работает</summary>\r\n<div>\r\n<h5>Agile-разработка с Jira</h5>\r\n<b>Agile</b> - это гибкая система разработки, в которой сложные задачи разбиваются на итерации -  небольшие этапы. После каждого из них команда постепенно выдает готовые части продукта, их тестируют и оценивают. Одну итерацию называют спринтом (англ. sprint - бег на короткую дистанцию). В конце спринта команда подводит итоги и ставит себе задачи на следующий.\r\n\r\n<b>Главные принципы Agile:</b>\r\n- Люди и их взаимодействие важнее процессов и инструментов.\r\n- Работающий продукт важнее исчерпывающей документации.\r\n- Сотрудничество с заказчиком важнее согласования условий контракта.\r\n- Готовность к изменениям важнее следования первоначальному плану.\r\n\r\nЕсть два подхода к работе над проектом, основанные на Agile:\r\n\r\n<b>1. Методика Kanban</b> - это способ визуализации задач с помощью досок, на которых задачи располагаются в соответствии со статусом. Стандартная канбан-доска делится на три колонки:\r\n<b>- to do</b> - список задач;\r\n<b>- in progress</b> -  задачи, которые взяли в работу и выполняют;\r\n<b>- done</b> - завершенные задачи.\r\n\r\nК этим колонкам можно добавлять другие. Например, между задачами в работе и завершенными поставить колонку с этапом тестирования. Такие доски используют для разных процессов - в команде маркетинга или при любой проектной работе.\r\n\r\n<img src=\"https://sun9-1.vkuserphoto.ru/s/v1/ig2/wst_rLMyp9ex8J3sNT2ZL9ZByxyWbkVRRo6IxEF6d2h9g27gvg9Ffc4jGy4k-LMLpX7xqcUb_9zpxn6JxkxpjBXs.jpg?quality=95&amp;as=32x19,48x29,72x43,108x64,160x95,240x143,360x215,480x286,540x322,640x382,720x429,1080x644,1280x763,1440x859,1999x1192&amp;from=bu&amp;cs=1999x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>2. Методика Scrum</b> - в ней собраны все принципы гибкой разработки: деление на спринты, взаимодействие в команде и с заказчиком, нацеленность на рабочий продукт. Для визуализации рабочего процесса в Scrum тоже используют доски, на которых отслеживается процесс разработки. Отличие от канбан-досок в том, что самую важную роль играют спринты и задача не может находиться в работе дольше, чем длится спринт. Доски бывают физическими - тогда команда перемещает задачи, переклеивая стикеры. Такую методику скрам-мастера рекомендуют для небольших команд, у которых все разработчики в одном офисе. В Jira виртуальные скрам-доски выглядят так:\r\n\r\n<img src=\"https://sun9-46.vkuserphoto.ru/s/v1/ig2/TDHt41crNPj4DgtkL12ebfo0yCvQWO-Q6yd_inIGha-gVftyh5o4tb7DrRoVrTHoYUPFHIqgsTkYx_cqQzBqHIv7.jpg?quality=95&amp;as=32x18,48x27,72x40,108x60,160x89,240x134,360x200,480x267,540x301,640x356,720x401,1080x601,1280x713,1440x802,1616x900&amp;from=bu&amp;cs=1616x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<hr>\r\n<h5>Интерфейс</h5>\r\nВнешне Jira похожа на любой другой таск-менеджер.\r\n\r\n<b>Верхняя строка меню</b>: имеет шесть вкладок\r\n<img src=\"https://sun9-85.vkuserphoto.ru/s/v1/ig2/IxeG-AeA-UOHihaOZUqgTgyO8dgGQeD0zG7820BfbnoBIDkAqGz86MYz_fV6RW8tj9Omj1YIt2mPqHej5Hv8-acK.jpg?quality=95&amp;as=32x2,48x3,72x4,108x7,160x10,240x15,360x22,480x30,540x34,640x40,720x45,934x58&amp;from=bu&amp;cs=934x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>- Ваша работа (Your Work)</b> - тут отображаются проекты конкретного члена команды, в которых он исполнитель.\r\n<b>- Проекты (Projects)</b> - вкладка с доступными досками команды, активными спринтами и отчетами о работе.\r\n<b>- Фильтры (Filters)</b> - таблица сортировки проектов по авторам, проектам, статусам и другим показателям.\r\n<b>- Дашборды (Dashboards)</b> - аналитические сводки по проектам.\r\n<b>- Люди (People)</b> - список профилей членов команды.\r\n<b>- Приложения (Apps)</b> - сторонние сервисы, которые интегрированы в Jira и расширяют ее функционал.\r\n\r\n\r\n<hr>\r\n<b>Рабочая область:</b> отображаются доски с колонками и задачи, которые в зависимости от статуса перемещаются между этими колонками. \r\n<img src=\"https://sun9-1.vkuserphoto.ru/s/v1/ig2/SO7GGJHfboGTbEe1FpZ7EDj3xCCi782qwqja08IGTjucWyKwF13qGsAi9NZKO9o_ubnYD9_OLkYVhOD5Zhwj5zqL.jpg?quality=95&amp;as=32x19,48x29,72x43,108x64,160x96,240x143,360x215,480x287,540x322,640x382,720x430,1080x645,1280x764,1440x860&amp;from=bu&amp;cs=1440x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nЕсть несколько типов задач:\r\n<b>- эпик (epic)</b> -  большая задача, которую нужно разделить на спринты;\r\n<b>- история (story)</b> - часть эпика, которую команда может решить за спринт;\r\n<b>- задача (task)</b> - часть работы, которую выполняет один или несколько членов - команды;\r\n<b>- подзадача (sub-task)</b> - часть задачи;\r\n<b>- баг (bug)</b> - особая задача по исправлению ошибок в продукте.\r\n\r\n<img src=\"https://sun9-52.vkuserphoto.ru/s/v1/ig2/YMD0uQ7-1lYpeTin3zXTnxvbGhu_k7caiZd7HzgJdwFpPCACLNxdSn9DdxNJzebWIfdDZ55oqmWCTpRvmu30wKaR.jpg?quality=95&amp;as=32x12,48x18,72x27,108x40,160x60,240x89,360x134,480x179,540x201,640x239,720x268,1080x403,1280x477,1440x537,1920x716&amp;from=bu&amp;cs=1920x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<hr>\r\n<b>Боковое меню:</b> состоит из элементов управления проектами\r\n<img src=\"https://sun9-29.vkuserphoto.ru/s/v1/ig2/vQ3BLsucQgrqMcQ3CTZknakA4XpiDSYAKD11l8RVCFdwvTlRqnS4xUHUglJ73ZotKY38uGbqGwC5t9ba2LYG9htx.jpg?quality=95&amp;as=32x84,48x127,72x190,108x285,160x422,240x633,327x863&amp;from=bu&amp;cs=327x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>- Доска (Board)</b> - это вкладка, в которой хранятся доски проектов, доступных команде. Между ними переключаются с помощью кнопки \"Вниз\".\r\n<img src=\"https://sun9-38.vkuserphoto.ru/s/v1/ig2/Hu8n-LKe1FS2kYGEjWQjVBS5Qt2-rJlethVXr1LXC1e3iho3dWAm0I70ba-pavy58xxTYgcRRrcjdmg7pxS5dvtb.jpg?quality=95&amp;as=32x10,48x14,72x21,108x32,160x48,240x72,302x90&amp;from=bu&amp;cs=302x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>- Дорожная карта (Roadmap)</b> - трекер, с помощью которого выстраивается картина работы над проектом; в нем на линии времени отображаются этапы разработки до финального релиза.\r\n<img src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/c6qwxCKYEqyvHKX8JvWbQkkwcWdcPKSnyS_vafxRrgInF6cKaj8ka6OzDMIiuQnF8-cWfmuAIhj261MD2YABBwKy.jpg?quality=95&amp;as=32x17,48x25,72x38,108x57,160x85,240x128,360x191,480x255,540x287,640x340,720x383,1080x574,1280x680,1440x765,1656x880&amp;from=bu&amp;cs=1656x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>- Бэклог (Backlog)</b> - список рабочих задач, расставленных по приоритетам на основе дорожной карты: важные задачи - в начале списка, а менее приоритетные - в конце. Каждая задача в бэклоге - отдельный спринт.\r\n<img src=\"https://sun9-21.vkuserphoto.ru/s/v1/ig2/fQLzuvr53hLhxBO88cpDgsYz3o82KuUkKSGyzyjCHPu2Mp_1NU3Raecn_r-U2pmySi1ObieGOmQ76naemNBUoPZ6.jpg?quality=95&amp;as=32x16,48x23,72x35,108x53,160x78,240x117,360x175,480x234,540x263,640x311,720x350,1080x526,1200x584&amp;from=bu&amp;cs=1200x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>- Активные спринты (Active sprints)</b> - список спринтов (задач из бэклога), которые находятся у команды в работе.\r\n<img src=\"https://sun9-48.vkuserphoto.ru/s/v1/ig2/BIxP1sUT5XD6uVX3vQHobXGNWE3sV2e24o69yMzFBOp4zgOztSyTEV34pMePQ5meyUIlti5AUxtSecL2-xpJMrhj.jpg?quality=95&amp;as=32x13,48x20,72x30,108x45,160x67,240x100,360x150,480x200,540x225,640x266,720x300,1080x450,1280x533,1440x600,2068x861&amp;from=bu&amp;cs=2068x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>Отчеты (Reports)</b> - в этой вкладке более 20 параметров: соотношение нагрузки на команду в спринтах, ее эффективность, длительность спринтов, прогресс проекта и прочее.\r\n<img src=\"https://sun9-68.vkuserphoto.ru/s/v1/ig2/CXAhzWHXyWZ6z-mO0oZAE53r-lO_UFMNMJQC4PooDb86gtlPokNAxzC6VCG7or4zcxLGBoMmVptgydxoz8IzRyEM.jpg?quality=95&amp;as=32x21,48x31,72x47,108x70,160x104,240x156,360x234,480x312,540x352,640x417,720x469,1080x703,1212x789&amp;from=bu&amp;cs=1212x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<hr>\r\n<b>Нижняя часть бокового меню:</b> расположены компоненты проекта\r\n<img src=\"https://sun9-23.vkuserphoto.ru/s/v1/ig2/Dfv4SyLdvTzXhvTz2HFIbxOe2CywsOjtoWCO5zcUtSyzTEn14GKKmpjexruqrrrI2pUd73xRHbNQeBil3oFGK2oE.jpg?quality=95&amp;as=32x45,48x67,72x101,108x151,160x223,240x335,360x503,388x542&amp;from=bu&amp;cs=388x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<b>- Задачи</b> -  вкладка с фильтрами задач по статусам, исполнителям и прочим параметрам.\r\n<b>- Компоненты</b> -  среднее по величине звено между проектом и задачей: проект можно разбить на компоненты, а компоненты - на несколько задач.\r\n<b>- Код</b> - вкладка быстрого доступа к сервисам для хранения исходного кода проекта (GitHub, GitLab, Bitbucket).\r\n<b>- Релизы</b> - они же версии проекта; могут быть трех статусов \"Выпущен\", \"Не издан\" и \"В архиве\". Хранение версий помогает при возникновении проблем с продуктом, когда нужно узнать, как велась работа в предыдущих итерациях.\r\n</div>\r\n</details>\r\n\r\n<hr>\r\n<h5>Пример</h5>\r\nНиже - пример проекта в Jira пошагово. Описывается проект по Scrum (Скрам) как основной сценарий, и в конце - как это выглядит в Kanban (Канбан), потому что у него другая логика (там нет спринтов). В Jira базовая сущность везде одна - issue (\"рабочий элемент\"/\"тикет\").\r\n\r\n<details>\r\n<summary>1. Создание проекта</summary>\r\n<div>\r\nДанный шаг выполняет не QA. Его настраивают соответствующие коллеги в команде. Но для практики можно попробовать и QA. \r\n\r\n1. Переходим в \"Разделы\" нажимаем \"Создать раздел\"\r\n<img src=\"https://sun9-8.vkuserphoto.ru/s/v1/ig2/p_yZwckp7eQgUr4Kmqp51_eC7wr2rp0lyi3vuHz4IQ8_IGA4Gwn_nNA1AYWaTeb6tzQ37JEcaNuGttFIZzA4Wc1v.jpg?quality=95&amp;as=32x13,48x19,72x29,108x43,160x64,240x97,360x145,480x193,540x217,640x258,720x290,1080x435,1280x515,1440x580,2146x864&amp;from=bu&amp;cs=2146x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n1.1 В боковом меню выбираем продукт Jira. Далее Выбираем шаблон Scrum (если команда работает спринтами) или Kanban (если поток задач непрерывный) &gt; Использовать шаблон. \r\n<img src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/9lF6RkMOumJiDOrt4DJ8dlMuYLUL3CdMvpjJh8Pz_RYge3nVNJhT_N1GxcOsvqAAvwKpRXAojNvGD6RJ8UcMZirq.jpg?quality=95&amp;as=32x19,48x29,72x43,108x65,160x96,240x145,360x217,480x289,540x326,640x386,720x434,1080x651,1280x772,1440x868,2073x1250&amp;from=bu&amp;cs=2073x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n(Atlassian прямо разделяет эти режимы: Scrum - со спринтами, Kanban - без них.)\r\n\r\n1.2 Далее там же выбираем \"Управление командой\"\r\n<img src=\"https://sun9-78.vkuserphoto.ru/s/v1/ig2/qS2RMCdIysnAjeKz-7VGxZ9sM470RHi4tg8Lx5btOpVDB5iYQefVVVrh2dzrEg1cI80rNKZhfFzbr4CQJ5y67QXV.jpg?quality=95&amp;as=32x39,48x59,72x88,108x132,160x196,240x294,360x442,480x589,540x662,640x785,720x883,1005x1233&amp;from=bu&amp;cs=1005x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n<hr>\r\n2. Даём имя проекту и key (ключ проекта, типа \"WEB\").\r\n<img src=\"https://sun9-60.vkuserphoto.ru/s/v1/ig2/FssrQWFRDmsaWW5snKiHJ29XQwY-uTmNPrxn7yO1h77UIb7CavMr9TASbuxTA_gGrrtGaUQox7Hoz15773MuaAPU.jpg?quality=95&amp;as=32x17,48x25,72x38,108x57,160x85,240x127,360x191,480x254,540x286,640x339,720x381,1080x572,1280x678,1440x763,1886x999&amp;from=bu&amp;cs=1886x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n<hr>\r\n3. Jira создаёт: backlog (\"бэклог\"), доску (board), базовый workflow (\"процесс статусов\").\r\n<img src=\"https://sun9-40.vkuserphoto.ru/s/v1/ig2/YPtQfXr-xGF7gA95CLu4zDMKyu4D92qz6EmAEkQ9uXi0TXYXoZZ9RDPFjMCmnYqeub-xW0AzDtt0J8HP2LHsRmN9.jpg?quality=95&amp;as=32x16,48x24,72x36,108x54,160x79,240x119,360x179,480x238,540x268,640x318,720x357,1080x536,1280x635,1440x715,1994x990&amp;from=bu&amp;cs=1994x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>2. Создание epic</summary>\r\n<div>\r\nЭпик - это \"крупный кусок работы\", который обычно делится на истории/задачи и может растянуться на несколько спринтов.\r\nДопустим создаем эпик по теме \"Авторизация\".\r\n(Опять же это делает не QA).\r\n\r\n2.1 Нажимаем на кнопку \"Создать\" верхней панели\r\n<img src=\"https://sun9-85.vkuserphoto.ru/s/v1/ig2/xzFOdP7V195ug-ahmyfFaTJd0rcUTgSCoA1nwhnPMJVsJoYKa1BL3fXCmg16UhWXSVT6JNhAapqx1ASwMGz-k0gR.jpg?quality=95&amp;as=32x10,48x15,72x22,108x33,160x49,240x74,360x110,480x147,540x166,640x196,720x221,1080x331,1125x345&amp;from=bu&amp;cs=1125x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n<hr>\r\n2.2 Выбираем тип задачи \"Эпик\"  и вводим название \"Авторизация\" и \"Создать\"\r\n<img src=\"https://sun9-85.vkuserphoto.ru/s/v1/ig2/UgQbFGzy9QF0lu1FK0gQnDO__wUXLBjtpO16Qs-aDQBRAcP4zIdpJFYYXsBO5pdZqRS4A4ydTi34c7OLXrisZKOy.jpg?quality=95&amp;as=32x45,48x68,72x101,108x152,160x225,240x338,360x507,480x676,540x761,640x902,720x1015,853x1202&amp;from=bu&amp;cs=853x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nЭпики так же можно создать в разделе беклога:\r\n<img src=\"https://sun9-50.vkuserphoto.ru/s/v1/ig2/-xQbhJaTnQcwMcoaN7ruUA1TTV8CXxBI9rFiC5KnDOXXTRLRQELWnbdhVtMb0ckxOGY4xOQdyBEmWMz8YzC3-SOM.jpg?quality=95&amp;as=32x11,48x17,72x26,108x38,160x57,240x85,360x128,480x170,540x192,640x227,720x255,1080x383,1280x454,1440x511,2560x908&amp;from=bu&amp;cs=2560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>3. Наполнение Backlog</summary>\r\n<div>\r\nБудем заполнять  Stories/Tasks/Bugs в эпик бэклога.\r\n\r\nВнутрь эпика давляем рабочие элементы:\r\n- Story (\"пользовательская история\") \"Пользователь может войти по логину/паролю\"\r\n- Task (\"техническая задача\") \"Добавить endpoint /login\"\r\n- Bug (\"дефект\") - когда уже что-то сломано, например \"авторазлогин после авторизации\"\r\n\r\n\r\nПереходим в раздел бэклог &gt; слева выбираем эпик &gt; выбираем необходимый тип задачи &gt; вводим название &gt; нажимаем создать:\r\n<img src=\"https://sun9-46.vkuserphoto.ru/s/v1/ig2/FbQ8hEMd-xqfAeIQVfaXu1KQ46J5ww2a8eceJ3Tnj-Te4KbNzfGBbL16W3MJv1cB3Uc0pP6kRwJlfxTufbEc3WHz.jpg?quality=95&amp;as=32x15,48x22,72x33,108x50,160x74,240x111,360x167,480x222,540x250,640x296,720x333,1080x500,1280x592,1440x667,2560x1185&amp;from=bu&amp;cs=2560x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nВ реальности QA чаще создаёт Bug и иногда Task (например, \"Добавить логирование\", \"Уточнить требования\"), но это зависит от процессов.\r\n\r\n<img src=\"https://sun16-1.vkuserphoto.ru/s/v1/ig2/JxDMT7aQDf23pRRF9AmJ_CRFZHiq-nVr6dj0_CVTW0vTUcSFBv9GFa40Rng7tBJ9iVv-OvHe-xptWIz2XbWpV7GD.jpg?quality=95&amp;as=32x5,48x7,72x11,108x16,160x24,240x36,360x54,480x72,540x81,640x96,720x108,1080x161,1280x191,1440x215,2263x338&amp;from=bu&amp;cs=2263x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>4. Планирование спринта и старт спринта</summary>\r\n<div>\r\nПосле заполнения эпиков в бэклоге, необходимо спланировать спринт. Команда берёт несколько задач из бэклога и выполняет их. \r\n\r\n1. В backlog создается спринт и перетаскиваются туда задачи из бэклога. Atlassian описывает это как базовые шаги Scrum в Jira: создать Scrum-проект -&gt; backlog -&gt; создать sprint -&gt; планирование -&gt; начать sprint.\r\n<hr>\r\n<img src=\"https://sun9-35.vkuserphoto.ru/s/v1/ig2/m8UgzMeuyklD0hY1zl9VJQb5mZyAIy6aUWVa8KB5Ci5JlQV75QAoeaGHP6eBIG_zZEKWv5PkZ_O90TowgnVUUlOT.jpg?quality=95&amp;as=32x9,48x14,72x21,108x31,160x46,240x69,360x104,480x138,540x155,640x184,720x207,1080x311,1280x368,1440x414,2256x649&amp;from=bu&amp;cs=2256x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n<hr>\r\n2. Нажимаем \"Начать спринт\", задаем даты и цель спринта &gt; Начать\r\n<img src=\"https://sun9-15.vkuserphoto.ru/s/v1/ig2/q2PaVIgzAPI5e47EWRXN3223m2x5zHnxeete33oJ5SCXbJcwooKJbi13gyufydX7i5qfqWRIbLn_VehZEblxYK6y.jpg?quality=95&amp;as=32x11,48x17,72x25,108x37,160x55,240x83,360x125,480x166,540x187,640x222,720x250,1080x375,1280x444,1440x499,2301x798&amp;from=bu&amp;cs=2301x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n<hr>\r\n<b>Итог:</b> задачи из бэклога становятся Sprint Backlog (\"бэклог спринта\").\r\n<img src=\"https://sun9-50.vkuserphoto.ru/s/v1/ig2/UiCcN7tz6JHkt4a_ICqAuA1oI3eIXjDl_vPL0wWDO1xLSwBFxaUOWtWHCQ3axvqfNCbHtaPWf2f_8yXX_awAIPWk.jpg?quality=95&amp;as=32x6,48x9,72x13,108x19,160x29,240x43,360x65,480x86,540x97,640x115,720x129,1080x194,1280x230,1440x259,2265x407&amp;from=bu&amp;cs=2265x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>5. Разрабы взяли в работу</summary>\r\n<div>\r\nНа доске карточки двигаются по колонкам. Важно: колонки доски отображают статусы workflow, и \"колонка\" может соответствовать одному или нескольким статусам.\r\nТипичный минимальный поток: К выполнению &gt; В работе &gt; Готово\r\n\r\n<img src=\"https://sun9-25.vkuserphoto.ru/s/v1/ig2/OW09ZxCHJwzBq9SYuZ9Te9y3zCC_o-oX74KTAZWL9gqecN8OvPa-SdsRpu-19I-TjqfKuLuNoEWlcxbvsn7yDp02.jpg?quality=95&amp;as=32x11,48x16,72x24,108x37,160x54,240x81,360x122,480x163,540x183,640x217,720x244,1080x367,1280x435,1440x489,1626x552&amp;from=bu&amp;cs=1626x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nНо в командах обычно добавляют ещё:\r\n- \"Code Review\" (\"ревью кода\")\r\n- \"Ready for QA\" (\"готово для тестирования\")\r\n- \"QA In Progress\" (\"в тестировании\")\r\n- \"Blocked\" (\"заблокировано\")\r\n\r\n<img src=\"https://sun9-64.vkuserphoto.ru/s/v1/ig2/rfCNNR8QH2h9yXeEEcLVuO7CMzQ791i981iPhlEJ41JpNZpRsCiF6ITAgDKNdB-Ny_Sz9OXjTAi4_nmA41snALbX.jpg?quality=95&amp;as=32x7,48x10,72x15,108x23,160x34,240x51,360x77,480x102,540x115,640x136,720x153,1080x230,1280x272,1440x306,2102x447&amp;from=bu&amp;cs=2102x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>6. Функциональность готова и отправили на QA</summary>\r\n<div>\r\nРазработчики создали функциональность / исправили баг. И перенесли задачу дальше. В задаче назначается ответственный. В нашем случае сразу отправляется в QA:\r\n<img src=\"https://sun9-66.vkuserphoto.ru/s/v1/ig2/d-v65sKwM6lo8na59D-6jzYJSGUagjBIs1iPjWjnDIaad4wGiP9EsgePU7wThSwFouehY0ROen45fNauMjG51jXO.jpg?quality=95&amp;as=32x7,48x11,72x16,108x25,160x37,240x55,360x82,480x110,540x124,640x147,720x165,1080x247,1280x293,1440x330,2065x473&amp;from=bu&amp;cs=2065x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>7. Что делает QA </summary>\r\n<div>\r\nУ ответственного QA на доске появляется задача которую реализовали разработчики. Теперь предстоит его часть работы. \r\n\r\nQA открывает задачу и ознакамливается с её деталями. (Даблклик по задаче)\r\n\r\n<img src=\"https://sun9-22.vkuserphoto.ru/s/v1/ig2/vuzwmoPsnpzCMwvgcxLFRshqws9e3NKFmw5X98MOoAjdLm5XTzNFTVT-INIlhiY-7jOBKP58Pc-hUQkY2flzscTq.jpg?quality=95&amp;as=32x24,48x36,72x54,108x81,160x121,240x181,360x272,480x362,540x407,640x483,720x543,1080x815,1280x966,1336x1008&amp;from=bu&amp;cs=1336x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nДалее он так же переносит задачу, но на стадию \"В тестировании\". \r\n<img src=\"https://sun16-2.vkuserphoto.ru/s/v1/ig2/D1IuS2a4e55DMHD_0DaKc2K2PzRUDURuLw0JmMo9zkT_P3RkfKBUVojTcU2BQwvaagE3l_olBtTaXVvDij4lCUcq.jpg?quality=95&amp;as=32x8,48x12,72x18,108x27,160x39,240x59,360x89,480x118,540x133,640x158,720x178,1080x267,1280x316,1440x355,2026x500&amp;from=bu&amp;cs=2026x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nПосле чего начинает тестировать то что описано в этой задаче. Будь это новая фича, ретест, регресс и т.п.\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>8. Куда \"уходит\" задача после QA</summary>\r\n<div>\r\nЗависит от результата:\r\n- Всё хорошо &gt; \"Done (Готово)\" (или \"Ready for Release\", если релиз отделён от разработки)\r\n- Есть дефекты &gt; обратно в разработку \"In Progress (В работе)\" + отдельный Bug(и) в backlog/спринт\r\n\r\nНеясные требования &gt; \"Blocked\" или Task на аналитика/PO (\"product owner\" - \"владелец продукта\")\r\n\r\nВ нашем случае представим что тестирование прошло успешно, и баг исправлен. QA переносит задачу в \"Готово\":\r\n<img src=\"https://sun9-57.vkuserphoto.ru/s/v1/ig2/fzo_WL-sVcMnANhiPsT9c__7aCcZM1NslhX87oV5ncxeUYlUvTVOc1gr8SoWucmlqRdH67WeI7u3KboRODnral-i.jpg?quality=95&amp;as=32x7,48x11,72x16,108x24,160x35,240x53,360x80,480x106,540x120,640x142,720x159,1080x239,1280x283,1440x319,2050x454&amp;from=bu&amp;cs=2050x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>9. Как закрывается спринт (и что бывает с незавершёнными задачами)</summary>\r\n<div>\r\nВ конце нажимают \"Complete sprint\" (\"завершить спринт\"). \r\nJira при этом: оставшиеся незакрытыми задачи переносит в backlog или будущий спринт .\r\n\r\n<img src=\"https://sun9-46.vkuserphoto.ru/s/v1/ig2/G2basxgHoO9eCQWuKQfyX6z2iN0SfYAwkSTgA-t5AytjCQfpLSjDh1hzdLvtwYvehc1boQ3Xy7Lf-6OVNlvTOHzi.jpg?quality=95&amp;as=32x3,48x5,72x8,108x12,160x17,240x26,360x39,480x52,540x59,640x70,720x79,1080x118,1280x140,1440x157,2291x250&amp;from=bu&amp;cs=2291x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\n<img src=\"https://sun9-67.vkuserphoto.ru/s/v1/ig2/Ln8KXeI5cAAM_Aak_usqZ3v4PUgolboA1cC2RxsiSBKP94UYGMPJcuP2Dy-F0cNNrpR6pQ0F62Tv7-mNx_fn7lJr.jpg?quality=95&amp;as=32x18,48x27,72x41,108x61,160x90,240x135,360x203,480x271,540x304,640x361,681x384&amp;from=bu&amp;cs=681x0\" data-target=\"#imageModal\" onclick=\"showImage(this.src)\" class=\"mx-auto d-block\" style=\"cursor: pointer; max-width: 500px; max-height: 400px;\">\r\n\r\nСпринт закрывают не потому что \"всё идеально\", а потому что timebox (\"фиксированный срок\") закончился. Незавершёнка не должна маскироваться - она должна быть явно видна и перенесена.\r\n</div>\r\n</details>\r\n\r\n<details>\r\n<summary>Как это выглядит в Kanban</summary>\r\n<div>\r\nKanban - это непрерывный поток: задачи просто двигаются по колонкам, а не \"упаковываются\" в спринты. Atlassian прямо пишет: в Scrum нужно создать и стартовать sprint, в Kanban - просто вести задачи на доске.\r\n\r\nВ Kanban логика такая:\r\n- есть WIP limits (\"лимиты незавершённой работы\") - чтобы не копить \"In Progress\"\r\n- релиз/срез качества обычно делается по версии/дате, а не \"закрытием спринта\"\r\n\r\nQA в Kanban делает то же самое по сути (проверка, возврат, баги), просто нет ритуала \"закрыть спринт\".\r\n\r\n<img src=\"https://sun9-42.vkuserphoto.ru/s/v1/ig2/OZcF-Jj1QQlEJLxjuge1E0g1EZWh2jl4SZVE5RL-_knJ2PL8Au_xnGTkHExb-cqpoKpJfCi8pxUuGB6KgSQtgMMC.jpg?quality=95&as=32x14,48x21,72x31,108x47,160x69,240x104,360x156,480x208,540x234,640x277,720x312,1080x468,1280x555,1440x624,1581x685&from=bu&cs=1581x0\" />\r\n</div>\r\n</details>","path":"-"}},{"title":"AllPairs","data":{"code":"-","description":"В ожидании","path":"-"}}]},{"header":"QA Automation","links":[{"title":"Postman Newman","data":{"code":"-","description":"В ожидании","path":"-"}},{"title":"Playwright","data":{"code":"-","description":"В ожидании","path":"-"}},{"title":"Selenium","data":{"code":"-","description":"В ожидании","path":"-"}}]},{"header":"QA практика"},{"header":"JavaScript основы","links":[{"title":"Типы данных и динамическая типизация","data":{"code":"//Примеры:\r\nconst n = 123; // nubmer\r\nconst s = \"Hello\"; // string\r\nconst b = false; // bool\r\nconst u; // undefined\r\nconst na = 123 * \"Hello world\"; // NaN","description":"В JavaScript существует несколько типов данных. Тип данных инициализируется во время первичного присваивания какого либо значения.\n\nТипы данных:\nnumber - числовой тип данных, хранит в себе любые значения состоящие из чисел 123\nbool - булевый тип данных, хранит в себе данные вида истина/ложь - true/false - 1/0\nstring - хранит в себе любые строки 'привет мир', \"Привет мир\", `Привет мир`\nundefined - означает что значения в переменной нет\nnull - неопределённое значение, никакое значение из вышеперечисленных \nNaN - is non a number, появляется при попытке выполнить математические операции между типами данных, которые не подразумевают их. Допустим 'A' * 3; \n\nВсе типы данных основаны на Object \n\n\n","path":"Типы данных и динамическая типизация"}},{"title":"Объекты и массивы","data":{"code":"//Примеры\r\nlet obj = {\r\nname: 'foo',\r\nsurname: 'bar'\r\n};\r\n\r\nlet arr = ['foo', 'bar'];\r\nlet objArr = {0: 'Значение 1', 1: 'Значение 2', 2: 'Значение 3', length: 3};\r\n\r\n\r\n//Методы и объекты внутри объекта\r\nconst obj = {\r\n    name: 'test',\r\n    width: 1024,\r\n    height: 768,\r\n    colors: {\r\n        border: 'black',\r\n        bg: 'red',\r\n    },\r\n    makeTest: function () {\r\n        console.log(\"test\");\r\n    }\r\n};\r\n\r\n\r\n//работа с массивами\r\nconst arrTest = [1, 2, 3, 4];\r\narrTest.pop(); //удалить последний элемент массива\r\nconsole.log(arrTest);\r\narrTest.push(5); //добавить элемент в конец\r\nconsole.log(arrTest);\r\n\r\nconst intArr = [1, 2, 44, 5, 18];\r\nfunction compareNum(a, b) {\r\n    return a - b;\r\n}\r\nintArr.sort(compareNum); //сортировать по int через калбэк\r\nconsole.log(intArr);\r\n\r\n\r\n//Объект создаётся один (экземпляр), и мы через переменные указываем на них (указатель). \r\n//Тем самым мы не можем просто так сделать на подобии обычных переменных\r\nlet obj1 = {\r\na: 'foo',\r\nb: 'bar'\r\n};\r\nlet obj2 = obj1; //у нас 2 переменные будут ссылаться на 1 экземпляр объекта, и если мы из obj1 что то изменим, то изменится и в obj2\r\n\r\n//для этого есть spread оператор, это такой оператор короче гуглите (коротко выдаёт всё что есть в объекте/массиве)\r\nconst obj1 = {\r\n    one: 1,\r\n    two: 2,\r\n    tree: 3\r\n};\r\n\r\nconst obj2 = {\r\n    ...obj1,  //развернули объект и вставили данные из него в новый объект\r\n}\r\nobj2.one = 4;\r\nconsole.log(obj1);\r\nconsole.log(obj2);\r\n\r\n\r\n//Деструктуризация объекта\r\nconst obj = {\r\na: 'foo',\r\nb: 'bar',\r\ncolors: {\r\n    border: '2px',\r\n     bg: 'red'\r\n  }\r\n};\r\nconst { border, bg } = obj.colors; //деструктуризация, получить вложенные данные из объекта в переменные \r\nconsole.log(bg);\r\n\r\nconst obj = {\r\n    name: 'test',\r\n    width: 1024,\r\n    height: 768,\r\n    colors: {\r\n        border: 'black',\r\n        bg: 'red',\r\n    },\r\n    makeTest: function () {\r\n        console.log(\"test\");\r\n    }\r\n};\r\n\r\n//удаление из объекта\r\ndelete obj.name; //удаляет свойство и значение из объекта\r\n\r\n//получение ключей объекта\r\nconsole.log(Object.keys(obj)); //получить все ключи объекта в виде массива\r\n\r\n//перебор объекта\r\nfor(let key in obj) {\r\n     console.log(`Свойство: ${key} \\ значение ${obj[key]}`);\r\n }\r\n//перебрать прям всё всё\r\nfunction getFromObj(item, str = '-') {\r\n    for (let key in item) {\r\n        if (typeof (item[key]) == 'object') {\r\n            console.log(`${str} Object: ${key}`);\r\n            getFromObj(item[key], str + '-');\r\n        } else {\r\n            console.log(`${str} Свойство: ${key} \\ значение ${item[key]}`);\r\n        }\r\n    }\r\n}\r\ngetFromObj(obj);\r\n","description":"Всё что есть в JavaScript'e основано на объектах. Каждый тип данных, классы, функции конструкторы. \nОбъекты объявляются фигурными скобками { };\nВ объекте присутствуют ключ и значение: key: \"value\"; (в основном так)\n\nТак же есть массивы и псевдомассивы. \nМассивы - ну это ясно что, не хочу объяснять, они во всех ЯП одинаковые. Объявляются квадратными скобками []. \nВ массиве присутствуют значения: ['value1', 'value2']; (в основном так)\n\nПсевдомассивы это объекты похожие на массивы, но имеющие внутри себя свойство length а так же он наследует прототипирование __proto__ \n\n\nОбъекты могут хранить в себе другие объекты, разные типы данных и методы.\nМассивы могут хранить в себе разные типы данных.","path":"Объекты и массивы"}},{"title":"Циклы и переборы","data":{"code":"\r\n//цикл с предусловием\r\nlet i = 0;\r\nwhile (i < 2) {\r\n    i++;\r\n   console.log(i); \r\n}\r\n\r\n//цикл с постусловием\r\nlet i = 0;\r\ndo {\r\n  console.log(i);\r\n} while(i < 2);\r\n\r\n//цикл с заданным количеством повторений\r\nfor(let i = 0; i < 2; i++) {\r\n  console.log(i);\r\n}\r\n\r\n//перебор\r\nconst arrTest = [1, 2, 3, 4];\r\n\r\narrTest.forEach(function (item, key, arr) { //элемент, ключ (итератор), массив\r\n    console.log(`${key}/${item}/${arr}`);\r\n});\r\n\r\n\r\n'use scrict';\r\n\r\n\r\n\r\n//>>>>>>>>>>>>>filter\r\n//Фильтрация массивов методом перебора filter\r\n//Filter возвращает новый массив\r\nconst names = [\r\n    'Ivan',\r\n    'Alex',\r\n    'Alexander',\r\n    'Ann'\r\n];\r\nconst shortNames = names.filter(item => {\r\n    return item.length < 5; //если длина каждого итема меньше 5\r\n});\r\nconsole.log(shortNames);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//>>>>>>>>>>>>> map\r\n//Перебрать массив и  изменить каждый элемент внутри, и вернуть новый изменённый масив\r\nconst answers = [\r\n    'IvAn',\r\n    'ANna',\r\n    'HeLLo'\r\n];\r\n\r\nconst resultAnswers = answers.map(item => item.toLowerCase()); //опять жэ, если 1 парамтер и 1 действие в функции, то можно сделать так\r\n//Аналог:\r\n/*\r\n    (item) => {\r\n        return item.toLowerCase();\r\n    }\r\n*/\r\nconsole.log(resultAnswers);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//>>>>>>>>>>>>> every/some\r\n//Функции перебора массива, проверка на совпадение, если какой то из элементов будет совпадать с some - вернётся true \r\n//С every наоборот, он проверят все значения на совпадение, и если какой то элемент не совпадает у условием вернётся  false\r\nconst someArray = [\r\n    4,\r\n    'asd',\r\n    'dsq'\r\n];\r\n\r\nconsole.log(someArray.some(item => typeof (item) === 'number')); //есть ли число в массиве (true)\r\n\r\nconst everyArray = [\r\n    4,\r\n    'asd',\r\n    'dsq'\r\n];\r\nconsole.log(someArray.every(item => typeof (item) === 'number')); //все ли числа в массиве? нет (false)\r\n\r\n\r\n\r\n\r\n\r\n//>>>>>>>>>>>>> reduce\r\n//Собрать массив в единное целое\r\n\r\n//у reduce 2 аргумента функции, 1 аргумент - сумма (резулбтат крч, то что будет return) предыдущего итератора перебора, 2 аргумент - текущий итем перебора\r\n//изначально sum = 0\r\n//Так же у reduce есть 3й агрумент, который присваивает начальное состояние для sum \r\nconst reduceArray = [\r\n    4,\r\n    5,\r\n    3,\r\n    2,\r\n    1\r\n];\r\n\r\nconsole.log(reduceArray.reduce((sum, current) => sum + current));\r\n\r\n//вариант со строками\r\nconst reduceArray2 = [\r\n    'Apple',\r\n    'Samsung',\r\n    'Xiaomi'\r\n];\r\nconsole.log(reduceArray2.reduce((sum, item) => `${sum}, ${item}`));\r\n\r\n\r\n\r\n\r\n\r\n//Example\r\n\r\nconst obj = {\r\n    ivan: 'persone',\r\n    ann: 'persone',\r\n    dog: 'animal',\r\n    cat: 'animal'\r\n};\r\n\r\n\r\nconst newArray = Object.entries(obj)\r\n    .filter(item => item[1] === 'persone')\r\n    .map(item => item[0]);\r\nconsole.log(newArray); //ivan, ann","description":"Циклы неотъемлемая часть любого ЯП. Конструкция циклов в JavaScript схожа со всеми остальными Си подобными языками. \nИмеются те же 3 основных вида циклов: цикл с предусловием, цикл с постусловием, цикл с заданным количеством повторений.\n\nПереборы это такой метод, который перебирает все данные внутри массивов. Он останавливается только когда данные будут все обработаны. Вызывается через forEach","path":"Циклы и переборы"}},{"title":"Раздновидности функций + ES6","data":{"code":"-","description":"Функции это отдельный участок кода, который можно вызвать и выполнять в любой момент, в любом месте (почти). Я даже не знаю зачем пишу дескрипшн по функциям. И так ясно, но ладно.\n\nВ JavaScript можно объявить несколько видов функций. \n\nОбычная функция (function declaration)\nСоздаётся как function nameFunction(arg) { }\nДанная функция доступна сразу после инициализации кода. И вызвать её можно до её объявления.\n\nОбъявленная функция (function expression)\nСоздаётся как const myFunc = function (arg) { }\nЭту функцию можно вызвать только после её создания.\n\nСтрелочная функция ES6\nне имеет контекста this (в данном случае)\nconst testFunc = (a) =&gt; console.log(a);\n\n\n","path":"-"}},{"title":"Работа со строками string","data":{"code":"const fromServer = \"Один,Два,Три,Четыре\";\r\nconst parseToArr = fromServer.split(','); //разделить по , в массив\r\nparseToArr.sort(); //сортировать по алфавиту (только str)\r\nconsole.log(parseToArr);\r\nconst toString = parseToArr.join(';'); //соединить через ; (обратно из массива в str)\r\nconsole.log(toString);\r\n\r\nconst str = \"Hello world\";\r\nconsole.log(str.length); //свойство (длина строки)\r\nconsole.log(str.toUpperCase()); //функция (все большие буквы)\r\nconsole.log(str.indexOf(\"world\")); //функция (получить индекс начала совпадения строки)\r\nconsole.log(str.slice(str.indexOf(\"world\"), str.length)); //функция, взять из строки с индекса по индекс \r\nconsole.log(str.substring(str.indexOf(\"world\"), str.length)); //функция, взять из строки с индекса по индекс (то же самое только без отрицательных значений)\r\nconsole.log(str.substr(str.indexOf(\"world\"), 5)); //функция, взять из строки с индекса, длину","description":"Такая же неотъемлемая часть любого ЯП. Описывать не вижу смысла. Но методы опишу ниже в коде.","path":"Работа со строками string"}},{"title":"Логические операторы","data":{"code":"-","description":"•\tКакое будет выведено значение: let x = 5; alert( x++ ); ?\n•\t5\n\n•\tЧему равно такое выражение: [ ] + false - null + true ?\n•\tNaN\n\n\n•\tЧто выведет этот код: let y = 1; let x = y = 2; alert(x); ?\n•\t2\n\n\n•\tЧему равна сумма [ ] + 1 + 2?\n•\t12\n\n\n•\tЧто выведет этот код: alert( \"1\"[0] )?\n•\t1\n\n\n•\tЧему равно 2 &amp;&amp; 1 &amp;&amp; null &amp;&amp; 0 &amp;&amp; undefined ?\n1.\t&amp;&amp; - запинается на лжи (false)\n2.\t(2 – true &amp;&amp; 1 – true) - true, пошли дальше вернули 1\n3.\t(1 – true &amp;&amp; Null - false), Запнулись на false\n4.\tNull – false, запнулись, вернули null\n\n\n\n•\tЕсть ли разница между выражениями? !!( a &amp;&amp; b ) и (a &amp;&amp; b)?\n•\tСлева bool а справа number – не равны \n\n\n•\tЧто выведет этот код: alert( null || 2 &amp;&amp; 3 || 4 ); ?\n1.\t&amp;&amp; - запинается на лжи (false) \n1.1\tlet a = 5;\nlet b = 3;\n(a &amp;&amp; b) будет return b; //у оба нас true,  вернул последнее значение b\n\nlet a = null;\nlet b = 3;\n(a &amp;&amp; b) будет return a; //у нас первое false, запнулись на нём, вернули a\n\n2.\t|| - запинается на правде (true) \n2.1\tlet a = 5;\nlet b = 3;\n(a || b) будет return a; //у нас первое true, вернул a\n\nlet a = null;\nlet b = 3;\n(a || b) будет return b; //у нас второе true, вернул b\n3.\tСначала сравниваем null || 2 – первое false не запнулись, второе true запнулись вернули 2\n\n4.\tПотом сравниваем 2 &amp;&amp; 3 – у нас оба true, мы не запнулись и вернули 3\n5.\tПотом сравниваем 3 || 4 – первое true, значит запнулись, выводим 3\n6.\tИтого наш alert выведет 3\nP.S: null - false, undefined - false, 0 – false, NaN – false, “” - false; всё остальное true, [] – true, {} – true, 1 – true, “a” - true\n\n\n•\ta = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?\n•\tfalse\n\n•\tЧто выведет этот код: alert( +\"Infinity\" ); ?\n•\tЕго и выведет number Infinity\n\n•\tВерно ли сравнение: \"Ёжик\" &gt; \"яблоко\"?\n•\tFalse, по юникоду надо смотреть \n\n\n•\tЧему равно 0 || \"\" || 2 || undefined || true || falsе ?\n\n1.\tТ.к. у нас || запинается на true\n2.\t0 = false – не запнулись пошли дальше\n3.\t“” = false – не запнулись пошли дальше\n4.\t2 =  true, запнулись вернули 2\n","path":"-"}},{"title":"Преобразование типов данных","data":{"code":"const testMath = \"12.2px\";\r\nconsole.log(parseInt(testMath)); //перевод str в int\r\nconsole.log(parseFloat(testMath)); //перевод str в float\r\n\r\nconst num = 12.3;\r\nconsole.log(Math.round(num)); //округление числа (тоже лишним не будет здесь)\r\n","description":"Конвертирование из одного типа данных в другой. Нужно для того что бы адекватно выполнять допустим математические операции. Т.к. все поля которые отправляет пользователь всегда в string.","path":"Преобразование типов данных"}},{"title":"Прототипирование","data":{"code":"const soldier = {\r\n    health: 100,\r\n    armor: 100,\r\n    sayHello: function () {\r\n        console.log('Hello');\r\n    }\r\n};\r\n\r\nconst john = {\r\n    health: 100\r\n};\r\n\r\n//устаревший формат наследования:\r\njohn.__proto__ = soldier;  //прототип джона - солдат, унаследовали так сказать\r\nconsole.log(john.armor); //взяли из родительского свойство \r\njohn.sayHello();\r\n//новый формат который лучше использовать\r\nconst ivan = {\r\n    health: 50\r\n};\r\n\r\nObject.setPrototypeOf(ivan, soldier); //привязать прототип soldier к ivan (когда объект ivan уже создан)\r\nivan.sayHello();\r\n\r\nconst andrey = Object.create(soldier); //создать объект наследуя прототип soldier\r\nivan.sayHello();","description":"ООП (но тут прототипно-ориентированый язык по сути, всё что есть в js - переменные, массивы, функции, все наследуются от __proto__ прототип)\n (конечная точка наследований прототипов всех массивов,переменных,функций это  объект Object)\nПоэтому JS это не прям по сути ООП, а ПОП прототипно ориентированное программирование","path":"Прототипирование"}},{"title":"Работа с элементами на странице","data":{"code":"'use strict';\r\n\r\n//старый вид селекта элементов (тут нет forEach)\r\n//HtmlCollection\r\nconst box = document.getElementById('box');\r\nconst buttons = document.getElementsByTagName('button');\r\nconst circles = document.getElementsByClassName('circle');\r\n//новый вид селектора элементов (тут есть forEach)\r\n//NodeList\r\n//Получает псевдомассив\r\nconst boxNew = document.querySelectorAll('#box');\r\nconst buttonsNew = document.querySelectorAll('button');\r\nconst hearts = document.querySelectorAll('.heart');\r\n//Получить только первый элемент\r\n//Возвращает сразу первый попавшийся элемент\r\nconst circleOne = document.querySelector('.circle');\r\n\r\n// box.style.background = 'blue';\r\nbox.style.width = '500px';\r\nbuttons[1].style.borderRadius = '100%';\r\ncircles[0].style.background = 'red';\r\nbox.style.cssText = \"background: blue; height: 300px; width: 100px\";\r\n\r\n\r\nfor(let i = 0; i < buttons.length; i++) {\r\n    buttons[i].style.cssText = \"background-color: yellow; color: black;\";\r\n}\r\n\r\nhearts.forEach(item => {\r\n    item.style.background = \"blue\";\r\n});\r\n\r\nconst text = document.createTextNode('Привет мир');\r\n\r\nconst div = document.createElement('div');\r\ndiv.classList.add('black');\r\ndocument.body.append(div);\r\n// document.querySelector('.wrapper').append(div); //вставить в конец блока\r\n// document.querySelector('.wrapper').prepend(div); //вставить в начало блока\r\n// hearts[0].before(div); //добавить перед этим элементом\r\n// hearts[0].after(div); //добавить после этим элементом\r\n// circles[0].remove(); //удалить элемент\r\n// hearts[0].replaceWith(circles[0]); //заменить собой каким то элементом\r\n\r\n//Устаревшие команды\r\n// document.body.appendChild(div);\r\n// document.querySelector('.wrapper').insertBefore(div, hearts[1]); //вставить в начало блока после какого-то\r\n// document.querySelector('.wrapper').removeChild(hearts[2]); //удалить какой то элемент у родителя (нельзя удалить сразу тот элемент)\r\n// document.querySelector('.wrapper').replaceChild(div, hearts[1]); //заменить какой то элемент на какой то у родителя (нельзя заменить сразу элемент)\r\n//Всё дальше норм\r\ndiv.innerHTML = \"<h1>Hello</h1>\"; //вставить что то внутрь HTML\r\n// div.textContent = \"<h1>Hello world</h1>\"; //вставить только как текст\r\n\r\n//beforebegin - перед началом элемента (перед открыважщим тегом)\r\n//afterbegin - после начала элемента (внутри элемента, перед всеми его дочерними)\r\n//afterend - после конца элемента (после закрывающего тега)\r\n//beforeend - перед концом элемента (внутри элемента, перед закрывающим тегом)\r\ndiv.insertAdjacentHTML('beforeend', '<h1>world</h1>'); //вставить (перед, после,  в) элементе\r\n\r\n\r\n","description":"Самая важная часть JavaScript это работа с элементами. Мы должны уметь найти элемент, изменять его свойства. Цепляться к событиям разным. И очень много всего. Тут мы затронем только несколько возможностей. А именно: поиск элемента в html, изменение inline css стилей элемента, вставка html до, после или перед элементом. Код ниже, всё описано.","path":"Работа с элементами на странице"}},{"title":"События Events","data":{"code":"'use strict';\r\n\r\nconst\r\n    btn = document.querySelector('#btn'),\r\n    overlay = document.querySelector('.overlay'),\r\n    link = document.querySelector('a');\r\n\r\n//устаревший формат, лучше не юзать\r\n//нельзя добавить ещё одно событие\r\n//нельзя удалить событие\r\n btn.onclick = function () {\r\n     alert('asd');\r\n };\r\n\r\n//правильный вариант\r\n//события выполняются только в порядке очереди\r\n//можно добавлять кучу функций на одно событие\r\n//можно удалять события\r\n btn.addEventListener('click', () => {\r\n     alert('dsa');\r\n });\r\n\r\n btn.addEventListener('click', () => {\r\n     alert('ads');\r\n });\r\nlet i = 0;\r\nconst deleteElement = function(e) {\r\n    console.log(e.target); //получает конечный элемент события (вложенный)\r\n    console.log(e.currentTarget); //получает тот элемент, на котором было событие\r\n    console.log(e.type);\r\n    i++;\r\n     if (i == 1) {\r\n         btn.removeEventListener('click', deleteElement);\r\n     }\r\n};\r\nbtn.addEventListener('click', deleteElement, {\r\n    once: true //выполнить всего 1 раз\r\n});\r\noverlay.addEventListener('click', deleteElement);\r\n\r\n\r\nlink.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    console.log(e.target);\r\n});","description":"События это участки кода, которые вызываются во время определённых действий на странице. Допустим пользователь нажал на кнопку, это событие будет click, и мы средствами JS подцепляемся к этому событию, и выполняем необходимые действия.","path":"События Events"}},{"title":"Элементы (Elements) и Ноды (Nodes)","data":{"code":"console.log(document.body);\r\nconsole.log(document.head);\r\nconsole.log(document.documentElement);\r\nconsole.log(document.body.childNodes); //полчить всех наследников (Узлы/ноды) от родителя body (включая перенос строк text) в виде псевдомассива\r\nconsole.log(document.body.firstChild); //получить первого наследника (Узлы/ноды) внутри родителя (включая перенос строк)\r\nconsole.log(document.body.lastChild); //получить последнего наследника (Узлы/ноды) внутри родителя (включая перенос строк)\r\nconsole.log(document.querySelector('#current').parentNode); //получить родителя\r\nconsole.log(document.querySelector('#current').parentNode.parentNode); //получить родителя родителя (включая перенос строк)\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').nextSibling); //получить следующий узел (включая перенос строк)\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').previousSibling); //получить предыдущий узел (включая перенос строк)\r\n\r\n//получить только элемент, не узел\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').nextElementSibling); //получить следующий элемент\r\nconsole.log(document.querySelector('li[data-current=\"3\"]').previousElementSibling); //получить предыдущий элемент\r\nconsole.log(document.querySelector('#current').parentElement); //получить родителя\r\nconsole.log(document.querySelector('#current').parentElement.parentElement); //получить родителя родителя\r\nconsole.log(document.body.firstElementChild); //получить первого наследника внутри родителя (Элемент)\r\nconsole.log(document.body.lastElementChild); //получить последнего наследникавнутри родителя (Элемент)\r\n\r\n//получить всех наследников за исключением узлов текстовых (включая перенос строк)\r\nfor (let node of document.body.childNodes) {\r\n    if (node.nodeName == \"#text\") continue;\r\n    console.log(node);\r\n\r\n}","description":"В JS есть чёткая грань между элементами и нодами HTML документа. \nВо время селекта нод, в них входят узлы. Узлы это текст, элемент, перенос строки, комментарии.\nА элемент это тупо HTML элемент со своими методами.","path":"Элементы (Elements) и Ноды (Nodes)"}},{"title":"Работа с классами элемента","data":{"code":"'use strict';\r\n\r\nconst btns = document.querySelectorAll('button');\r\n console.log(btns[0].classList.length); //количество классов у элемента\r\n console.log(btns[0].classList.item(0)); //получить класс из списка в виде строки\r\n btns[0].classList.add('red'); //добавить класс элементу (можно через запятую кучу)\r\n btns[0].classList.remove('blue'); //удалить класс у элемента (можно через запятую кучу)\r\n btns[0].classList.toggle('blue'); //тоглер класса (знаешь что это)\r\n\r\n if(btns[0].classList.contains('red')) { //проверка на существование класса, возвращает true \r\n     console.log('У кнопки есть класс RED');\r\n }\r\n\r\nbtns[0].addEventListener('click', () => {\r\n    if(btns[1].classList.contains('red')) {\r\n        btns[1].classList.remove('red');\r\n    } else {\r\n        btns[1].classList.add('red');\r\n    }\r\n    //аналогично\r\n    // btns[1].classList.remove('red');\r\n});\r\n\r\n//устаревшее\r\n console.log(btns[0].className); //возвращает как строку всегда (лучше не юзать)\r\n\r\n//делеширование событий (нескольким элементам задать одно действие на событие. Т.е. выдать общему родителю клик а потом от него отталкиваться)\r\n//делегирование событий родителя на его потомка\r\ndocument.querySelector('#first').addEventListener('click', (e) => {\r\n     console.log(e.target);\r\n     console.log(targetElement.tagName)\r\n     console.log(e.target.matches('button'));\r\n    if(e.target && e.target.matches('button')) { //ищет совпадение в элементе, если будет то вернёт true (можно button.red button#firstBtn и т.п.)\r\n    // if(e.target && e.target.tagName == 'BUTTON') {\r\n        console.log('Кликнули на кнопку родителя div');\r\n    }\r\n    \r\n});\r\n","description":"Описания не будет. Сразу в код.","path":"Работа с классами"}},{"title":"Таймеры","data":{"code":"'use strict';\r\n\r\nconst btn = document.querySelector('.btn');\r\n\r\nfunction anime() {\r\n    const el = document.querySelector('.box');\r\n    let pos = 0;\r\n    const id = setInterval(frame, 10);\r\n\r\n    function frame() {\r\n        if(pos == 300) {\r\n            clearInterval(id);\r\n        } else {\r\n            pos++;\r\n            el.style.top = pos+\"px\";\r\n            el.style.left = pos+\"px\";\r\n        }\r\n    }\r\n}\r\n\r\nbtn.addEventListener('click', (e) => {\r\n    e.preventDefault();\r\n    anime();\r\n});\r\n\r\n////////////////////////////////////\r\n let timerId2,\r\n    i = 0;\r\n\r\n btn.addEventListener('click', (e) => {\r\n     e.preventDefault();\r\n     // const timerId2 = setTimeout(logger, 2000);\r\n     timerId2 = setInterval(logger, 2000);\r\n });\r\n\r\n\r\nconst timerId = setTimeout((text) => {\r\n    console.log(text);\r\n }, 2000, 'Hello');\r\n\r\n\r\n function logger() {\r\n     console.log('Text');\r\n     i++;\r\n    if(i == 3) {\r\n        clearInterval(timerId2);\r\n    }\r\n }\r\n","description":"setTimeOut - выполняется 1 раз и всё\nsetTinterval - выполняется всегда пока его не очистишь clearInterval\n\nsetInterval не учитывает время выполнения кода функции, и при большом тайминге функции, интервал запустит следующий итератор \nsetTimeOut ожидает выполнения функции, после чего отсчитывает опять заданное количество МС и выполняет дальше \n\nлучше всего использовать рекурсивный setTimeOut (который вызывает сам себя изнутри) чем setInterval\n// let id = setTimeout(function log() {\n//     console.log('World');\n//     id = setTimeout(log, 500);\n// }, 500);","path":"Таймеры"}},{"title":"Работа с датами Date","data":{"code":"'use strict';\r\n\r\n\r\nconst now = new Date();\r\n\r\n//Геттеры\r\nconsole.log(now.getFullYear()); //получить год\r\nconsole.log(now.getMonth()); //получить месяц (0 - январь, 1 - февраль и т.п.)\r\nconsole.log(now.getDate()); //получить день (как обычно с 1)\r\nconsole.log(now.getDay()); //получить номер дня недели (воскресенье 0 день, суббота 6 день)\r\n//с часовыми поясами\r\nconsole.log(now.getUTCHours()); //получает местное время и по гринвичу\r\nconsole.log(now.getTimezoneOffset()); //получить разницу во времени между местным и гринвичем\r\nconsole.log(now.getTime()); //получить unix'time миллисекунд (от 1 января 1970)\r\n\r\n//Сеттеры\r\nnew Date.parse('2021-01-05'); // парсинг даты\r\nconsole.log(now.setHours(18)); //перевести время на 18:00 где 00 будет текущие минуты\r\nconsole.log(now);\r\n\r\n//Пример бенчмарка по времени выполнения\r\nlet start = new Date();//текущая дата до операций\r\nfor(let i = 0; i < 100000; i++) {\r\n    let some = i ** 3; //ввести в степень каждый раз (стандарт ES7 **)\r\n}\r\nlet end = new Date();//конечная дата после операций\r\nalert(`Цикл отработал за ${end - start} мс`); //разница между датами (всё по unix'time кэп)\r\n\r\n\r\n//Пример обратного отсчёта таймеры+дата (сколько осталось до конца акции)\r\n    //Timer\r\n    const deadline = '2021-01-07';\r\n\r\n    function getTimeRemaining(endtime){\r\n        const t = Date.parse(endtime) - Date.parse(new Date()),\r\n                days = Math.floor(t / (1000 * 60 * 60 * 24)),\r\n                hours = Math.floor((t / (1000 * 60 * 60)) % 24),\r\n                minutes = Math.floor((t / 1000 / 60) % 60),\r\n                seconds =  Math.floor((t / 1000) % 60);\r\n        return {\r\n            'total': t,\r\n            'days': days,\r\n            'hours': hours,\r\n            'minutes': minutes,\r\n            'seconds': seconds\r\n        };\r\n    }\r\n\r\n    function getZero(number) {\r\n        if(number >= 0 && number < 10) {\r\n            return `0${number}`;\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function setClock(selector, endtime) {\r\n        const timer = document.querySelector(selector),\r\n                days = timer.querySelector('#days'),\r\n                hours = timer.querySelector('#hours'),\r\n                minutes = timer.querySelector('#minutes'),\r\n                seconds = timer.querySelector('#seconds'),\r\n                timerInterval = setInterval(updateClock, 1000);\r\n        function updateClock() {\r\n            const t = getTimeRemaining(endtime);\r\n            days.innerHTML = getZero(t.days);\r\n            hours.innerHTML = getZero(t.hours);\r\n            minutes.innerHTML = getZero(t.minutes);\r\n            seconds.innerHTML = getZero(t.seconds);\r\n            if(t.total <= 0) {\r\n                clearInterval(timerInterval);\r\n            }\r\n        }\r\n        updateClock();\r\n    }\r\n    setClock('.timer', deadline);","description":"Описание даже не знаю что. Позже напишу.","path":"Работа с датами Date"}},{"title":"Функции конструкторы","data":{"code":"function User(name, id) {\r\n    this.name = name;\r\n    this.id = id;\r\n    this.human = true;\r\n    this.hello = () => {\r\n        console.log(`Hello ${this.name}`);\r\n    };\r\n}\r\n\r\nUser.prototype.exit = function () { //расширяем функционал конструктора\r\n    console.log(`${this.name} вышел`);\r\n};\r\n\r\nconst ivan = new User('Иван', 22);\r\nconst alex = new User('Alex', 25);\r\n\r\nivan.hello();\r\nalex.hello();\r\n\r\nivan.exit();\r\nalex.exit();\r\n\r\nconsole.log(ivan);\r\nconsole.log(alex);\r\n\r\n\r\n//пример инкапсуляции\r\nfunction User(name, lname, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n    let lastname = lname; //имитирование инкапсуляции, данная переменная небудет доступна извне \r\n    this.say = function () {\r\n        console.log(`Привет ${this.name} ${lastname} ваш возраст ${this.age}`);\r\n    };\r\n\r\n    this.setLastName = function (newlastname) { //создали метод сеттер (именно как метод)\r\n        //тут так же валидацию прикрутить можно и мутаторы\r\n        lastname = newlastname;\r\n    };\r\n\r\n    this.getLastName = function() { //создали метод геттер (именно как метод)\r\n        return lastname;\r\n    };\r\n}\r\n\r\nconst test = new User('Ras', 'Testerov', 26); //создаём объект функции конструктора \r\n\r\n//получим то что сейчас есть в свойствах объекта\r\nconsole.log(test.name);\r\nconsole.log(test.age);\r\nconsole.log(test.lastname); // undefined (прямого доступа нет)\r\nconsole.log(test.getLastName()); // через геттер будет\r\n\r\n//пробуем модифицировать данные\r\ntest.age = 25;\r\ntest.name = 'FANtasy';\r\ntest.lastname = 'Edited1'; //прямого доступа нет\r\ntest.setLastName('Edited2'); //через сеттер будет \r\n//получаем что сейчас там\r\ntest.say();","description":"Функции конструкторы  это объекты которые могут хнарить в себе прототипные данные и функции\n    Это сделано для того что бы можно было создавать множество однотипных объектов но с разными свойствами\n    Общее правило в создании функций конструкторов то что он начинается с заглавной буквы\n    Создание нового объекта функции конструктора выполняется через new\n    К каждому элементу функции конструатора обращение идёт через this\n    В функциях конструкторах можно добавить новые прототипные данные и функции через .prototype.foo = bar;\n    Функции конструкторы это стандарт ES5\n    В ES6 добавили сахар для этого, под видом обычного ООП class ","path":"Функции конструкторы"}},{"title":"Контекст this","data":{"code":"'use strict';\r\n\r\n\r\n// в обычной функции классической function() this == window\r\n// при использовании 'use strict' this == undefined \r\n\r\n\r\nfunction showThis(a,b) {\r\n    console.log(this); //== undefined\r\n    function sum() {\r\n        console.log(this); //== undefined\r\n        return this.a + this.b; // undefined + undefined == error\r\n    }\r\n\r\n    console.log(sum());\r\n}\r\nshowThis(4,5);\r\n\r\n\r\n//если используется метод внутри объекта, контекст this ссылается на сам объект\r\nconst obj = {\r\n    a: 20,\r\n    b: 15,\r\n    sum: function() {\r\n        console.log(this);\r\n        function shout() { //будет undefined т.к. это уже не метод а обычная функция (не стрелочная)\r\n            console.log(this);\r\n        }\r\n    }\r\n};\r\nobj.sum();\r\n\r\n\r\n// //this в конструкторах и классах это новый экземпляр объекта \r\nfunction User(name, id) {\r\n    //фактически this = {} \r\n    //далее в этот объект добавляются свойства и методы \r\n    this.name = name;\r\n    this.id = id;\r\n    this.human = true;\r\n    //return this;\r\n}\r\n\r\n// const ivan = new User('Иван', 22);\r\n\r\n\r\n//ручная привязка this через apply и call\r\n//контекст this можно передать в функцию, через методы apply и call\r\n//функции абсолютно одинаковые\r\n//в параметрах функции передаём объект для контекста\r\n//можно сказать что это sayName где инициализируется user\r\nfunction sayName(surname) {\r\n    console.log(this);\r\n    console.log(this.name + ' '+ surname);\r\n}\r\n\r\nconst user = {\r\n    name: 'John'\r\n};\r\n\r\nsayName.call(user, 'Test'); //передача контекста this (передача аргументов функции передаются через запятую)\r\nsayName.apply(user, ['Testo']); //передача контекста this (а тут передача аргументов в виде массива)\r\n\r\n\r\n//ручная привязка this через bind\r\n//контекст this так же можно передать через создание новой функции средствами bind\r\n//double это новая функция к которой привязан контекст this\r\n//где мы в контекст присвоили 2\r\n//далее вызываем новую функцию double где передаём аргумент функции, т.к. контекст this у нас 2, то 2*3 = 6\r\nfunction count(num) {\r\n    return this * num;\r\n}\r\nconst double = count.bind(2);\r\nconsole.log(double(3));\r\n\r\n\r\nconst btn = document.querySelector('button');\r\n\r\nbtn.addEventListener('click', function () { //если объявление обработчика событий в классическом стиле function() { }\r\n    console.log(this); //конекст является сам элемент \r\n    //проще this == event.target;\r\n});\r\n\r\n//стрелочная же функция не передаёт контекст this\r\n//она наследует this от своего родителя\r\nconst obj2 = {\r\n    num: 5,\r\n    sayNubmer: function() { //метот ссылается на объект в котором он существует\r\n        const say = () => {\r\n            console.log(this); //в нашем случае контекст вернёт родителя sayNumber т.к. это стрелочная функция\r\n        }\r\n        say();\r\n    }\r\n}\r\n\r\nobj2.sayNubmer();\r\n\r\n\r\n\r\nbtn.addEventListener('click', () => { //если объявление обработчика событий в стрелочном стиле \r\n    console.log(this); //конекст является window (родитель кнопки window)\r\n});\r\n\r\n","description":"Как у старших ЯП есть this. Которая обращается к текущему экземпляру объекта. Все примеры ниже в коде","path":"Контекст this"}},{"title":"Классы Class ES6","data":{"code":"//название класса всегда с заглавной буквы\r\nclass Rectangle {\r\n    constructor(height, width) {\r\n        this.height = height;\r\n        this.width = width;\r\n    }\r\n\r\n    calcArea() {\r\n        return this.height * this.width;\r\n    }\r\n}\r\n\r\nconst recCalc = new Rectangle(20, 30);\r\nconst recCalc2 = new Rectangle(40, 40);\r\nconsole.log(recCalc.calcArea());\r\nconsole.log(recCalc2.calcArea());\r\n\r\n//Наследование\r\nclass ColoredRectangleWithText extends Rectangle {\r\n    constructor(height, width, color, text) {\r\n        super(height, width); //вызывает конструктор родителя (в нашем случае Rectangle) всегда первой строчкой\r\n        this.color = color;\r\n        this.text = text;\r\n    }\r\n\r\n    showProps() {\r\n        return `${this.text}; ${this.color}`;\r\n    }\r\n}\r\n\r\nconst coloredRectangle = new ColoredRectangleWithText(100, 100, 'red', 'Example');\r\n\r\nconsole.log(coloredRectangle.showProps());\r\nconsole.log(coloredRectangle.calcArea());\r\n\r\n//Инкапсуляция\r\nclass UserData {\r\n    constructor(name, lname, age) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this._lastname = lname; \r\n    }\r\n\r\n    say() {\r\n        console.log(`Привет ${this.name} ${this._lastname} ваш возраст ${this.age}`);\r\n    }\r\n\r\n    set lastname(newlastname) { //создали метод сеттер (именно как сеттер)\r\n        //тут так же валидацию прикрутить можно и мутаторы\r\n        this._lastname = newlastname;\r\n    }\r\n\r\n    get lastname() { //создали метод геттер (именно как сеттер)\r\n        return this._lastname;\r\n    }\r\n}\r\nconst testUser = new UserData('Ras', 'Testerov', 26); //создаём объект класса\r\n\r\n//получим то что сейчас есть в свойствах объекта\r\nconsole.log(testUser.name);\r\nconsole.log(testUser.age);\r\nconsole.log(testUser._lastname); //прямой доступ есть, но переменные с нижним подчёркиванием в начале нельзя трогать (правило кодеров ЖС, вот такая тебе инкапсуляция)\r\nconsole.log(testUser.lastname); // через геттер будет\r\n\r\n//пробуем модифицировать данные\r\ntestUser.age = 25;\r\ntestUser.name = 'FANtasy';\r\ntestUser._lastname = 'Edited1'; //прямой доступ есть, но переменные с нижним подчёркиванием в начале нельзя трогать (правило кодеров ЖС, вот такая тебе инкапсуляция)\r\ntestUser.lastname = 'Edited2'; //через сеттер будет \r\n//получаем что сейчас там\r\ntestUser.say();\r\n\r\n//полиморфизм (переопределение на свои методы, перезапись родительских)\r\nclass Person {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    me() {\r\n        return `My name is ${this.name}`; \r\n    }\r\n}\r\nconst axel = new Person('Axel');\r\nconsole.log(axel.me());\r\nclass Employee extends Person {\r\n    constructor(name, salary) {\r\n        super(name);\r\n        this.salary = salary;\r\n    }\r\n    me() {  //вот тут полиморфизм, мы перезаписали метод родителя, но доступны свойства родителя\r\n        return `My name is ${this.name} and my salary is ${this.salary}`;\r\n    }\r\n}\r\nconst nick = new Employee('Nick', 3000);\r\nconsole.log(nick.me());","description":"Классы появились с ES6\nКлассы это те же функции конструкторы, только в красивой обёртке (сахар)","path":"Классы Class ES6"}},{"title":"POST и GET через XMLHttpRequest ","data":{"code":"//POST запрос \r\n\r\n  const request = new XMLHttpRequest(); //создаём экземпляр класса\r\n            request.open('POST', 'server.php'); //выполняем настройки \r\n            // request.setRequestHeader('Content-type', 'multipart/form-data'); //заголовок от FormData заполняется автоматически если отправлять FormData, если хедеры использовать такие то будут пустые данные\r\n            request.setRequestHeader('Content-type', 'application/json'); //Если через JSON то надо выставлять такой тип контента (обязательно formData нужно парсить в JSON)\r\n            const Fdata = new FormData(form); //получаем данные с формы (любой)\r\n            const obj = {}; //объект\r\n\r\n            Fdata.forEach(function (value, key) { //через перебор из FormData получаем \r\n                obj[key] = value; //в объект\r\n            });\r\n\r\n            const json = JSON.stringify(obj); //парсим в JSON \r\n            request.send(json); //отправляем на бэкэнд JSON\r\n//в случае с FormData то можно просто request.send(Fdata); без setRequestHeader\r\n\r\n//проверка состояния запроса\r\n  request.addEventListener('load', (e) => { //подцепляем событие load\r\n                if (request.status === 200) { //если 200 ОК\r\n                    console.log(request.response); //тут наш ответ от бэкэнда\r\n                } else {\r\n                    //тут остальные ошибки\r\n                }\r\n            });\r\n\r\n//GET\r\nconst request = new XMLHttpRequest(); //такой же экземпляр класса\r\n\r\n    request.open('GET', 'current.json'); //собрать настройки для запроса\r\n    request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); //настройка заголовков\r\n    request.send(); //отправка запроса\r\n\r\n    // request.addEventListener('readystatechange', () => { //статус запроса  (каждый раз будет обрабатываться при изменени состояния readyState, по readyState можно загуглить)\r\n    request.addEventListener('load', () => { //статус запроса \r\n        //request.readyState - проверка состояния запроса, их 4 (подробнее в гугле)\r\n        if(request.status == 200) { //readyState 4 done по запросу, request по status 200 OK\r\n            console.log(request.response); //ответ от бэкэнда\r\n        } else {\r\n          //ошибка\r\n        }\r\n    });","description":"В старых стандартах использовался AJAX запрос XMLHttpRequest. В данный момент его не используют. Но есть старые разработки, где он встречается. Поэтому его лучше знать.","path":"POST и GET через XMLHttpRequest "}},{"title":"Promise (Промисы)","data":{"code":"//Создание промиса выглядит так\r\n//resolve - это успешное выполнение кода\r\n//reject - неуспешное \r\nconst req = new Promise((resolve, reject) => {\r\n    setTimeout(() => { //симуляция запроса в бэкэнд\r\n        const product = {\r\n            name: 'Mouse',\r\n            order: 2000\r\n        };\r\n        console.log('Подготовка данных....');\r\n        resolve(product); //тут мы вызываем функцию успешного выполнения промиса\r\n        //в параметры выдаём то что нужно использовать дальше\r\n    }, 2000);\r\n});\r\n\r\nreq.then(data => { //сюда приходит дата из resolve(data);\r\n    //так же можно внутри промиса создать новый промис и отправить его через резолв\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => { //симуляция запроса в бэкэнд\r\n            data.status = 'ordered';\r\n            console.log('Модифицируем...');\r\n            reject(); //симулируем ошибку\r\n            // resolve(data);\r\n        }, 3000);\r\n    });\r\n}).then(data => { //т.к. у нас верху ретюрним промис с резолвом, то можем сразу вызвать резолв then\r\n    data.modify = true; //ещё раз модифицируем\r\n    return data; //возвращаем модифицированные данные (дальше резолвим)\r\n}).then(modifydata => { //так же дальше можем передать резолв следующей цепочке\r\n    console.log(modifydata);\r\n}).catch(() => { //если что то пошло нет так, то вызываем в любой цепочке reject и он сразу приходит в catch  (пропуская остальные цепочки)\r\n    console.error(`Ошибка данных`);\r\n}).finally(() => { //после всех цепочек и обработок ошибок будет выполняться всегда финальный каллбэк  (даже при catch reject)\r\n    console.log('Finally');\r\n    //тут какие либо манипуляции по очистке данных форм и т.п.\r\n});\r\n\r\n\r\nconst test = time => {\r\n    return new Promise(resolve => { //иногда можно обойтись без reject (очень редко)\r\n        setTimeout(() => {\r\n            resolve();\r\n        }, time); //запустить таймаут по time\r\n    });\r\n};\r\n\r\n// test(1000).then(() => {\r\n//     console.log('Резолв сработал 1000');\r\n// });\r\n// test(2000).then(() => {\r\n//     console.log('Резолв сработал 2000');\r\n// });\r\n\r\nPromise.all([test(1000), test(2000)]).then(() => { //запустить все промисы по очереди через .all и после всех выполнений сможем в resolve (.then)\r\n    console.log('Резолвы сработали');\r\n});\r\n\r\nPromise.race([test(1000), test(2000)]).then(() => { //запустить все промисы по очереди через .race и после первого выполнения будет resolve (.then) \r\n    console.log('Резолвы сработали');\r\n});\r\n\r\n\r\n//без комметов, просто пример повседневного промиса\r\nconst reqTest = new Promise((resolve, reject) => {\r\n    const product = {\r\n        name: 'Mouse',\r\n        order: 2000\r\n    };\r\n    if (product.order >= 2000) {\r\n        resolve(product);\r\n    } else {\r\n        reject();\r\n    }\r\n}).then(data => {\r\n    data.modify = true;\r\n    return data;\r\n}).then(mdata => {\r\n    mdata.mtest = false;\r\n    return mdata;\r\n}).then(test => {\r\n    console.log(test);\r\n}).catch(() => {\r\n    console.log('Error');\r\n}).finally(() => {\r\n    console.log('End');\r\n});","description":"Promise (промисы) нужны для последовательного выполнения асихронных операций\nт.к. от бэкэнда результат разных операций может приходить в разное время\nи нам необходимо что бы операции выполнялись последовательно (по цепочке)\n\n\nцепочка такая\nСоздаём промис new Promise в нём аргументы каллбэков resolve и reject\nresolve - это каллбэк успешного выполнения\nreject - не успешного\nКогда мы вызываем resolve() то дальшейшая цепочка выполнения каллбэчится к .then \nКогда какие либо ошибки, а так же reject будет каллбэчится к .catch ","path":"Promise (Промисы)"}},{"title":"Fetch","data":{"code":"  fetch('https://jsonplaceholder.typicode.com/posts', { //если не задавать объект с параметрами то будет просто GET\r\n        //объект параметров запроса \r\n        method: 'POST', //GET,POST,PUT,PATCH,DELETE\r\n        body: JSON.stringify({ //Данные отправляемые на сервер (в нашем случае JSON с данными)\r\n            name: 'Ras',\r\n            age: 25\r\n        }),\r\n        headers: { //заголовки запроса\r\n            'Content-type': 'application/json'\r\n        }\r\n    }) \r\n        .then(response => response.json()) //получили ответ и пропарсили черещ встроенный метод .json в fetch, который сразу продолжает промис (resolve)\r\n        .then(json => console.log(json)); //пропарсенный json выведем в консоль ","description":"Современная система отправки запросов и получения ответов от бэкэнда\nЗаменяет XMLHttpRequest, более гибок и может в промисы","path":"Fetch"}},{"title":"Rest и spread операторы","data":{"code":"//Пример Spread\r\nfunction sum(x, y, z) {\r\n  return x + y + z;\r\n}\r\nconst numbers = [1, 2, 3];\r\nconsole.log(sum(...numbers)); //вот тут разложили массив\r\n\r\nvar parts = ['shoulders', 'knees'];\r\nvar lyrics = ['head', ...parts, 'and', 'toes'];\r\n// [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"]\r\n\r\nvar obj1 = { foo: 'bar', x: 42 };\r\nvar obj2 = { foo: 'baz', y: 13 };\r\n\r\nvar clonedObj = { ...obj1 };\r\n// Object { foo: \"bar\", x: 42 }\r\n\r\nvar mergedObj = { ...obj1, ...obj2 };\r\n// Object { foo: \"baz\", x: 42, y: 13 }\r\n\r\n//Пример REST\r\n    //Аргументов REST можно писать хоть сколько т.к. это массив\r\n    class CardItem {\r\n        constructor(src, alt, subtitle, descriprion, price, parentElement, ...classes) { //Rest оператор у нас ...classes \r\n            this.src = src;\r\n            this.subtitle = subtitle;\r\n            this.descriprion = descriprion;\r\n            this.price = price;\r\n            this.alt = alt;\r\n            this.transfer = 27; // актуальный курс доллара \r\n            this.classes = classes;\r\n            this.changeToUAH();\r\n            this.parentElement = document.querySelector(parentElement);\r\n        }\r\n\r\n        changeToUAH() { //конвертация доляров в гривны по курсу\r\n            this.price = this.price * this.transfer;\r\n        }\r\n\r\n        render() {\r\n            const divElement = document.createElement('div');\r\n            if (this.classes.length) { //если не указали никакой аргумен в rest, будет пустой массив, поэтому проверяем на длинну массива\r\n                this.classes.forEach(className => divElement.classList.add(className)); // перебрали rest и добавили все классы в div \r\n            } else {\r\n                divElement.classList.add('menu__item');\r\n            }\r\n            divElement.innerHTML = `тут html код`;\r\n            this.parentElement.append(divElement);\r\n        }\r\n    }\r\n\r\n new CardItem(\r\n                    el.img,\r\n                    el.altimg,\r\n                    el.title,\r\n                    el.descr,\r\n                    el.price,\r\n                    '.menu .container',\r\n                    //тут начинаются REST агрументы \r\n                    'menu__item',\r\n                    'two__class',\r\n                    'tree__class'\r\n                ).render();","description":"Spread оператор, разбирает массив на переменные через запятую.\nЕго удобно использовать для клонирования объектов первого уровня (вложенные объекты не клонируются)\n\n<hr>\nRest оператор это такой оператор который указывается в аргументе функции\nРаботает как ...spread только наоборот, собирает аргументы в массив (spread наоборот выбирает из массива в переменные)\n Такой оператор ставится в конце функции, и все аргументы после основных будут записаны в Rest\n\nАргументов REST можно писать хоть сколько т.к. это массив","path":"Rest и spread операторы"}},{"title":"LocalStorage","data":{"code":"//Можно без window\r\nwindow.localStorage.setItem('foo', 'bar'); //установить значение в LocalStorage ключ foo значение bar \r\nwindow.localStorage.getItem('foo'); //получить значение из ключа foo \r\nwindow.localStorage.removeItem('foo'); //удалить ключ и значение из LocalStorage \r\nwindow.localStorage.clear(); //очистить весь LocalStorage \r\n\r\n//пример с формой\r\nconst checkbox = document.querySelector('#checkbox'), //сохранение состояния чекбокса \r\n    form = document.querySelector('form'),  //форма для примера\r\n    change = document.querySelector('#color'); //после нажатия на кнопку форма будет другого цвета и запомнит \r\n\r\nif (localStorage.getItem('isChecked')) {\r\n    checkbox.checked = true;\r\n}\r\n\r\nif (localStorage.getItem('isColored')) {\r\n    form.style.backgroundColor = 'red';\r\n}\r\n\r\ncheckbox.addEventListener('change', () => {\r\n    localStorage.setItem('isChecked', true);\r\n});\r\n\r\n\r\nchange.addEventListener('click', () => {\r\n    if (localStorage.getItem('isColored')) {\r\n        localStorage.removeItem('isColored');\r\n        form.style.backgroundColor = 'unset';\r\n    } else {\r\n        localStorage.setItem('isColored', true);\r\n        form.style.backgroundColor = 'red';\r\n    }\r\n}); \r\n\r\n//Запись JSON\r\nconst person = {\r\n    name: 'Ras',\r\n    age: 26\r\n};\r\n\r\nconst jsonPerson = JSON.stringify(person);\r\nlocalStorage.setItem('person', jsonPerson);\r\nconsole.log(JSON.parse(localStorage.getItem('person')));\r\n","description":"LocalStorage - это локальное хранилище данных для сайта. Данная система не может получить чужие данные с других доменов. \nМаксимальный объём данных которые можно записать в LocalStorage - 5 мегабайт. \nУ данной системы есть всего 2 поля, ключ и значение (key and value), очень похоже на куки, но это не они. \nДля примера в такую систему записывают корзину пользователя в магазине, или настройки внешнего вида сайта, время остановки плеера на странице (что бы можно было продолжить просмотр с этого  места), счётчики, таймеры и т.п. \nLocalStorage находится в window. Ниже примеры 4х методов LocalStorage. \nДанные лучше хранить в JSON формате ","path":"LocalStorage"}},{"title":"RegExp","data":{"code":"//В регулярных выражениях JS есть паттерны и флаги\r\n//Пример создания регулярки, которым не пользуются \r\nnew RegExp('pattern', 'flags');\r\n//Другой пример, который используют в основном\r\n/pattern/flags \r\n\r\n//Пример поиска по букве n (первое совпадение)\r\nconst ans = 'Anna';\r\nconst reg = /n/;\r\nconsole.log(ans.search(reg)); //выдаст 1 т.к. первая буква n находится на первой позиции в строке, если не найдёт то -1\r\n\r\n\r\n//Пример поиска по букве n (все совпадения)\r\nconst ans = 'AnNa';\r\nconst reg = /n/ig; //для того что бы найти все, необходимо добавить флаг после второго /\r\n//Примеры флагов:\r\n// i - поиск вне зависимости от регистра\r\n// g - поиск нескольких вхождений\r\n// m - многострочный режим (включая переносы)\r\nconsole.log(ans.match(reg)); //найдёт все вхождения по паттерну и флагам, вернёт массив \r\n\r\n\r\n//Замена строки\r\nconst pass = 'AnNa';\r\nconsole.log(pass.replace(/./gi, '*')); //заменить все символы на *\r\n\r\n\r\n//Проверить строку на определённый паттернт \r\nconst ans = 'Anna';\r\nconst reg = /n/;\r\nconsole.log(reg.test(ans)); //вернёт true т.к. в строке встречается буква n \r\n\r\n//номер телефона\r\nconst ans = '+77027570570';\r\nconsole.log(/^(\\+[1-9]|8)(\\d+|\\s|-|\\()(\\d+|\\()(\\d+)(\\d+|\\))(\\d+|\\s|\\))(\\d+|-)(\\d+|\\s)(\\d+|-)(\\d+|\\s)(\\d+|-)\\d*/gi.test(ans));\r\n\r\n//email \r\nconst ans = 'rassoft@bk.ru';\r\nconsole.log(/\\w+@\\w+.\\w+/gi.test(ans));","description":"Регулярные выражения необходимы для поиска/изменения/удаления/проверки определённых строк по шаблону.\n","path":"RegExp"}},{"title":"Геттеры и Сеттеры (Getters & Setters) ","data":{"code":"//Пример\r\nconst persone = {\r\n    name: 'Ras',\r\n    age: 26,\r\n\r\n    get userAge() { //геттер (если будет только геттер будет только чтение)\r\n        //внутри мутатор может быть\r\n        return this.age;\r\n    },\r\n\r\n    set userAge(num) { //название сеттера и геттера могут быть одинаковые, конфликта не будет \r\n        //внутри мутатор может быть\r\n        this.age = num;\r\n    }\r\n};\r\n\r\npersone.userAge = 30; //вызвали сеттер\r\nconsole.log(persone.userAge); //вызвали геттер \r\n","description":"Геттеры (Getters) и Сеттеры (Setters) - это ацессоры объекта\nОни позволяют получать или изменять свойства внутри объекта не соприкосаясь напрямую с ними\nГеттеры получают значение свойства\nСеттеры устанавливают значение свойства","path":"Геттеры и Сеттеры"}},{"title":"Инкапсуляция в JS","data":{"code":"//Пример на функциях конструкторах (ES5)\r\nfunction User(name, lname, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n    let lastname = lname; //имитирование инкапсуляции, данная переменная небудет доступна извне \r\n    this.say = function () {\r\n        console.log(`Привет ${this.name} ${lastname} ваш возраст ${this.age}`);\r\n    };\r\n\r\n    this.setLastName = function (newlastname) { //создали метод сеттер (именно как метод)\r\n        //тут так же валидацию прикрутить можно и мутаторы\r\n        lastname = newlastname;\r\n    };\r\n\r\n    this.getLastName = function() { //создали метод геттер (именно как метод)\r\n        return lastname;\r\n    };\r\n}\r\n\r\nconst test = new User('Ras', 'Testerov', 26); //создаём объект функции конструктора \r\n\r\n//получим то что сейчас есть в свойствах объекта\r\nconsole.log(test.name);\r\nconsole.log(test.age);\r\nconsole.log(test.lastname); // undefined (прямого доступа нет)\r\nconsole.log(test.getLastName()); // через геттер будет\r\n\r\n//пробуем модифицировать данные\r\ntest.age = 25;\r\ntest.name = 'FANtasy';\r\ntest.lastname = 'Edited1'; //прямого доступа нет\r\ntest.setLastName('Edited2'); //через сеттер будет \r\n//получаем что сейчас там\r\ntest.say();\r\n\r\n\r\n//Пример на классах (ES6)\r\n\r\nclass UserData {\r\n    constructor(name, lname, age) {\r\n        this.name = name;\r\n        this.age = age;\r\n        this._lastname = lname; \r\n    }\r\n\r\n    say() {\r\n        console.log(`Привет ${this.name} ${this._lastname} ваш возраст ${this.age}`);\r\n    }\r\n\r\n    set lastname(newlastname) { //создали метод сеттер (именно как сеттер)\r\n        //тут так же валидацию прикрутить можно и мутаторы\r\n        this._lastname = newlastname;\r\n    }\r\n\r\n    get lastname() { //создали метод геттер (именно как сеттер)\r\n        return this._lastname;\r\n    }\r\n}\r\nconst testUser = new UserData('Ras', 'Testerov', 26); //создаём объект класса\r\n\r\n//получим то что сейчас есть в свойствах объекта\r\nconsole.log(testUser.name);\r\nconsole.log(testUser.age);\r\nconsole.log(testUser._lastname); //прямой доступ есть, но переменные с нижним подчёркиванием в начале нельзя трогать (правило кодеров ЖС, вот такая тебе инкапсуляция)\r\nconsole.log(testUser.lastname); // через геттер будет\r\n\r\n//пробуем модифицировать данные\r\ntestUser.age = 25;\r\ntestUser.name = 'FANtasy';\r\ntestUser._lastname = 'Edited1'; //прямой доступ есть, но переменные с нижним подчёркиванием в начале нельзя трогать (правило кодеров ЖС, вот такая тебе инкапсуляция)\r\ntestUser.lastname = 'Edited2'; //через сеттер будет \r\n//получаем что сейчас там\r\ntestUser.say();","description":"Инкапсуляция один из столпов ООП. \nПозволяет сокрыть данные/свойства внутри класса, защищая их от изменения и прямого доступа. \n\nВ JS нет прям такой нормальной ООПшной инкапсуляции, но есть имитирование её. ","path":"Инкапсуляция в JS"}},{"title":"Модули и Замыкание","data":{"code":"//Пример модуля методом приватного замыкания (автоматический)\r\n//Замыкание, тут мы решаем проблему глобального просртанства\r\nconst number = 1;  //глобальная переменная \r\n//Отдельный модуль так сказать\r\n(function(){  //анонимная самовызывающаяся функция (сразу запускается при загрузке)\r\n    //создали собстветтую область видимости \r\n    let number = 2; //переменная внутри анонимной самовызвающийся функции\r\n    console.log(number); //мы изменяем данные внутненней переменной (замкнулись)\r\n    console.log(number+3);\r\n}());\r\nconsole.log(number); //извне вызвается переменная из глобального пространства \r\n\r\n\r\n\r\n\r\n//Пример модуля, объектный интерфейс (то же самое замыкание, но уже дёргать методы объекта можно)\r\nconst User = (function(){ //так же создаём анонимную самовызывающуюся функцию, но присвоим её в переменную\r\n    const privat = function() { //внутри у нас есть метод, который выполняет определённую логику\r\n        console.log('I am a private function');\r\n    };\r\n    return { sayHello: privat }; //вот тут мы возвращаем из этой функции объект, в котором имеется метод privat (то что нам нужно), и мы извне можем дёргать за него, но он не будет в глобальном пространстве \r\n}());\r\n\r\nUser.sayHello();\r\n","description":"Проблема глобальных пространств в том что если создать глобальную переменную, \nи вдруг такая же переменная имеется в другом JS файле, то будет беда. \n\nРешением является модульность (замыкание), это когда мы оборачиваем переменные/методы внутри анонимной функции, в которой будет логика. \nВсе переменные внутри анонимной функции будут глобальным только для неё, выше уже не видно переменную. \n\nТак же модули позволяют освободить глобальное пространство. Что в свою очередь решает проблему перебивания глобальных переменных. \n\nЗакон JSсера - как можно меньше переменных в глобальном пространстве. ","path":"Модули и Замыкание"}},{"title":"CommonJS + WebPack","data":{"code":"//Файл index.js \r\nconst myModule = require('./js/main');\r\nconst myModuleInstance = new myModule();\r\nmyModuleInstance.hello();\r\nmyModuleInstance.goodbye();\r\n\r\n//файл main.js\r\nfunction myModule() {\r\n    this.hello = function() {\r\n        console.log('hello');\r\n    };\r\n\r\n    this.goodbye = function() {\r\n        console.log('bye');\r\n    };\r\n}\r\n\r\nmodule.exports = myModule;\r\n","description":"CommonJS - система позволяющая разделить код на логические модули, которые могут работать незавимимо друг от друга. \n\n    Для примера имеется основной файл куда импортируются модули index.js \n    и какой то для примера main.js \n\n    В main.js мы создаём функцию конструктор (или класс, или объект)\n    и импортируем его как модуль через module.exports = [Название вашего класса/объекта/функции конструктора]; \n\n    Далее, что бы его подключить в главный файл сборщика, необходимо в самом сборщике его импортировать \n    Пример: const moduleVariable = require('Путь до вашего модуля');\n    Так как в нашем случае это функция конструктор, то её нужно инициализировать через new \n    const moduleVariableInstance = new moduleVariable();\n\n    Всё, дальше мы можем использовать все методы и свойства внутри модуля. \n\n    Что бы всё это рабоотало, необходимо так же использовать сборщик (допустим webPack)\n    Он собирает все файлы в единное целое. Сам браузер не умеет так, он не знает  require, module.exports и т.п. \n\n    Все модули должны находиться в папке /src/js (По стандарту webpack)\n    Сам же файл основной в /src/index.js\n    Естественно всё это можно перенастроить по своему усмотрению. (webpack.config.js гугли)\n\n    - для сборки билда вводится npx webpack \n    - как установить webpack в гугл\n\n    после сборки в папке dist создаются конечные файлы","path":"CommonJS + WebPack"}},{"title":"Modules ES6","data":{"code":"файл index.js\r\n// as можно изменить название переменной\r\nimport {one as first,two} from './js/main'; //для именованного импорта/экспорта обязательно фигурные скобки \r\n\r\n//импорт абсолютно всего \r\nimport * as data from './js/main';\r\n\r\nconsole.log(`${first} and ${two}`);\r\nconsole.log(`${data.one} and ${data.two}`); //обращаться в модуль через data. \r\ndata.sayhi();\r\n\r\n\r\n//файл main.js\r\nexport let one = 1;\r\n\r\nlet two = 2; \r\nexport {two};\r\n\r\n//экспорт по дефолту export default (он должен быть только один в файле)\r\n//позволяет экспортировать напрямую, не как именованную, и использовать её в конечном файле как обычную функцию \r\nexport function sayhi() {\r\n    console.log('Hello');\r\n}","description":"В ES6 есть система экспорта и импорта модулей\r\n    что бы что-то экспортировать пишется export  (Далее переменная допустим let asd; или функция и т.п.)\r\n    Преимущество данной системы в том что в 1 файле модуля может быть несколько экспортируемых данных (пример в файле main.js)\r\n\r\n    Для импорта естественно import ппример ниже. \r\n\r\n    Всё так же собирается сборщиками ","path":"Modules ES6"}}]},{"header":"ReGex","links":[{"title":"Основные понятия и примеры","data":{"code":"-","description":"Регулярные выражения (RegEx) - это способ поиска совпадений шаблона с текстом.\nРегулярные выражения могут находить по точному совпадению строки, допустим \"Hello\"\nРегулярные выражения чувствительны к регистру.\nА так же у них есть определённые спецсимволы.\n\n\n1) <b>.</b> - любой одиночный символ (точка)\nПример: \n<b>b.</b> - у нас получается, найти совпадение где строка начинается на b и рядом любой другой символ \n<b>b..</b> - двум любым символам (любой свимвол, пробелы, точки и т.п.)\n\n<hr>\n\n2) <b>[]</b> - любой из них. Всё что будет в этих скобках, будет поиск по любому совпадению. \nПример: \n<b>[Ii]</b> - найти совпадение, в которых будет либо большая I либо маленькая i\n<b>[Ii].</b> - либо большая I либо маленькая i и любой одиночный символ после \n<b>[a-d].</b> - диапазон от a до d (либо диапазон), и содержит любой одиночный символ после аналог [abcd].\nДиапазон так же можно указать в числах: [0-9]\nДиапазон дроби <b>[0-9].[0-9]</b> но в таком случае будет совпадение и с 4a5 т.к. точка это любой символ \nТак же через запятую <b>[a-b,w-z]</b>\nНаоборот не содержит <b>[^sw]</b> - найдёт строки которые не содержут эти символы \n\n\n<hr>\n\n3) <b>$</b> - конец строки. Само за себя говорит.\nПример:\nДопустим все строки которые заканчиваются на точку:\n\\.$ - обратный слеш будет экранирование (что бы точка работала как точка а не как любой символ)\n\n\n<hr>\n\n4) ^ - начало строки. Само за себя говорит.\n\nПример:\n^[Hh] - Любой из них H или h в начале строки. \n^T - строки которые начинаются с большой буквы T\n\n\n<hr>\n\n\n5) \\d - любая единичная цифра \nПример: \n\\d\\d\\d - три любых цифры  аналог [0-9][0-9][0-9]\n\n<hr>\n\n\n6) \\D - всё что угодно, кроме цифр \n\\d\\D\\d - любая цифра, не цифра, любая цифра \n\n<hr>\n\n\n7) \\s - поиск пробелов \nПример: \nen\\s - найти слова которые заканчиваются на en\n\n<hr>\n\n\n8) \\S - всё проме пробелов \nПример: \nen\\S - найти слова в которых есть en \n\n<hr>\n\n\n9) \\w - любая буква (одна буква)\nПример:\n\\w\\w\\w\\w\\s - любые 4 буквы и пробел (слово)\n\n<hr>\n\n\n10) \\W - всё кроме букв \n\\W\\W\\W - допустим троеточие (включая пробелы)\n\n\n<hr>\n\n\n11) \\b - граница строки\nПример: \n\\b...\\b - граница строки из 3х символов \n\\b\\w\\w\\w\\b - граница строки из 3х букв \n\n\n<hr>\n\n12) \\B - всё кроме не границ (больше или меньше, но не равно)\n\\B\\w\\w\\w\\B -  все слова кроме 3 букв\n\n<hr>\n<hr>\n\nКвантификация, лаконичное сочетание правил шаблона к строкам\n\n1) {} - повторение какого-то правила шаблона \nПример: \n\\b\\w{3}\\b - граница строки из 3х букв \nn{4} - искать n подряд 4 раза \nn{4,6} - искать n от 4 до 6 раз \n\n<hr>\n\n2) * - от нуля и выше \nПример: \nbe* - найти слова в которых совпадают символы be от 1 количества раз до бесконечности \n\n\n<hr>\n\n3) + - от одно и выше \nПример: \nbe+ - найти слова в которых совпадает последовательно символы be от 1 количества раз до бесконечности\n\n<hr>\n\n4) ? - от нуля или 1 раз \nПример: \nbe? - найти слова в которых совпадают символы be от 0 количества раз до бесконечности \n\n\n<hr>\n\n5) () - группировка \n\\d{4}(\\s|-) - 4 цифры далее пробел или - \n\n\n\n<hr>\n<hr>\n\nБольшой пример всего: \nНомер кредитной краточки\n4444 4545 8545 8545\n\n\\d{4}\\s\\d{4}\\s\\d{4}\\s\\d{4} - 4 цифры, пробел, 4 цифры, пробел, 4 цифры, пробел, 4 цифры\n\\d\\d\\d\\d \\d\\d\\d\\d \\d\\d\\d\\d \\d\\d\\d\\d \\d\\d\\d\\d - аналог то что сверху \n[0-9]{4}\\s[0-9]{4}\\s[0-9]{4}\\s[0-9]{4} - аналог то что сверху \n\\d{4}[\\s,-]\\d{4}[\\s,-]\\d{4}[\\s,-]\\d{4} - либо пробел между 4 цифрами, либо - между 4 цифрами \n\\d{4}(\\s|-)\\d{4}(\\s|-)\\d{4}(\\s|-)\\d{4} - пробел между 4 цифрами (или | ) тире - между 4 цифрами \n\n\nТелефонный номер:\n+7 (702) 757 05 70\n^\\+[1-9]\\s\\(\\d{3}\\)\\s\\d{3}\\s\\d{2}\\s\\d{2}\n\nпродвинутый \n+7 (702) 757 05 70\n+7(702)7570570\n+7-(702)-757-05-70\n+77027570570\n+77121457512\n88005553535\n87252533867\n\n^\\+\\d(\\s|-|\\d|\\()(\\d{3}|\\()(\\d{3}|\\))(\\)|\\d{2}|\\s|\\d|-)(\\s|-|\\d{2})(\\d{3}|$|-|\\s)(\\s|-|$)(\\d{2}|$)(\\s|-|$)(\\d{2}|$)\nвероятно не очень правильно, но пока так \nДругой вариант: \n^(\\+[1-9]|8)(\\d+|\\s|-|\\()(\\d+|\\()(\\d+)(\\d+|\\))(\\d+|\\s|\\))(\\d+|-)(\\d+|\\s)(\\d+|-)(\\d+|\\s)(\\d+|-)\\d*\n\nEmail:\nhello@bk.ru\nhello@ru\n@bk.ru\n\n\\w+@\\w+.\\w+\n","path":"-"}}]}]